<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  <meta name="baidu-site-verification" content="codeva-0Qx7wvY9gP" />
  
  <title>『glibc源码补完计划』UnsortedBin | C_LBY&#39;s BLOG</title>
  <meta name="author" content="鎏柏鱼">
  
  <meta name="description" content="glibc_2.23，除非特别说明，否则下文默认为此版本下的分析。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="『glibc源码补完计划』UnsortedBin"/>
  <meta property="og:site_name" content="C_LBY&#39;s BLOG"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="C_LBY&#39;s BLOG" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">C_LBY&#39;s BLOG</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class="fa fa-rss"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> 『glibc源码补完计划』UnsortedBin</h1>
		</div>
	



	<div class="row post">
		<!-- cols -->
		
			<div id="top_meta"></div>
			<div class="col-md-9">
				

							<!-- content -->
							<div class="mypage">
								
									<div class="alert alert-success description">
										<i class="fa fa-info-circle"></i> glibc_2.23，除非特别说明，否则下文默认为此版本下的分析。
									</div> <!-- alert -->
									

										<h2 id="UnsortedBin"><a href="#UnsortedBin" class="headerlink" title="UnsortedBin"></a>UnsortedBin</h2><p>最近学习堆题的时候接触到了unsortedbin的利用，感觉还挺有意思的，所以先把它的源码读了，方便以后构建利用思路。之所以这里分析glibc2.23的代码而非2.35的代码，是因为从2.29开始，unsortedbin加入了一坨检查机制以至于它在高版本下难以被攻击，所以索性读低版本的了。</p>
<p>glibc2.23在unsortedbin中取chunk的时候的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)|| __builtin_expect (victim-&gt;size &gt; av&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,chunk2mem (victim), av);</span><br></pre></td></tr></table></figure>

<p>glibc2.29对unsortedbin链表完整性的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line">       size = chunksize (victim);</span><br><span class="line">       mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">           || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">           || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">           || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="Unsorted-Bin的基本情况-对一些变量的理解"><a href="#Unsorted-Bin的基本情况-对一些变量的理解" class="headerlink" title="Unsorted Bin的基本情况 &amp; 对一些变量的理解"></a>Unsorted Bin的基本情况 &amp; 对一些变量的理解</h3><p>当用户申请一块堆内存的时候，malloc会先去fast bin里找适合的chunk，如果没有则去找small bin，如果还没有这才去找unsorted bin。也就是说如果考虑unsorted bin attack，那就要先考虑到前面两个bin的影响。unsorted bin是一个双向链表，取放的原则是FIFO。最先放入的chunk我们叫尾部，最后放入的叫头部，取出chunk的时候是从尾部取的。</p>
<p><code>unsorted_chunks(av)</code>: unsorted bin的堆头。unsorted bin一旦被使用，就会初始化这个堆头，它和main_arena在相同glibc版本下有着固定偏移（比如glibc2.23中是main_arena+0x58）。<br><code>av</code>: 一个指向当前arena地址的指针，也就是指向分配区的指针。<br><code>victim</code>: 指当前unsorted bin链表中处于尾部的chunk。<br><code>bck</code>: victim的上一个chunk。<br><code>nb</code>: 用户申请的chunk大小，包括了维护chunk的0x10结构部分。<br><code>remainder</code>: unsorted bin中的chunk被切割后剩下的部分。<br><code>last_remainder</code>: 最后一次被切割的chunk剩下的部分。</p>
<p>Unsorted Bin由一个循环的双向链表维护，也就是说，链表的头部chunk的bk会指向堆头，而尾部chunk的fd也会指向堆头，如下图所示（chunk0先被释放可看做尾部，chunk1后被释放可看做头部）：</p>
<p><img src="https://c-lby.github.io/images/glibc_unsortedbin/unsortedbin%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="unsortedbin循环链表"></p>
<p>不难想象，如果unsorted bin中只含有一个chunk，那么这个chunk的fd和bk都会指向堆头，堆头的fd和bk都会指向这个chunk。</p>
<h3 id="malloc时unsorted-bin的行为"><a href="#malloc时unsorted-bin的行为" class="headerlink" title="malloc时unsorted bin的行为"></a>malloc时unsorted bin的行为</h3><p>接下来我们将源码分段来分析。以下分析顺序基于unsorted bin的行为顺序。</p>
<h5 id="一些基本检查"><a href="#一些基本检查" class="headerlink" title="一些基本检查"></a>一些基本检查</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*其他的下面再看*/</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码检查了unsorted bin中是否含有chunk，设置了victim和bck两个变量，并且检查victim的size字段。这个检查相当地简单，所以给予了我们攻击的可能。当然，这种可能在2.29之后概率就很低了。</p>
<h5 id="对唯一chunk的分割"><a href="#对唯一chunk的分割" class="headerlink" title="对唯一chunk的分割"></a>对唯一chunk的分割</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">          If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">          only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">          runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">          exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">          no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; <span class="comment">//用户申请的大小在smallbin范围中</span></span><br><span class="line">           bck == unsorted_chunks (av) &amp;&amp; <span class="comment">//unsorted bin中只有唯一chunk</span></span><br><span class="line">           victim == av-&gt;last_remainder &amp;&amp; <span class="comment">//这个chunk是上一次被分割的chunk（包括尚未被分割的chunk）</span></span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) <span class="comment">//这个chunk的size大于用户申请的大小+MINSIZE</span></span><br><span class="line">         &#123;</span><br><span class="line">           <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">           remainder_size = size - nb; <span class="comment">//剩余部分的大小</span></span><br><span class="line">           remainder = chunk_at_offset (victim, nb); <span class="comment">//剩余部分的chunk地址</span></span><br><span class="line">           unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; <span class="comment">//修改堆头的fd和bk</span></span><br><span class="line">           av-&gt;last_remainder = remainder; <span class="comment">//更新最后被分割的chunk指针</span></span><br><span class="line">           remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); <span class="comment">//修改剩余部分的fd和bk</span></span><br><span class="line">           <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">             &#123;</span><br><span class="line">               remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">               remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>)); <span class="comment">//设置取出来的部分的size字段 </span></span><br><span class="line">           set_head (remainder, remainder_size | PREV_INUSE); <span class="comment">//设置剩余部分的size字段</span></span><br><span class="line">           set_foot (remainder, remainder_size); <span class="comment">//设置物理意义上下一个chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">           check_malloced_chunk (av, victim, nb); <span class="comment">//对切割下来的chunk进行检查</span></span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim); <span class="comment">//返回mem指针给用户</span></span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p; </span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p>只有满足if条件后malloc才会去切割unsorted bin中的chunk以返回合适的chunk给用户，否则会直接进入下一步。</p>
<h5 id="移除尾部chunk"><a href="#移除尾部chunk" class="headerlink" title="移除尾部chunk"></a>移除尾部chunk</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>代码很简单，但是确实把尾部的chunk扔出了unsorted bin。之所以会有这么一步是因为只要上一步切割没实现，那么接下来无论如何尾部chunk都不可能留在unsorted bin里了，要么被分配到其他bin中，要么大小刚刚好而被返回给用户。</p>
<h5 id="victim返回给用户"><a href="#victim返回给用户" class="headerlink" title="victim返回给用户"></a>victim返回给用户</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果用户申请的chunk大小和victim的大小刚刚好一样，那太好了，直接把victim返回给用户，皆大欢喜。当然，除了会改一改标志位除外，其他地方不会动。也就是说，原本存在上面的fd和bk指针现在依然残留在上面，那就可以利用这一点来泄露libc地址了。</p>
<h5 id="victim进入到small-bin或large-bin中"><a href="#victim进入到small-bin或large-bin中" class="headerlink" title="victim进入到small bin或large bin中"></a>victim进入到small bin或large bin中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line">		 <span class="comment">/*核心的放置步骤在57行*/</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size)) <span class="comment">//如果victim在smallbin范围中（size&lt;0x400）</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size); <span class="comment">//找到对应size的bin的索引</span></span><br><span class="line">              bck = bin_at (av, victim_index); <span class="comment">//将bck设置为对应bin的地址</span></span><br><span class="line">              fwd = bck-&gt;fd; <span class="comment">//将fwd设置为对应bin当前的头部chunk</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//如果victim在largebin范围中</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size); <span class="comment">//同上</span></span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="comment">/*下面一大坨看起来和复杂但其实它就在干一件事，那就是保持large bin内的chunk要按照size大小从小到大排序*/</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">/*放置chunk到对应bin的核心步骤，也就是设置fd和bk增加链表节点*/</span></span><br><span class="line">          mark_bin (av, victim_index); <span class="comment">//将victim要进入的bin的binmap设置为1，意味着这个bin里包含空闲chunk</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*然后返回到while处重新找下一个chunk是否能满足用户需求然后返回，除非unsorted bin已经空了，或者已经循环了MAX_ITERS次*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//这个break是给最初那个while用的，这里也是while语句块的最后一个语句了。</span></span><br></pre></td></tr></table></figure>



<h5 id="依然找不到合适chunk的解决办法"><a href="#依然找不到合适chunk的解决办法" class="headerlink" title="依然找不到合适chunk的解决办法"></a>依然找不到合适chunk的解决办法</h5><p>如果unsorted bin已经空了或者循环次数过多了，但是还找不到合适的chunk给用户，ptmalloc就开largebin去找大小最合适的chunk，这个chunk大小可能比需要的还要大，所以会把它放进unsorted bin中进行切割。如果还没有，ptmalloc急了就会开地图炮去找合适的chunk来切割。实在没有的话，那就只能去切割top chunk了，或者合并fastbin亦或者直接sysmalloc，此处不做分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">      sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">     &#123;</span><br><span class="line">       bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">       <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">         &#123;</span><br><span class="line">           victim = victim-&gt;bk_nextsize;</span><br><span class="line">           <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                   (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">              list does not have to be rerouted.  */</span></span><br><span class="line">           <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">             victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">/*至此，最开始的for语句块结束了*/</span></span><br></pre></td></tr></table></figure>



<h3 id="free时unsorted-bin的行为"><a href="#free时unsorted-bin的行为" class="headerlink" title="free时unsorted bin的行为"></a>free时unsorted bin的行为</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av); <span class="comment">//将要被free的chunk插入链表头部</span></span><br><span class="line">     fwd = bck-&gt;fd; </span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) <span class="comment">//检查当前头部chunk的bk是否被破坏，对unsorted bin来说bk很重要</span></span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd; <span class="comment">//设置被free的chunk的fd和bk指针</span></span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p; <span class="comment">//插入链表</span></span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE); <span class="comment">//设置size字段</span></span><br><span class="line">     set_foot(p, size); <span class="comment">//设置物理相邻chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>chunk被释放后会进入unsorted bin有以下几种情况：<br>- 这个chunk不属于fastbin范围，则会先进入unsorted bin<br>- unsorted bin中的chunk被切割后，剩余部分如果大于MINSIZE，则会继续放回到unsorted bin中<br>- 触发malloc_consolidate之后，合并好的的chunk会先被放到unsorted bin中<br>- 这个chunk不与top chunk相邻，否则会被top chunk合并</p>
<p>关于这些情况的源码分析将在另一篇文章中进行。</p>
<p>参考阅读：<br>- <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d3fdeff8683f">heap 中常见函数、宏与值</a></p>

											<div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0
        国际许可协议(CC BY-NC-SA 4.0) 发布.</a></br>
    因本人技术水平和知识面有限, 内容如有纰漏或者需要修正的地方, 欢迎大家指正。转载请注明来自<a href="https://c-lby.github.io" target="_blank">C_LBY's blog</a>！
</div>
							</div>

							
									
										<span data-path="/2024/03/02/glibc-unsortedbin/">
											<em class="post-meta-item-text"> Page View <i
													class="waline-pageview-count"></i></em>
										</span>

										
											<div>
												<center>

													<div class="pagination">

    
    
    <a href="/2024/03/05/pwnable-WP/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2024/03/01/newstar-week4-wp/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


												</center>
											</div>

											<!-- comment -->
											<!--
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>

-->
											
													
														<section id="comments" class="comments">
															<!-- <link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css" />
<div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
  var walineConfig = 
    walineConfig.el='#waline';
  Waline.init(walineConfig);
</script> -->

<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css" />
<div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

  init({
    enable: true,
    el: '#waline',
    serverURL: 'https://blog-s-comment-three.vercel.app',
    dark: true,
    pageview: true,
    lang: 'zh-CN',
    requiredMeta: ['nick', 'mail'],
    locale:
      { placeholder: 'Say something……' },
    highlighter: true,
    search: false,
    emoji: [
      '//unpkg.com/@waline/emojis@1.2.0/weibo',
      '//unpkg.com/@waline/emojis@1.2.0/bmoji',
      '//unpkg.com/@waline/emojis@1.2.0/bilibili',
      'https://unpkg.com/@waline/emojis@1.2.0/qq',
    ],
    imageUploader: false,
  });
</script>
														</section>
														
															
					</div> <!-- col-md-9/col-md-12 -->


					
						<div id="side_meta">
							<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2024-03-02 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/glibc源码补完计划/">glibc源码补完计划<span>2</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/heap/">heap<span>3</span></a></li> <li><a href="/tags/CTF/">CTF<span>7</span></a></li> <li><a href="/tags/PWN/">PWN<span>7</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#UnsortedBin"><span class="toc-article-text">UnsortedBin</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Unsorted-Bin%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-%E5%AF%B9%E4%B8%80%E4%BA%9B%E5%8F%98%E9%87%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-article-text">Unsorted Bin的基本情况 &amp; 对一些变量的理解</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#malloc%E6%97%B6unsorted-bin%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-article-text">malloc时unsorted bin的行为</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A3%80%E6%9F%A5"><span class="toc-article-text">一些基本检查</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E5%AF%B9%E5%94%AF%E4%B8%80chunk%E7%9A%84%E5%88%86%E5%89%B2"><span class="toc-article-text">对唯一chunk的分割</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E7%A7%BB%E9%99%A4%E5%B0%BE%E9%83%A8chunk"><span class="toc-article-text">移除尾部chunk</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#victim%E8%BF%94%E5%9B%9E%E7%BB%99%E7%94%A8%E6%88%B7"><span class="toc-article-text">victim返回给用户</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#victim%E8%BF%9B%E5%85%A5%E5%88%B0small-bin%E6%88%96large-bin%E4%B8%AD"><span class="toc-article-text">victim进入到small bin或large bin中</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E4%BE%9D%E7%84%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%90%88%E9%80%82chunk%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-article-text">依然找不到合适chunk的解决办法</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#free%E6%97%B6unsorted-bin%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-article-text">free时unsorted bin的行为</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->



						</div>

						

			</div><!-- row -->

			<!--
 -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
    &copy; 2024
      鎏柏鱼's Blog
        
                powered by <a href="http://hexo.io/" target="_blank">Hexo</a> | Theme by <a
                  href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
