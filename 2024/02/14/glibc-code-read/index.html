<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>glibc源码阅读计划（heap相关） | C_LBY&#39;s BLOG</title>
  <meta name="author" content="鎏柏鱼">
  
  <meta name="description" content="glibc_2.35(持续更新)">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="glibc源码阅读计划（heap相关）"/>
  <meta property="og:site_name" content="C_LBY&#39;s BLOG"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="C_LBY&#39;s BLOG" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">C_LBY&#39;s BLOG</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> glibc源码阅读计划（heap相关）</h1>
		</div>
	



	<div class="row post">
		<!-- cols -->
		
			<div id="top_meta"></div>
			<div class="col-md-9">
				

							<!-- content -->
							<div class="mypage">
								
									<div class="alert alert-success description">
										<i class="fa fa-info-circle"></i> glibc_2.35(持续更新)
									</div> <!-- alert -->
									

										<p>在ptmalloc2堆内存管理机制中，管理空闲chunk的bins一共有6种：</p>
<ul>
<li>tcachebin</li>
<li>fastbin</li>
<li>unsortedbin</li>
<li>smallbin</li>
<li>largebin</li>
</ul>
<p>每一个bin（不是每种）就是一条储存一定数量chunk的链表。</p>
<h2 id="TcacheBin"><a href="#TcacheBin" class="headerlink" title="TcacheBin"></a>TcacheBin</h2><p>TcacheBin是从glibc2.26才开始加入的，访问速度比fastbin更快，相对的检查机制也比较弱，容易攻击。</p>
<h3 id="TcacheBin相关数据结构"><a href="#TcacheBin相关数据结构" class="headerlink" title="TcacheBin相关数据结构"></a>TcacheBin相关数据结构</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#if USE_TCACHE
&#x2F;* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  *&#x2F;
# define TCACHE_MAX_BINS		64
# define MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)

&#x2F;* Only used to pre-fill the tunables.  *&#x2F;
# define tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)

&#x2F;* When &quot;x&quot; is from chunksize().  *&#x2F;
# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) &#x2F; MALLOC_ALIGNMENT)
&#x2F;* When &quot;x&quot; is a user-provided size.  *&#x2F;
# define usize2tidx(x) csize2tidx (request2size (x))

&#x2F;* With rounding and alignment, the bins are...
   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)
   idx 1   bytes 25..40 or 13..20
   idx 2   bytes 41..56 or 21..28
   etc.  *&#x2F;

&#x2F;* This is another arbitrary limit, which tunables can change.  Each
   tcache bin will hold at most this number of chunks.  *&#x2F;
# define TCACHE_FILL_COUNT 7

&#x2F;* Maximum chunks in tcache bins for tunables.  This value must fit the range
   of tcache-&gt;counts[] entries, else they may overflow.  *&#x2F;
# define MAX_TCACHE_COUNT UINT16_MAX
#endif


&#x2F;* We overlay this structure on the user-data portion of a chunk when
   the chunk is stored in the per-thread cache.  *&#x2F;
typedef struct tcache_entry
&#123;
  struct tcache_entry *next;
  &#x2F;* This field exists to detect double frees.  *&#x2F;
  uintptr_t key;
&#125; tcache_entry;

&#x2F;* There is one of these for each thread, which contains the
   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  *&#x2F;
typedef struct tcache_perthread_struct
&#123;
  uint16_t counts[TCACHE_MAX_BINS];
  tcache_entry *entries[TCACHE_MAX_BINS];
&#125; tcache_perthread_struct;

static __thread bool tcache_shutting_down &#x3D; false;
static __thread tcache_perthread_struct *tcache &#x3D; NULL;

&#x2F;* Process-wide key to try and catch a double-free in the same thread.  *&#x2F;
static uintptr_t tcache_key;

static void
tcache_key_initialize (void)
&#123;
  if (__getrandom (&amp;tcache_key, sizeof(tcache_key), GRND_NONBLOCK)
      !&#x3D; sizeof (tcache_key))
    &#123;
      tcache_key &#x3D; random_bits ();
#if __WORDSIZE &#x3D;&#x3D; 64
      tcache_key &#x3D; (tcache_key &lt;&lt; 32) | random_bits ();
#endif
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每个线程都会被分配一个&#x3D;&#x3D;TcacheBin&#x3D;&#x3D;数组，数组大小为64，也就是每个TcacheBin里会有64个bin单向链表，每个bin最多可以缓存7个相同大小的空闲chunk。chunk在64位机器以16字节递增，从24到1024(MAX_TCACHE_COUNT)字节。在32位机器上以8字节递增，从12到512字节。TcacheBin由tcache_perthread_struct结构体维护，一般大小是0x250，放在堆头；counts数组记录了每个bin上chunk的数量，entries数组记录每个bin的地址。tcache_entry结构体用来连接空闲的chunk结构体形成链表。在这里有几个需要注意的问题，其一是next指针指向的是同一个bin中下一个chunk（大小一定相同的chunk）的user_data处，而在fastbin中chunk的fd指针的是下一个chunk的头部，即prev_size处；其二是key是为了防止double free而从glibc2.29才开始加入的，在glibc2.34前key是指向TcacheBin的指针，储存在空闲chunk的bk位置上，而2.34之后的key是由tcache_key_initialize函数生成的。</p>
<p>tidx2usize(idx)通过bin索引计算chunk大小<br>csize2tidx(x)通过chunk大小找到相应的bin索引<br>usize2tidx(x)通过用户的需求size计算相应的bin索引</p>
<p>TcacheBin有很多特性和FastBin很像，LIFO的单向链表结构，PREV_INUSE标志位不清零，严格限制每个bin内chunk的大小相同，且chunk没法在bin内合并，要由malloc_consolidate函数释放并合并。</p>
<h3 id="TcacheBin初始化"><a href="#TcacheBin初始化" class="headerlink" title="TcacheBin初始化"></a>TcacheBin初始化</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">static void
tcache_init(void)
&#123;
  mstate ar_ptr;
  void *victim &#x3D; 0;
  const size_t bytes &#x3D; sizeof (tcache_perthread_struct);

  if (tcache_shutting_down)
    return;

  arena_get (ar_ptr, bytes);
  victim &#x3D; _int_malloc (ar_ptr, bytes); &#x2F;&#x2F;分配内存给tcache_perthread_struct
  if (!victim &amp;&amp; ar_ptr !&#x3D; NULL) &#x2F;&#x2F;如果分配失败则尝试再分配一次
    &#123;
      ar_ptr &#x3D; arena_get_retry (ar_ptr, bytes);
      victim &#x3D; _int_malloc (ar_ptr, bytes);
    &#125;


  if (ar_ptr !&#x3D; NULL)
    __libc_lock_unlock (ar_ptr-&gt;mutex); &#x2F;&#x2F;释放一个互斥锁

  &#x2F;* In a low memory situation, we may not be able to allocate memory
     - in which case, we just keep trying later.  However, we
     typically do this very early, so either there is sufficient
     memory, or there isn&#39;t enough memory to do non-trivial
     allocations anyway.  *&#x2F;
  &#x2F;* 在内存不足的情况下，我们可能无法分配内存 -这样的话，我们稍后再试。(๑ゝڡ◕๑) *&#x2F;
  if (victim)
    &#123;
      tcache &#x3D; (tcache_perthread_struct *) victim;
      memset (tcache, 0, sizeof (tcache_perthread_struct));
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="TcacheBin释放"><a href="#TcacheBin释放" class="headerlink" title="TcacheBin释放"></a>TcacheBin释放</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">static void
tcache_thread_shutdown (void)
&#123;
  int i;
  tcache_perthread_struct *tcache_tmp &#x3D; tcache;

  tcache_shutting_down &#x3D; true;

  if (!tcache)
    return;

  &#x2F;* Disable the tcache and prevent it from being reinitialized.  *&#x2F;
  tcache &#x3D; NULL; &#x2F;&#x2F;将TcacheBin堆头置空

  &#x2F;* Free all of the entries and the tcache itself back to the arena
     heap for coalescing.  *&#x2F;
  for (i &#x3D; 0; i &lt; TCACHE_MAX_BINS; ++i)
    &#123;
      while (tcache_tmp-&gt;entries[i])
	&#123;
	  tcache_entry *e &#x3D; tcache_tmp-&gt;entries[i]; &#x2F;&#x2F;释放每一个bin
	  if (__glibc_unlikely (!aligned_OK (e)))
	    malloc_printerr (&quot;tcache_thread_shutdown(): &quot;
			     &quot;unaligned tcache chunk detected&quot;);
	  tcache_tmp-&gt;entries[i] &#x3D; REVEAL_PTR (e-&gt;next);
	  __libc_free (e);
	&#125;
    &#125;

  __libc_free (tcache_tmp); &#x2F;&#x2F;释放临时堆头
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="TcacheBin存取chunk"><a href="#TcacheBin存取chunk" class="headerlink" title="TcacheBin存取chunk"></a>TcacheBin存取chunk</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* Caller must ensure that we know tc_idx is valid and there&#39;s room
   for more chunks.  *&#x2F;
static __always_inline void
tcache_put (mchunkptr chunk, size_t tc_idx) &#x2F;&#x2F;空闲chunk存入tcachebin
&#123;
  tcache_entry *e &#x3D; (tcache_entry *) chunk2mem (chunk); 

  &#x2F;* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will
     detect a double free.  *&#x2F;
  e-&gt;key &#x3D; tcache_key; &#x2F;&#x2F;防止double free的key

  e-&gt;next &#x3D; PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]); &#x2F;&#x2F;将当前bin头部chunk的指针赋给next
  tcache-&gt;entries[tc_idx] &#x3D; e; &#x2F;&#x2F;将这个chunk存进相应索引的bin链表头部（更新bin头部）
  ++(tcache-&gt;counts[tc_idx]); &#x2F;&#x2F;chunk计数器+1
&#125;

&#x2F;* Caller must ensure that we know tc_idx is valid and there&#39;s
   available chunks to remove.  *&#x2F;
static __always_inline void *
tcache_get (size_t tc_idx) &#x2F;&#x2F;从tcachebin取出chunk
&#123;
  tcache_entry *e &#x3D; tcache-&gt;entries[tc_idx]; &#x2F;&#x2F;根据计算好的索引取出链表头部的chunk
  if (__glibc_unlikely (!aligned_OK (e)))
    malloc_printerr (&quot;malloc(): unaligned tcache chunk detected&quot;);
  tcache-&gt;entries[tc_idx] &#x3D; REVEAL_PTR (e-&gt;next); &#x2F;&#x2F;将头部地址改成下一个chunk
  --(tcache-&gt;counts[tc_idx]); &#x2F;&#x2F;计数器-1
  e-&gt;key &#x3D; 0; &#x2F;&#x2F;key位置置空
  return (void *) e;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="FastBin"><a href="#FastBin" class="headerlink" title="FastBin"></a>FastBin</h2><p>从malloc.c第1729行开始可以得知，fastbin采用LIFO的单向链表维护。在fastbin中的chunk会保持PREV_INUSE标志位不变，所以chunk没法在fastbin里进行合并，合并的工作交给了malloc_consolidate函数进行。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*To be continued...*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


											<div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0
        国际许可协议(CC BY-NC-SA 4.0) 发布.</a></br>
    因本人技术水平和知识面有限, 内容如有纰漏或者需要修正的地方, 欢迎大家指正。
</div>
							</div>

							
									
										<span data-path="/2024/02/14/glibc-code-read/">
											<em class="post-meta-item-text"> Page View <i
													class="waline-pageview-count"></i></em>
										</span>

										
											<div>
												<center>

													<div class="pagination">

    
    
    <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2024/02/14/fastbin_attack/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


												</center>
											</div>

											<!-- comment -->
											<!--
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>

-->
											
													
														<section id="comments" class="comments">
															<!-- <link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css" />
<div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
  var walineConfig = 
    walineConfig.el='#waline';
  Waline.init(walineConfig);
</script> -->

<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css" />
<div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

  init({
    enable: true,
    el: '#waline',
    serverURL: 'https://blog-s-comment-three.vercel.app',
    dark: true,
    pageview: true,
    lang: 'zh-CN',
    requiredMeta: ['nick', 'mail'],
    locale:
      { placeholder: 'Say something……' },
    highlighter: true,
    search: false,
    emoji: [
      '//unpkg.com/@waline/emojis@1.2.0/weibo',
      '//unpkg.com/@waline/emojis@1.2.0/bmoji',
      '//unpkg.com/@waline/emojis@1.2.0/bilibili',
      'https://unpkg.com/@waline/emojis@1.2.0/qq',
    ],
    WalineImageUploader: false,
  });
</script>
														</section>
														
															
					</div> <!-- col-md-9/col-md-12 -->


					
						<div id="side_meta">
							<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2024-02-14 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/PWN/">PWN<span>1</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/heap/">heap<span>2</span></a></li> <li><a href="/tags/CTF/">CTF<span>1</span></a></li> <li><a href="/tags/PWN/">PWN<span>1</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#TcacheBin"><span class="toc-article-text">TcacheBin</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#TcacheBin%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-article-text">TcacheBin相关数据结构</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#TcacheBin%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-article-text">TcacheBin初始化</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#TcacheBin%E9%87%8A%E6%94%BE"><span class="toc-article-text">TcacheBin释放</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#TcacheBin%E5%AD%98%E5%8F%96chunk"><span class="toc-article-text">TcacheBin存取chunk</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#FastBin"><span class="toc-article-text">FastBin</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->



						</div>

						

			</div><!-- row -->

			<!--
 -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
    &copy; 2024
      鎏柏鱼's Blog
        
                powered by <a href="http://hexo.io/" target="_blank">Hexo</a> | Theme by <a
                  href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
