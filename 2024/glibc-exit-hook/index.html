<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  <meta name="baidu-site-verification" content="codeva-0Qx7wvY9gP" />
  <meta name="msvalidate.01" content="FB02A8AFF2CE6EF90657A5C51EA59F68" />
  
  <title>『glibc源码补完计划』exit_hook | C_LBY&#39;s BLOG</title>
  <meta name="author" content="鎏柏鱼">
  
  <meta name="description" content="glibc2.31，但是适用于glibc2.34及以前的版本">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="『glibc源码补完计划』exit_hook"/>
  <meta property="og:site_name" content="C_LBY&#39;s BLOG"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="C_LBY&#39;s BLOG" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">C_LBY&#39;s BLOG</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/diary" title="fashion little junk">
			  <i class="fa fa-tasks"></i>Diary
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class="fa fa-rss"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> 『glibc源码补完计划』exit_hook</h1>
		</div>
	



	<div class="row post">
		<!-- cols -->
		
			<div id="top_meta"></div>
			<div class="col-md-9">
				

							<!-- content -->
							<div class="mypage">
								
									<div class="alert alert-success description">
										<i class="fa fa-info-circle"></i> glibc2.31，但是适用于glibc2.34及以前的版本
									</div> <!-- alert -->
									

										<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>线程退出的时候，需要释放掉这个线程所占有的资源，并且停止内核和CPU对其的调度，才算是结束了这个线程。换句话说，线程退出需要用户层面和内核层面的共同工作。内核层面，glibc通过_exit()系统调用来终止线程，用户层面则通过exit()函数。在pwn中，系统调用很难被利用，我们通常重点关注exit函数。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>exit.c中定义了<code>exit</code>函数和<code>__run_exit_handlers</code>函数，其中exit函数其实就是对__run_exit_handlers的封装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到exit函数调用了__run_exit_handlers函数并以<code>__exit_funcs</code>等变量为参数。在查看核心函数之前，先来关注与其相关的数据结构。</p>
<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><p>我们追溯__exit_funcs，可以发现其在cxa_atexit.c中有定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> <span class="title">initial</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *__<span class="title">exit_funcs</span> =</span> &amp;initial;</span><br></pre></td></tr></table></figure>

<p>在exit.h中对<code>exit_function_list</code>结构体有定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ef_free, <span class="comment">/* `ef_free&#x27; MUST be zero!  */</span></span><br><span class="line">  ef_us,</span><br><span class="line">  ef_on,</span><br><span class="line">  ef_at,</span><br><span class="line">  ef_cxa</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">     this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*at)(<span class="type">void</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">void</span> (*fn)(<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line">    &#125; on;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">void</span> (*fn)(<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line">      <span class="type">void</span> *dso_handle;</span><br><span class="line">    &#125; cxa;</span><br><span class="line">  &#125; func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="type">size_t</span> idx;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>exit执行时会进行一些析构工作，<code>exit_function</code>结构体是对单个析构函数的描述，其中<code>flavour</code>变量描述的是函数类型：</p>
<ul>
<li><code>ef_free</code>: 此位置空闲（没有析构函数）</li>
<li><code>ef_us</code>: 此位置函数使用中，但尚未写入函数指针，类型未知等待写入</li>
<li><code>ef_at</code>: 没有参数的函数</li>
<li><code>ef_on</code>: 先传入状态码再传入第二参数的函数</li>
<li><code>ef_cxa</code>: 先传入第一参数后状态码的函数</li>
</ul>
<p>因为单个函数只会有一种类型，所以使用了联合体。而<code>exit_function_list</code>是维护多个析构函数的单链表，idx储存的是函数个数。而<code>initial</code>变量则是exit的第一个析构函数链表，储存在libc的.data段，而往后的其他链表节点则是通过malloc分配的。</p>
<h3 id="run-exit-handlers"><a href="#run-exit-handlers" class="headerlink" title="__run_exit_handlers()"></a>__run_exit_handlers()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">	attribute_hidden</span><br><span class="line">	__run_exit_handlers(<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">						<span class="type">bool</span> run_list_atexit, <span class="type">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">	<span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>) </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (run_dtors)</span><br><span class="line">			__call_tls_dtors(); <span class="comment">//首先释放tls</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">	   the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">	   everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">	   exit (). */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">//析构函数处理大循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">		__libc_lock_lock(__exit_funcs_lock); <span class="comment">//给互斥锁上锁</span></span><br><span class="line"></span><br><span class="line">	restart:</span><br><span class="line">		cur = *listp; <span class="comment">//最开始的就是initial变量</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* Exit processing complete.  We will not allow any more</span></span><br><span class="line"><span class="comment">			   atexit/on_exit registrations.  */</span></span><br><span class="line">			__exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">			__libc_lock_unlock(__exit_funcs_lock); <span class="comment">//给互斥锁解锁</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">			<span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">			__libc_lock_unlock(__exit_funcs_lock);</span><br><span class="line">			<span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">void</span> (*atfct)(<span class="type">void</span>);</span><br><span class="line">				<span class="type">void</span> (*onfct)(<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">				<span class="type">void</span> (*cxafct)(<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> ef_free:</span><br><span class="line">			<span class="keyword">case</span> ef_us:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> ef_on:</span><br><span class="line">				onfct = f-&gt;func.on.fn; <span class="comment">//绑定on类型的函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">				PTR_DEMANGLE(onfct); <span class="comment">//用宏来解密函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">				onfct(status, f-&gt;func.on.arg); <span class="comment">//执行相应析构函数</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> ef_at:</span><br><span class="line">				atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">				PTR_DEMANGLE(atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">				atfct();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> ef_cxa:</span><br><span class="line">				<span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment">			   we must mark this function as ef_free.  */</span></span><br><span class="line">				f-&gt;flavor = ef_free; <span class="comment">//为了防止条件竞争，执行过的cxa类型析构函数之后会被置free</span></span><br><span class="line">				cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">				PTR_DEMANGLE(cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">				cxafct(f-&gt;func.cxa.arg, status);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* Re-lock again before looking at global state.  */</span></span><br><span class="line">			__libc_lock_lock(__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (__glibc_unlikely(new_exitfn_called != __new_exitfn_called))</span><br><span class="line">				<span class="comment">/* The last exit function, or another thread, has registered</span></span><br><span class="line"><span class="comment">				   more exit functions.  Start the loop over.  */</span></span><br><span class="line">				<span class="keyword">goto</span> restart;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		*listp = cur-&gt;next; <span class="comment">//切换到下一个节点</span></span><br><span class="line">		<span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">			   allocate element.  */</span></span><br><span class="line">			<span class="built_in">free</span>(cur); <span class="comment">//释放除了第一个以外的其他节点</span></span><br><span class="line"></span><br><span class="line">		__libc_lock_unlock(__exit_funcs_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">		RUN_HOOK(__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">	_exit(status); <span class="comment">//系统调用，内核exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TLS</code>：Thread Local Storage，是一种数据的储存方式，作用是保持数据在线程内全局可访问，而不能被其他线程访问到。</p>
<p>__run_exit_handlers函数的大致流程就是，先进行两个条件判断，成立则调用__call_tls_dtors函数释放tls。我们来追踪一下这个函数（在cxa_thread_atexit_impl.c中）。</p>
<h3 id="call-tls-dtors"><a href="#call-tls-dtors" class="headerlink" title="__call_tls_dtors()"></a>__call_tls_dtors()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Call the destructors.  This is called either when a thread returns from the</span></span><br><span class="line"><span class="comment">   initial function or when the process exits via the exit function.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ensure that the MAP dereference happens before</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count decrement.  That way, we protect this access from a</span></span><br><span class="line"><span class="comment">	 potential DSO unload in _dl_close_worker, which happens when</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span></span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>tls_dtor_list</code>不为空，则解密每个节点中的func函数指针，并以obj成员为参数执行。所以其实可以劫持tls_dtor_list写入system和binsh，前提是要泄露解密的key，这个后面再看。我们先来看tls_dtor_list的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*dtor_func)</span> <span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">tls_dtor_list</span>;</span></span><br></pre></td></tr></table></figure>

<p>那么也就是如果有任意写的机会，可以往tls_dtor_list里写加密后的system地址到func和binsh地址到obj。顺带一提，这个攻击方法在2.35也适用。</p>
<p>但是一般做题的时候pwndbg并不能读取到tls_dtor_list的符号，所以只能通过其他途径来找到其所在处。我们将libc扔到ida查找一下这个函数，看看汇编层面这个函数是如何运行的。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000047280</span>                 public __call_tls_dtors</span><br><span class="line">.text:<span class="number">0000000000047280</span> __call_tls_dtors <span class="keyword">proc</span> near              ; <span class="type">CODE</span> <span class="type">XREF</span>: sub_467B0:loc_46A08↑p</span><br><span class="line">.text:<span class="number">0000000000047280</span>                                         ; <span class="type">DATA</span> <span class="type">XREF</span>: <span class="type">LOAD</span>:<span class="number">000000000000E420</span>↑o</span><br><span class="line">.text:<span class="number">0000000000047280</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000047280</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000047284</span>                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000047285</span>                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000047286</span>                 sub     rsp, <span class="number">8</span></span><br><span class="line">.text:000000000004728A                 mov     rbx, cs:off_1EBD60</span><br><span class="line">.text:<span class="number">0000000000047291</span>                 mov     rbp, fs:[rbx]</span><br><span class="line">.text:<span class="number">0000000000047295</span>                 test    rbp, rbp</span><br><span class="line">.text:<span class="number">0000000000047298</span>                 jz      short loc_472DD</span><br><span class="line">.text:000000000004729A                 nop     word ptr [rax+rax+00h]</span><br><span class="line">.text:00000000000472A0</span><br><span class="line">.text:00000000000472A0 loc_472A0:                              ; <span class="type">CODE</span> <span class="type">XREF</span>: __call_tls_dtors+5B↓j</span><br><span class="line">.text:00000000000472A0                 mov     rdx, [rbp+18h]</span><br><span class="line">.text:00000000000472A4                 mov     rax, [rbp+<span class="number">0</span>]</span><br><span class="line">.text:00000000000472A8                 ror     rax, 11h</span><br><span class="line">.text:00000000000472AC                 xor     rax, fs:30h</span><br><span class="line">.text:00000000000472B5                 mov     fs:[rbx], rdx</span><br><span class="line">.text:00000000000472B9                 mov     rdi, [rbp+<span class="number">8</span>]</span><br><span class="line">.text:00000000000472BD                 call    rax</span><br><span class="line">.text:00000000000472BF                 mov     rax, [rbp+10h]</span><br><span class="line">.text:00000000000472C3                 lock sub qword ptr [rax+460h], <span class="number">1</span></span><br><span class="line">.text:00000000000472CC                 mov     rdi, rbp</span><br><span class="line">.text:00000000000472CF                 call    j_free</span><br><span class="line">.text:00000000000472D4                 mov     rbp, fs:[rbx]</span><br><span class="line">.text:00000000000472D8                 test    rbp, rbp</span><br><span class="line">.text:00000000000472DB                 jnz     short loc_472A0</span><br><span class="line">.text:00000000000472DD</span><br><span class="line">.text:00000000000472DD loc_472DD:                              ; <span class="type">CODE</span> <span class="type">XREF</span>: __call_tls_dtors+<span class="number">18</span>↑j</span><br><span class="line">.text:00000000000472DD                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000000000472E1</span>                 pop     rbx</span><br><span class="line">.text:<span class="number">00000000000472E2</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">00000000000472E3</span>                 retn</span><br><span class="line">.text:<span class="number">00000000000472E3</span> ; &#125; // starts at <span class="number">47280</span></span><br><span class="line">.text:<span class="number">00000000000472E3</span> __call_tls_dtors endp</span><br></pre></td></tr></table></figure>

<p>第9行给rbx赋了一个地址，然后将fs+[rbx]赋给了rbp，此时rbp就指向tls_dtor_list。第11行的test就是在检查其是否为空。第17行，将func赋给rax，然后右循环位移17位，取fs+0x30的内容进行异或。这就完成了函数指针的解密操作。后面就是传入参数并执行了。</p>
<p>fs+0x30是个啥呢？fs是段寄存器，里面存放着GDT表的索引，linux会让fs指向当前线程的控制块，也就是<code>tcbhead_t</code>结构体，很多和线程相关的全局变量会储存在这个结构体当中，其定义在tls.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;		<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">			   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;		<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> feature_1;</span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The lowest address of shadow stack,  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>

<p>pointer_guard就是我们要找的fs:0x30，而stack_guard就是常见的canary，也就是fs:0x28。在pwndbg中查找这个结构体地址的方法也很简单，可以通过符号搜索，也可以直接输入<code>tls</code>作为指令，就可以输出其地址了，计算一下偏移即可。</p>
<h3 id="PTR-DEMANGLE"><a href="#PTR-DEMANGLE" class="headerlink" title="PTR_DEMANGLE"></a>PTR_DEMANGLE</h3><p>顺便也来看一下PTR_DEMANGLE这个用来解密的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var)	asm (<span class="string">&quot;xor %%fs:%c2, %0\n&quot;</span>		      \</span></span><br><span class="line"><span class="meta">				     <span class="string">&quot;rol $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0&quot;</span>		      \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;=r&quot;</span> (var)			      \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;0&quot;</span> (var),			      \</span></span><br><span class="line"><span class="meta">				       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,	      \</span></span><br><span class="line"><span class="meta">						      pointer_guard)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var)	asm (<span class="string">&quot;ror $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0\n&quot;</span>	      \</span></span><br><span class="line"><span class="meta">				     <span class="string">&quot;xor %%fs:%c2, %0&quot;</span>			      \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;=r&quot;</span> (var)			      \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;0&quot;</span> (var),			      \</span></span><br><span class="line"><span class="meta">				       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,	      \</span></span><br><span class="line"><span class="meta">						      pointer_guard)))</span></span><br></pre></td></tr></table></figure>

<p>libc在x86_64&#x2F;sysdep.h中很简单粗暴地直接用汇编来写解密过程了，其中LP_SIZE定义为8。</p>
<h3 id="已存在的析构函数？"><a href="#已存在的析构函数？" class="headerlink" title="已存在的析构函数？"></a>已存在的析构函数？</h3><p>libc封装了一系列函数到<code>atexit()</code>函数，用来添加exit的析构函数，或者说，用来注册exit的析构函数。定义如下，但这里不展开叙述了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))func, <span class="literal">NULL</span>, &amp;__dso_handle == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : __dso_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题在于，就算我们写程序的时候没有使用这个函数来添加析构函数，程序exit的时候也会执行一些析构函数。显然肯定是有谁注册了这些析构函数，并且是早在程序启动还没开始执行main时就注册完成了。</p>
<p>程序逆向得多了的话，应该不难发现每个elf文件都有个<code>_start()</code>函数，并且这个函数还占据.text段的第一个位置。显而易见，这个函数才是一个elf文件真正的入口。那么这个函数干了什么事呢？</p>
<h5 id="start"><a href="#start" class="headerlink" title="_start()"></a>_start()</h5><p>这个函数的源码在glibc中是以汇编的形式出现的，在sysdeps&#x2F;x86_64&#x2F;start.S中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ENTRY (_start) //告诉编译器，这是程序入口</span><br><span class="line">	/* Clearing frame pointer is insufficient, use CFI.  */</span><br><span class="line">	cfi_undefined (rip)</span><br><span class="line">	/* Clear the frame pointer.  The ABI suggests this be done, to mark</span><br><span class="line">	   the outermost frame obviously.  */</span><br><span class="line">	xorl %ebp, %ebp //初始化栈底</span><br><span class="line"></span><br><span class="line">	/* Extract the arguments as encoded on the stack and set up</span><br><span class="line">	   the arguments for __libc_start_main (int (*main) (int, char **, char **),</span><br><span class="line">		   int argc, char *argv,</span><br><span class="line">		   void (*init) (void), void (*fini) (void),</span><br><span class="line">		   void (*rtld_fini) (void), void *stack_end).</span><br><span class="line">	   The arguments are passed via registers and on the stack:</span><br><span class="line">	main:		%rdi</span><br><span class="line">	argc:		%rsi</span><br><span class="line">	argv:		%rdx</span><br><span class="line">	init:		%rcx</span><br><span class="line">	fini:		%r8</span><br><span class="line">	rtld_fini:	%r9</span><br><span class="line">	stack_end:	stack.	*/ /*这里写的是__libc_start_main函数的传参寄存器*/</span><br><span class="line"></span><br><span class="line">	mov %RDX_LP, %R9_LP	/* Address of the shared library termination function.  *//*设置参数rtld_fini*/</span><br><span class="line">#ifdef __ILP32__</span><br><span class="line">	mov (%rsp), %esi	/* Simulate popping 4-byte argument count.  */</span><br><span class="line">	add $4, %esp</span><br><span class="line">#else</span><br><span class="line">	popq %rsi		/* Pop the argument count.  */ //设置参数argc</span><br><span class="line">#endif</span><br><span class="line">	/* argv starts just at the current stack top.  */</span><br><span class="line">	mov %RSP_LP, %RDX_LP  //设置参数argv</span><br><span class="line">	/* Align the stack to a 16 byte boundary to follow the ABI.  */</span><br><span class="line">	and  $~15, %RSP_LP   //rsp对齐</span><br><span class="line"></span><br><span class="line">	/* Push garbage because we push 8 more bytes.  */</span><br><span class="line">	pushq %rax</span><br><span class="line"></span><br><span class="line">	/* Provide the highest stack address to the user code (for stacks</span><br><span class="line">	   which grow downwards).  */</span><br><span class="line">	pushq %rsp</span><br><span class="line"></span><br><span class="line">#ifdef PIC</span><br><span class="line">	/* Pass address of our own entry points to .fini and .init.  */</span><br><span class="line">	//设置参数init和fini</span><br><span class="line">	mov __libc_csu_fini@GOTPCREL(%rip), %R8_LP</span><br><span class="line">	mov __libc_csu_init@GOTPCREL(%rip), %RCX_LP</span><br><span class="line"></span><br><span class="line">	mov main@GOTPCREL(%rip), %RDI_LP        //设置参数main函数地址</span><br><span class="line">#else</span><br><span class="line">	/* Pass address of our own entry points to .fini and .init.  */</span><br><span class="line">	mov $__libc_csu_fini, %R8_LP</span><br><span class="line">	mov $__libc_csu_init, %RCX_LP</span><br><span class="line"></span><br><span class="line">	mov $main, %RDI_LP</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* Call the user&#x27;s main function, and exit with its value.</span><br><span class="line">	   But let the libc call main.  Since __libc_start_main in</span><br><span class="line">	   libc.so is called very early, lazy binding isn&#x27;t relevant</span><br><span class="line">	   here.  Use indirect branch via GOT to avoid extra branch</span><br><span class="line">	   to PLT slot.  In case of static executable, ld in binutils</span><br><span class="line">	   2.26 or above can convert indirect branch into direct</span><br><span class="line">	   branch.  */</span><br><span class="line">	   //调用</span><br><span class="line">	call *__libc_start_main@GOTPCREL(%rip)</span><br><span class="line"></span><br><span class="line">	hlt			/* Crash if somehow `exit&#x27; does return.	 */</span><br><span class="line">END (_start)</span><br></pre></td></tr></table></figure>

<p>本人不是很习惯看att风格的汇编，我们对照ida里的汇编来看。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401140</span>                 public _start</span><br><span class="line">.text:<span class="number">0000000000401140</span> _start          <span class="keyword">proc</span> near               ; <span class="type">DATA</span> <span class="type">XREF</span>: <span class="type">LOAD</span>:00000000003FE018↑o</span><br><span class="line">.text:<span class="number">0000000000401140</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000401140</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401144</span>                 xor     ebp, ebp</span><br><span class="line">.text:<span class="number">0000000000401146</span>                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:<span class="number">0000000000401149</span>                 pop     rsi             ; argc</span><br><span class="line">.text:000000000040114A                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:000000000040114D                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:<span class="number">0000000000401151</span>                 push    rax</span><br><span class="line">.text:<span class="number">0000000000401152</span>                 push    rsp             ; stack_end</span><br><span class="line">.text:<span class="number">0000000000401153</span>                 mov     r8, offset __libc_csu_fini ; fini</span><br><span class="line">.text:000000000040115A                 mov     rcx, offset __libc_csu_init ; init</span><br><span class="line">.text:<span class="number">0000000000401161</span>                 mov     rdi, offset main ; main</span><br><span class="line">.text:<span class="number">0000000000401168</span>                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:000000000040116E                 hlt</span><br><span class="line">.text:000000000040116E ; &#125; // starts at <span class="number">401140</span></span><br><span class="line">.text:000000000040116E _start          endp</span><br></pre></td></tr></table></figure>

<p>会发现，start函数就调用了一个__libc_start_main函数，这个函数一旦返回，就直接hlt停机了。那么就能先大致推测，main函数是由__libc_start_main函数引导启动的，其他程序的准备包括析构函数的注册也是在此进行。</p>
<h5 id="libc-start-main"><a href="#libc-start-main" class="headerlink" title="libc_start_main()"></a>libc_start_main()</h5><p>我们追踪这个函数，在libc-start.c中有定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">STATIC <span class="type">int</span></span><br><span class="line"><span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params">		 <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">#ifdef LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line"><span class="params">		 ElfW(<span class="type">auxv_t</span>) *auxvec,</span></span><br><span class="line"><span class="params">#endif</span></span><br><span class="line"><span class="params">		 __typeof (main) init,</span></span><br><span class="line"><span class="params">		 <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params">		 <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Result of the &#x27;main&#x27; function.  */</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">//保存main函数的返回地址</span></span><br><span class="line"></span><br><span class="line">  __libc_multiple_libcs = &amp;_dl_starting_up &amp;&amp; !_dl_starting_up;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  _dl_relocate_static_pie (); <span class="comment">//设置程序基址，重新定位</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>]; <span class="comment">//保存环境变量</span></span><br><span class="line"></span><br><span class="line">  __environ = ev; <span class="comment">//这个就是ssp攻击中常见的获取栈地址的环境变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Store the lowest stack address.  This is done in ld.so if this is</span></span><br><span class="line"><span class="comment">     the code for the DSO.  */</span></span><br><span class="line">  __libc_stack_end = stack_end; <span class="comment">//保存栈底地址</span></span><br><span class="line"></span><br><span class="line"> ...<span class="comment">//省略了一些看不懂且应该没啥用的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize very early so that tunables can use it.  */</span></span><br><span class="line">  __libc_init_secure ();</span><br><span class="line"></span><br><span class="line">  __tunables_init (__environ);</span><br><span class="line"></span><br><span class="line">  ARCH_INIT_CPU_FEATURES ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Perform IREL&#123;,A&#125; relocations.  */</span></span><br><span class="line">  ARCH_SETUP_IREL ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The stack guard goes into the TCB, so initialize it early.  */</span></span><br><span class="line">  ARCH_SETUP_TLS ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In some architectures, IREL&#123;,A&#125; relocations happen after TLS setup in</span></span><br><span class="line"><span class="comment">     order to let IFUNC resolvers benefit from TCB information, e.g. powerpc&#x27;s</span></span><br><span class="line"><span class="comment">     hwcap and platform fields available in the TCB.  */</span></span><br><span class="line">  ARCH_APPLY_IREL ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the stack checker&#x27;s canary.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random); <span class="comment">//生成canary，然后保存</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_STACK_GUARD</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DL_SYSDEP_OSCHECK</span></span><br><span class="line">  <span class="keyword">if</span> (!__libc_multiple_libcs)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This needs to run to initiliaze _dl_osversion before TLS</span></span><br><span class="line"><span class="comment">	 setup might check it.  */</span></span><br><span class="line">      DL_SYSDEP_OSCHECK (__libc_fatal);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize libpthread if linked in.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__pthread_initialize_minimal != <span class="literal">NULL</span>)</span><br><span class="line">    __pthread_initialize_minimal (); <span class="comment">//初始化TLS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the pointer guard value.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard (_dl_random,</span><br><span class="line">							 stack_chk_guard); <span class="comment">//生成pointer_guard，并保存</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_POINTER_GUARD</span></span><br><span class="line">  THREAD_SET_POINTER_GUARD (pointer_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  __pointer_chk_guard_local = pointer_chk_guard;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !SHARED  */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Register the destructor of the dynamic linker if there is any.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//注册ld的析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Call the initializer of the libc.  This is only needed here if we</span></span><br><span class="line"><span class="comment">     are compiling for the static library in which case we haven&#x27;t</span></span><br><span class="line"><span class="comment">     run the constructors in `_dl_start_user&#x27;.  */</span></span><br><span class="line">  __libc_init_first (argc, argv, __environ); <span class="comment">//初始化libc</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Register the destructor of the program, if any.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//注册fini函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Some security at this point.  Prevent starting a SUID binary where</span></span><br><span class="line"><span class="comment">     the standard file descriptors are not opened.  We have to do this</span></span><br><span class="line"><span class="comment">     only for statically linked applications since otherwise the dynamic</span></span><br><span class="line"><span class="comment">     loader did the work already.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">    __libc_check_standard_fds ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Call the initializer of the program, if any.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">    GLRO(dl_debug_printf) (<span class="string">&quot;\ninitialize program: %s\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (init)</span><br><span class="line">    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM); <span class="comment">//调用构造函数init</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">//省略了一些代码，大概是对线程的初始化和一些维护工作</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Nothing fancy, just call the function.  */</span></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM); <span class="comment">//调用main函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result); <span class="comment">//如果main函数返回了，会先返回到这里，这个函数帮main调用exit函数来终止线程。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们清楚了一件事：libc_start_main函数确实注册了几个析构函数，还调用了个构造函数。根据注释我们可以知道，rtld_fini函数是ld的析构函数，fini是elf的析构函数。</p>
<p>奇怪的是，elf当中的fini函数是一个空函数，直接retn了，什么都没有。而调用的那个init则负责遍历.init_array段，实现段上多个构造函数的调用。而和.init_array挨得很近的.fini_array段，则由ld的rtld_fini负责，显然elf中的fini函数本身没什么用处。</p>
<h5 id="dl-fini"><a href="#dl-fini" class="headerlink" title="_dl_fini()"></a>_dl_fini()</h5><p>rtld_fini实际指向_dl_fini函数，我们跟踪一下这个函数，在elf&#x2F;dl-fini.c中有定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Lots of fun ahead.  We have to call the destructors for all still</span></span><br><span class="line"><span class="comment">     loaded objects, in all namespaces.  The problem is that the ELF</span></span><br><span class="line"><span class="comment">     specification now demands that dependencies between the modules</span></span><br><span class="line"><span class="comment">     are taken into account.  I.e., the destructor for a module is</span></span><br><span class="line"><span class="comment">     called before the ones for any of its dependencies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     To make things more complicated, we cannot simply use the reverse</span></span><br><span class="line"><span class="comment">     order of the constructors.  Since the user might have loaded objects</span></span><br><span class="line"><span class="comment">     using `dlopen&#x27; there are possibly several other modules with its</span></span><br><span class="line"><span class="comment">     dependencies to be taken into account.  Therefore we have to start</span></span><br><span class="line"><span class="comment">     determining the order of the modules once again from the beginning.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We run the destructors of the main namespaces last.  As for the</span></span><br><span class="line"><span class="comment">     other namespaces, we pick run the destructors in them in reverse</span></span><br><span class="line"><span class="comment">     order of the namespace ID.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) <span class="comment">//遍历_rtld_global中的所有非共享模块: _dl_ns[DL_NNS]</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">	 auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">	  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  )</span><br><span class="line">	__rtld_lock_unlock_recursive (GL(dl_load_lock)); <span class="comment">//如果这个命名空间中没有模块，则直接解锁</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则遍历模块</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">	     copy the pointers in.  */</span></span><br><span class="line">	  <span class="keyword">struct</span> link_map *maps[nloaded]; <span class="comment">//把这个命名空间中的所有模块指针, 都复制到maps数组中</span></span><br><span class="line"></span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">	  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">	  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">	    <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">	    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">	      &#123;</span><br><span class="line">		assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">		maps[i] = l;</span><br><span class="line">		l-&gt;l_idx = i;</span><br><span class="line">		++i;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">		   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">		++l-&gt;l_direct_opencount;</span><br><span class="line">	      &#125;</span><br><span class="line">	  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">	  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i; <span class="comment">//模块数量</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">	     binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">	     the main namespace.  */</span></span><br><span class="line">	  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line">			 <span class="literal">NULL</span>, <span class="literal">true</span>); <span class="comment">//排序确定析构顺序</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">	     from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">	     various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">	     count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">	     we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">	     from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">	     lock.  */</span></span><br><span class="line">	  __rtld_lock_unlock_recursive (GL(dl_load_lock)); <span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">	     call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">	     the front.  */</span></span><br><span class="line">	  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i) <span class="comment">//按顺序析构每一个模块</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">		  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">           <span class="comment">/* 是否包含fini_array节, 或者fini节 */</span></span><br><span class="line">		  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">		      || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">		      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">					    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">			_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">					  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">					  ns);</span><br><span class="line"></span><br><span class="line">		      <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">		      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">        		 <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     l-&gt;l_addr: 模块l的加载基地址</span></span><br><span class="line"><span class="comment">                     l-&gt;l_info[DT_FINI_ARRAY]: 模块l中fini_array节的描述符</span></span><br><span class="line"><span class="comment">                     l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr: 模块l中fini_arrary节的偏移</span></span><br><span class="line"><span class="comment">                     array: 为模块l的fini_array节的内存地址</span></span><br><span class="line"><span class="comment">                   */</span>                 </span><br><span class="line">			  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">			    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">					    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">                   <span class="comment">/* </span></span><br><span class="line"><span class="comment">                       ELF中 fini_arraysz节用来记录fini_array节的大小</span></span><br><span class="line"><span class="comment">                       l-&gt;l_info[DT_FINI_ARRAYSZ]: 模块l中fini_arraysz节描述符</span></span><br><span class="line"><span class="comment">                       l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val: 就是fini_array节的大小, 以B为单位</span></span><br><span class="line"><span class="comment">                       i: fini_array节的大小/一个指针大小, 即fini_array中有多少个析构函数</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">					    / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">			  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) <span class="comment">//从后往前调用析构函数</span></span><br><span class="line">			    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		      <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">		      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>) <span class="comment">//调用fini段中的函数</span></span><br><span class="line">			DL_CALL_DT_FINI</span><br><span class="line">			  (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">	      --l-&gt;l_direct_opencount;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是看的一脸懵逼？根据注释我们可以发现ld还调用了一个叫_dl_open的函数。这个函数干了什么事呢？我们知道动态链接的elf文件会共享libc里的符号，把libc里的符号加载到不同进程的过程叫映射，映射工作由动态链接器也就是ld来完成。我们把进程空间中的每个单独文件称之为模块。ld则调用了_dl_open函数来映射这些模块到进程空间中，并且把所有映射的文件都记录在__rtld_global中。同样的，当进程结束时，ld还要负责用_dl_close()卸载这些模块。</p>
<h5 id="rtld-global结构体"><a href="#rtld-global结构体" class="headerlink" title="__rtld_global结构体"></a>__rtld_global结构体</h5><p>我们追踪一下这个结构体，在ldsodefs.h中有定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span> <span class="comment">//每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针</span></span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded; <span class="comment">//模块数量</span></span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span> <span class="comment">//映射模块的搜索表</span></span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span> //这个命名空间中的符号表, 单个命名空间中的符号不允许重复</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> hashval; <span class="comment">//符号的哈希值</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name; <span class="comment">//符号名称</span></span><br><span class="line">	<span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym; <span class="comment">//符号</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span> <span class="comment">//所属模块</span></span><br><span class="line">      &#125; *entries; <span class="comment">//索引指针</span></span><br><span class="line">      <span class="type">size_t</span> size; <span class="comment">//元素数量</span></span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *); <span class="comment">//析构函数</span></span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">  &#125; _dl_ns[DL_NNS]; <span class="comment">//一个命名空间一个link_namespace结构体</span></span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns; <span class="comment">//使用了多少个命名空间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* During the program run we must not modify the global data of</span></span><br><span class="line"><span class="comment">     loaded shared object simultanously in two threads.  Therefore we</span></span><br><span class="line"><span class="comment">     protect `_dl_open&#x27; and `_dl_close&#x27; in dl-close.c.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     This must be a recursive lock since the initializer function of</span></span><br><span class="line"><span class="comment">     the loaded object might as well require a call to this function.</span></span><br><span class="line"><span class="comment">     At this time it is not anymore a problem to modify the tables.  */</span></span><br><span class="line">  __rtld_lock_define_recursive (EXTERN, _dl_load_lock)</span><br><span class="line">  <span class="comment">/* This lock is used to keep __dl_iterate_phdr from inspecting the</span></span><br><span class="line"><span class="comment">     list of loaded objects while an object is added to or removed</span></span><br><span class="line"><span class="comment">     from that list.  */</span></span><br><span class="line">  __rtld_lock_define_recursive (EXTERN, _dl_load_write_lock)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br></pre></td></tr></table></figure>

<p>定义很复杂，我们只关注想要看的部分。</p>
<ul>
<li>ns代表着NameSpace</li>
<li>nns代表着Num of NameSpace</li>
<li>struct rtld_global先以命名空间为单位建立了一个数组 <em>dl_ns[DL_NNS]</em></li>
<li>_在每个命名空间内部加载的模块以双向链表组织, 通过_ns_loaded索引</li>
<li>同时每个命名空间内部又有一个符号表_ns_unique_sym_table, 记录着所有模块导出的符号集合</li>
</ul>
<p>再来关注link_map结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line">	<span class="comment">//模块的基地址</span></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF file and the addresses in memory.  */</span> <span class="comment">//模块的基地址</span></span><br><span class="line">    <span class="type">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span> <span class="comment">//模块的文件名</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span> <span class="comment">//指向elf的dyn节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns; <span class="comment">//模块所属命名空间的idx</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">      l_info是ELF节描述符组成的的数组</span></span><br><span class="line"><span class="comment">      ELF中一个节, 使用一个ElfW(Dyn)描述</span></span><br><span class="line"><span class="comment">      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;	<span class="comment">/* Pointer to program header table in core.  */</span> <span class="comment">//elf的头表</span></span><br><span class="line">    ElfW(Addr) l_entry;		<span class="comment">/* Entry point location.  */</span> <span class="comment">//elf的入口</span></span><br><span class="line">    ElfW(Half) l_phnum;		<span class="comment">/* Number of program header entries.  */</span> <span class="comment">//头表的节数</span></span><br><span class="line">    ElfW(Half) l_ldnum;		<span class="comment">/* Number of dynamic segment entries.  */</span> <span class="comment">//dyn中的描述符数量</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>总而言之，我们可以知道，glibc按照: 命名空间-&gt;模块-&gt;节 的形式描述所有的模块, 通过_ns_unique_sym_table描述命名空间中所有的可见符号。这时候我们再返回去看dl_fini()的流程，不难发现他的工作就是：</p>
<ol>
<li>遍历rtld_global中的所有命名空间</li>
<li>遍历命名空间中的所有模块</li>
<li>找到这个模块所在的fini_array段，并调用其中所有的函数指针</li>
<li>找到这个模块所在的fini段，并调用所有函数指针</li>
</ol>
<h5 id="可劫持的lock与unlock函数指针"><a href="#可劫持的lock与unlock函数指针" class="headerlink" title="可劫持的lock与unlock函数指针"></a>可劫持的lock与unlock函数指针</h5><p>所以__rtld_global结构体非常重要。这个结构体里还有什么其他重要的东西没有呢？有，那就是用来上锁和解锁的两个函数指针，在摘抄过来的代码的60行和64行。如果去追溯dl_fini函数中的<code>__rtld_lock_lock_recursive (GL(dl_load_lock));</code>，会发现它宏定义展开后，其实调用的就是结构体中第60行的函数。而__rtld_global结构体又是写在ld.so.2文件的.data段中的，所以如果我们泄露了libc地址或者ld地址，有任意写的机会，我们就可以劫持这两个函数指针为ogg从而getshell。</p>
<p>别忘了，他们也是析构函数本身，劫持后只有机会执行一次，然后就会被置为ef_free了。详情看<a href="https://c-lby.top/2024/05/12/exit-hook-first-try/#%E5%8A%AB%E6%8C%81exit-hook%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AA%E8%83%BD%E7%94%A8%E4%B8%80%E9%81%8D">这篇文章</a>。</p>
<h3 id="其他利用点"><a href="#其他利用点" class="headerlink" title="其他利用点"></a>其他利用点</h3><p>不想写了，看看这个师傅的<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/243196#h3-9">文章</a>吧。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/243196">exit()分析与利用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/260754">Glibc2.32源码分析之exit部分</a></p>
<p><a target="_blank" rel="noopener" href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">Linux x86 Program Start Up</a></p>

											<div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0
        国际许可协议(CC BY-NC-SA 4.0) 发布.</a></br>
    因本人技术水平和知识面有限, 内容如有纰漏或者需要修正的地方, 欢迎大家指正。转载请注明来自<a href="https://c-lby.github.io" target="_blank">C_LBY's blog</a>！
</div>
							</div>

							
									
										<span data-path="/2024/glibc-exit-hook/">
											<em class="post-meta-item-text"> Page View <i
													class="waline-pageview-count"></i></em>
										</span>

										
											<div>
												<center>

													<div class="pagination">

    
    
    <a href="/2024/buu-wp-1/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2024/exit-hook-first-try/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


												</center>
											</div>

											<!-- comment -->
											<!--
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>

-->
											
													
														<section id="comments" class="comments">
															<!-- <link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css" />
<div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
  var walineConfig = 
    walineConfig.el='#waline';
  Waline.init(walineConfig);
</script> -->

<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css" />
<div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

  init({
    enable: true,
    el: '#waline',
    serverURL: 'https://blog-s-comment-three.vercel.app',
    dark: true,
    pageview: true,
    lang: 'zh-CN',
    requiredMeta: ['nick', 'mail'],
    locale:
      { placeholder: 'Say something……' },
    highlighter: true,
    search: false,
    emoji: [
      '//unpkg.com/@waline/emojis@1.2.0/weibo',
      '//unpkg.com/@waline/emojis@1.2.0/bmoji',
      '//unpkg.com/@waline/emojis@1.2.0/bilibili',
      'https://unpkg.com/@waline/emojis@1.2.0/qq',
    ],
    imageUploader: false,
  });
</script>
														</section>
														
															
					</div> <!-- col-md-9/col-md-12 -->


					
						<div id="side_meta">
							<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2024-05-15 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/glibc源码补完计划/">glibc源码补完计划<span>4</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/exit-hook/">exit_hook<span>2</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-article-text">概述</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-article-text">源码分析</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-article-text">相关数据结构</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#run-exit-handlers"><span class="toc-article-text">__run_exit_handlers()</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#call-tls-dtors"><span class="toc-article-text">__call_tls_dtors()</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#PTR-DEMANGLE"><span class="toc-article-text">PTR_DEMANGLE</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-article-text">已存在的析构函数？</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#start"><span class="toc-article-text">_start()</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#libc-start-main"><span class="toc-article-text">libc_start_main()</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#dl-fini"><span class="toc-article-text">_dl_fini()</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#rtld-global%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-article-text">__rtld_global结构体</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E5%8F%AF%E5%8A%AB%E6%8C%81%E7%9A%84lock%E4%B8%8Eunlock%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-article-text">可劫持的lock与unlock函数指针</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%85%B6%E4%BB%96%E5%88%A9%E7%94%A8%E7%82%B9"><span class="toc-article-text">其他利用点</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-article-text">参考链接</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->



						</div>

						

			</div><!-- row -->

			<!--
 -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
    &copy; 2024
      鎏柏鱼's Blog
        
                powered by <a href="http://hexo.io/" target="_blank">Hexo</a> | Theme by <a
                  href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
